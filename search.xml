<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深度学习-预备知识</title>
      <link href="/2025/03/04/shen-du-xue-xi-yu-bei-zhi-shi/"/>
      <url>/2025/03/04/shen-du-xue-xi-yu-bei-zhi-shi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="1-数据操作"><a href="#1-数据操作" class="headerlink" title="1.数据操作"></a>1.数据操作</h1><blockquote><p>本篇笔记的所有代码，都是以<strong>PyTorch</strong>为框架来写的。MXNET、TensorFlow、Paddle略过</p></blockquote><p>数据操作的元素是<strong>张量(tensor)</strong>，也就是通常意义上的<strong>n维数组</strong></p><p>在PyTorch、TensorFlow框架下，<em>张量类</em>称为<strong>tensor</strong>；MXNet框架下为<strong>ndarray</strong></p><ul><li>深度学习框架下的张量类与Numpy的ndarray类似，但功能更多，包括：<strong>GPU支持张量类加速计算，张量类支持自动微分</strong></li></ul><hr><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h2><h3 id="1-导入Pytorch"><a href="#1-导入Pytorch" class="headerlink" title="1.导入Pytorch"></a>1.<strong>导入Pytorch</strong></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>张量表示一个由数值组成的数组，这个数组可能有多个维度。 <strong>具有一个轴的张量</strong>对应数学上的<strong>向量</strong>（vector）； <strong>具有两个轴的张量</strong>对应数学上的<strong>矩阵</strong>（matrix）； 具有两个轴以上的张量没有特殊的数学名称。</p><h3 id="2-创建行向量"><a href="#2-创建行向量" class="headerlink" title="2.创建行向量"></a>2.<strong>创建行向量</strong></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先，我们可以使用 <code>arange</code> 创建一个行向量 <code>x</code>。这个行向量包含<strong>以0开始</strong>的前12个整数，它们<strong>默认创建为整数</strong>。也可指定创建类型为浮点数。张量中的每个值都称为张量的 <em>元素</em>（element）。例如，张量 <code>x</code> 中有 12 个元素。除非额外指定，新的张量将<strong>存储在内存中，并采用基于CPU的计算</strong>。</p><ul><li>实际上，<code>torch.arange</code>创建的张量，其元素类型默认取决于<strong>步长</strong><ul><li>若<code>step</code>为整数(默认是<code>1</code>)，则<code>dtype</code>&#x3D;<code>torch.int64</code></li><li>若<code>step</code>为浮点数，则<code>dtype</code>&#x3D;<code>torch.float32</code></li></ul></li></ul><h3 id="3-访问张量形状"><a href="#3-访问张量形状" class="headerlink" title="3.访问张量形状"></a>3.<strong>访问张量形状</strong></h3><p>可以通过张量的<code>shape</code>属性来访问张量（<strong>沿每个轴的长度</strong>）的<em>形状</em> 。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">torch.Size([12])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-获取张量元素总数"><a href="#4-获取张量元素总数" class="headerlink" title="4.获取张量元素总数"></a>4.<strong>获取张量元素总数</strong></h3><p>张量中元素的总数，即形状的所有元素乘积，可以检查它的大小（size）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-改变张量形状"><a href="#5-改变张量形状" class="headerlink" title="5.改变张量形状"></a>5.<strong>改变张量形状</strong></h3><p>要想改变一个张量的形状而<strong>不改变元素数量和元素值</strong>，可以调用<code>reshape</code>函数。 例如，可以把张量<code>x</code>从形状为（12,）的行向量转换为形状为（3,4）的矩阵。 这个新的张量包含与转换前相同的值，但是它被看成一个3行4列的矩阵。 要重点说明一下，虽然张量的形状发生了改变，但其元素值并没有变。 注意，通过改变张量的形状，张量的大小不会改变。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([[ 0, 1, 2, 3],[ 4, 5, 6, 7],[ 8, 9, 10, 11]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们不需要通过手动指定每个维度来改变形状。 也就是说，如果我们的目标形状是（高度,宽度）， 那么在<strong>知道宽度后，高度会被自动计算得出，不必我们自己做除法</strong>。 在上面的例子中，为了获得一个3行的矩阵，我们手动指定了它有3行和4列。 幸运的是，我们<strong>可以通过<code>-1</code>来调用此自动计算出维度的功能</strong>。 即我们可以用<code>x.reshape(-1,4)</code>或<code>x.reshape(3,-1)</code>来取代<code>x.reshape(3,4)</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-全0张量"><a href="#6-全0张量" class="headerlink" title="6.全0张量"></a>6.全0张量</h3><p>全0张量的元素类型，默认是<code>torch.float32</code>，即浮点数。与正常<code>arange</code>创建张量不同</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([[[0., 0., 0., 0.],         [0., 0., 0., 0.],         [0., 0., 0., 0.]],<span class="token code keyword">        [[0., 0., 0., 0.],         [0., 0., 0., 0.],         [0., 0., 0., 0.]]])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-全1张量"><a href="#7-全1张量" class="headerlink" title="7.全1张量"></a>7.全1张量</h3><p>全1张量的元素类型，默认是<code>torch.float32</code>，即浮点数。与正常<code>arange</code>创建张量不同</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([[[1., 1., 1., 1.],         [1., 1., 1., 1.],         [1., 1., 1., 1.]],<span class="token code keyword">        [[1., 1., 1., 1.],         [1., 1., 1., 1.],         [1., 1., 1., 1.]]])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-随机采样矩阵"><a href="#8-随机采样矩阵" class="headerlink" title="8.随机采样矩阵"></a>8.随机采样矩阵</h3><p>有时我们想通过从某个特定的概率分布中随机采样来得到张量中每个元素的值。 例如，当我们构造数组来作为神经网络中的参数时，我们通常会随机初始化参数的值。 以下代码创建一个形状为（3,4）的张量。 其中的每个元素都<strong>从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([[-0.0135,  0.0665,  0.0912,  0.3212],        [ 1.4653,  0.1843, -1.6995, -0.3036],        [ 1.7646,  1.0450,  0.2457, -0.7732]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="9-给定值初始化"><a href="#9-给定值初始化" class="headerlink" title="9.给定值初始化"></a>9.给定值初始化</h3><p>我们还可以通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值。 在这里，最外层的列表对应于轴0，内层的列表对应于轴1。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([[2, 1, 4, 3],        [1, 2, 3, 4],        [4, 3, 2, 1]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h2><h3 id="1-按元素计算"><a href="#1-按元素计算" class="headerlink" title="1.按元素计算"></a>1.按元素计算</h3><blockquote><p>这里特指：<strong>在形状相同的张量上</strong>按元素操作</p></blockquote><p>对于任意具有相同形状的张量， 常见的标准算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>和<code>**</code>）都可以被升级为按元素运算。 我们可以在同一形状的任意两个张量上调用按元素操作。 在下面的例子中，我们使用逗号来表示一个具有5个元素的元组，其中每个元素都是按元素操作的结果。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>x<span class="token operator">+</span>y<span class="token punctuation">,</span> x<span class="token operator">-</span>y<span class="token punctuation">,</span> x<span class="token operator">*</span>y<span class="token punctuation">,</span> x<span class="token operator">/</span>y<span class="token punctuation">,</span> x<span class="token operator">**</span>y <span class="token comment"># **运算符是求幂运算</span>torch<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([ 3.,  4.,  6., 10.]),tensor([-1.,  0.,  2.,  6.]),tensor([ 2.,  4.,  8., 16.]),tensor([0.5000, 1.0000, 2.0000, 4.0000]),tensor([ 1.,  4., 16., 64.])tensor([2.7183e+00, 7.3891e+00, 5.4598e+01, 2.9810e+03])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-线性代数运算"><a href="#2-线性代数运算" class="headerlink" title="2.线性代数运算"></a>2.线性代数运算</h3><p>详见第3节</p><h3 id="3-连结-concatenate"><a href="#3-连结-concatenate" class="headerlink" title="3.连结(concatenate)"></a>3.连结(concatenate)</h3><p>我们也可以把多个张量<em>连结</em>（concatenate）在一起， 把它们端对端地叠起来形成一个更大的张量。 我们只需要提供张量列表，并给出沿哪个轴连结。</p><ul><li><strong>行</strong>，即<strong>轴0</strong>，<strong>形状(shape)的第一个元素</strong></li><li><strong>列</strong>，即<strong>轴1</strong>，<strong>形状(shape)的第二个元素</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>y <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 按行连结</span>torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment"># 按列连结</span>torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([[ 0.,  1.,  2.,  3.],         [ 4.,  5.,  6.,  7.],         [ 8.,  9., 10., 11.],         [ 2.,  1.,  4.,  3.],         [ 1.,  2.,  3.,  4.],         [ 4.,  3.,  2.,  1.]])tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],         [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],         [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h3><p>有时，我们想通过<em>逻辑运算符</em>构建二元张量。 以<code>X == Y</code>为例： 对于每个位置，如果<code>X</code>和<code>Y</code>在该位置相等，则新张量中相应项的值为1。 这意味着逻辑语句<code>X == Y</code>在该位置处为真，否则该位置为0。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">z <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([[False,  True, False,  True],        [False, False, False, False],        [False, False, False, False]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-求和"><a href="#5-求和" class="headerlink" title="5.求和"></a>5.求和</h3><p>对张量中的所有元素进行求和，会产生一个<strong>单元素张量</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor(66.)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="3-广播机制"><a href="#3-广播机制" class="headerlink" title="3.广播机制"></a>3.广播机制</h2><blockquote><p>即<strong>在不同形状的张量下</strong>执行<strong>按元素操作</strong></p></blockquote><p><strong>广播机制</strong> 的工作方式如下：</p><ul><li>通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状；</li><li>对生成的数组执行按元素操作。</li></ul><p><strong>大多数情况下，我们将沿着数组中长度为1的轴进行广播(即列轴)</strong></p><p>示例如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([[0],        [1],        [2]])tensor([[0, 1]]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于<code>a</code>和<code>b</code>分别是3×1和1×2矩阵，如果让它们相加，它们的形状不匹配。</p><p>我们将两个矩阵<em>广播</em>为一个更大的3×2矩阵，如下所示：<strong>矩阵<code>a</code>将复制列， 矩阵<code>b</code>将复制行，然后再按元素相加。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([[0, 1],        [1, 2],        [2, 3]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="4-索引与切片"><a href="#4-索引与切片" class="headerlink" title="4.索引与切片"></a>4.索引与切片</h2><p>就像在任何其他Python数组中一样，张量中的元素可以通过索引访问。 与任何Python数组一样：<strong>第一个元素的索引是0，最后一个元素索引是-1</strong>； <strong>可以指定范围以包含第一个元素和最后一个之前的元素。</strong></p><h3 id="1-读取"><a href="#1-读取" class="headerlink" title="1.读取"></a>1.读取</h3><p>如下所示，我们可以用<code>[-1]</code>选择最后一个元素，可以用<code>[1:3]</code>选择第二个和第三个元素(<strong>左闭右开</strong>)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor(11)tensor([1, 2])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-写入"><a href="#2-写入" class="headerlink" title="2.写入"></a>2.写入</h3><p>除读取外，我们还可以通过指定索引来将元素写入矩阵。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([ 0,  9,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们想为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值。 例如，<code>[0:2, :]</code>访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素。 虽然我们讨论的是矩阵的索引，但这也适用于向量和超过2个维度的张量。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([[12., 12., 12., 12.],        [12., 12., 12., 12.],        [ 8.,  9., 10., 11.]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="5-节省内存"><a href="#5-节省内存" class="headerlink" title="5.节省内存"></a>5.节省内存</h2><p>运行一些操作可能会导致为新结果分配内存。 例如，如果我们用<code>Y = X + Y</code>，我们将<strong>取消引用<code>Y</code>指向的张量，而是指向新分配的内存处的张量</strong>。</p><p>这可能是不可取的，原因有两个：</p><ol><li>首先，我们不想总是不必要地分配内存。在机器学习中，我们可能有数百兆的参数，并且在一秒内多次更新所有参数。通常情况下，我们希望原地执行这些更新；</li><li>如果我们不原地更新，其他引用仍然会指向旧的内存位置，这样我们的某些代码可能会无意中引用旧的参数。</li></ol><p>幸运的是，执行原地操作非常简单。 我们可以使用<strong>切片表示法</strong>将操作的结果分配给先前分配的数组，例如<code>Y[:] = &lt;expression&gt;</code>。 为了说明这一点，我们首先创建一个新的矩阵<code>Z</code>，其形状与另一个<code>Y</code>相同， 使用<code>zeros_like</code>来分配一个全0的块。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Z <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>Y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'id(Z):'</span><span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">(</span>Z<span class="token punctuation">)</span><span class="token punctuation">)</span>Z<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> X <span class="token operator">+</span> Y<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'id(Z):'</span><span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">(</span>Z<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">id(Z): 140327634811696id(Z): 140327634811696<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果在后续计算中没有重复使用<code>X</code>， 我们也可以使用<code>X[:] = X + Y</code>或<code>X += Y</code>来减少操作的内存开销。</p><hr><h2 id="6-转换为其他python对象"><a href="#6-转换为其他python对象" class="headerlink" title="6.转换为其他python对象"></a>6.转换为其他python对象</h2><h3 id="1-tensor–numpy"><a href="#1-tensor–numpy" class="headerlink" title="1.tensor–numpy"></a>1.tensor–numpy</h3><p>将深度学习框架定义的张量转换为NumPy张量（<code>ndarray</code>）很容易，反之也同样容易。 torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">A <span class="token operator">=</span> X<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>B <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token builtin">type</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">(numpy.ndarray, torch.Tensor)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-tensor–python标量"><a href="#2-tensor–python标量" class="headerlink" title="2.tensor–python标量"></a>2.tensor–python标量</h3><p>要将大小为1的张量转换为Python标量，我们可以调用<code>item</code>函数或Python的内置函数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3.5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a<span class="token punctuation">,</span> a<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([3.5000]), 3.5, 3.5, 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h2><ul><li>深度学习存储和操作数据的主要接口是张量（n维数组）。它提供了各种功能，包括基本数学运算、广播、索引、切片、内存节省和转换其他Python对象。</li></ul><hr><h1 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2.数据预处理"></a>2.数据预处理</h1><p>为了能用深度学习来解决现实世界的问题，我们经常从预处理原始数据开始， 而不是从那些准备好的张量格式数据开始。 在Python中常用的数据分析工具中，我们通常使用**<code>pandas</code>软件包**。 像庞大的Python生态系统中的许多其他扩展包一样，<code>pandas</code>可以与张量兼容。 本节我们将简要介绍使用<code>pandas</code>预处理原始数据，并将原始数据转换为张量格式的步骤。 后面的章节将介绍更多的数据预处理技术。</p><h2 id="1-读取数据集"><a href="#1-读取数据集" class="headerlink" title="1.读取数据集"></a>1.读取数据集</h2><p>举一个例子，我们首先创建一个人工数据集，并存储在CSV（逗号分隔值）文件 <code>../data/house_tiny.csv</code>中。 以其他格式存储的数据也可以通过类似的方式进行处理。 下面我们将数据集按行写入CSV文件中。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> osos<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'data'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exist_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>data_file <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token string">'house_tiny.csv'</span><span class="token punctuation">)</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>data_file<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'NumRooms,Alley,Price\n'</span><span class="token punctuation">)</span>  <span class="token comment"># 列名</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'NA,Pave,127500\n'</span><span class="token punctuation">)</span>  <span class="token comment"># 每行表示一个数据样本</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'2,NA,106000\n'</span><span class="token punctuation">)</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'4,NA,178100\n'</span><span class="token punctuation">)</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'NA,NA,140000\n'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要从创建的CSV文件中加载原始数据集，我们导入<code>pandas</code>包并调用**<code>read_csv</code>函数**。该数据集有四行三列。其中每行描述了房间数量（“NumRooms”）、巷子类型（“Alley”）和房屋价格（“Price”）。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>data_file<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">   NumRooms Alley   Price0       NaN  Pave  1275001       2.0   NaN  1060002       4.0   NaN  1781003       NaN   NaN  140000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-处理缺失值"><a href="#2-处理缺失值" class="headerlink" title="2.处理缺失值"></a>2.处理缺失值</h2><p>注意，“NaN”项代表缺失值。 为了处理缺失的数据，典型的方法包括<em>插值法</em>和<em>删除法</em>， 其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值。 在这里，我们将考虑<strong>插值法</strong>。</p><p>通过<strong>位置索引<code>iloc</code></strong>，我们将<code>data</code>分成<code>inputs</code>和<code>outputs</code>， 其中前者为<code>data</code>的前两列，而后者为<code>data</code>的最后一列。 对于<code>inputs</code>中缺少的数值，我们用同一列的均值替换“NaN”项。</p><ul><li><code>fillna</code>方法：填充NaN项</li><li><code>inputs.mean()</code>：NaN值所在列的平均值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">inputs<span class="token punctuation">,</span> outputs <span class="token operator">=</span> data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>inputs <span class="token operator">=</span> inputs<span class="token punctuation">.</span>fillna<span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">   NumRooms Alley0       3.0  Pave1       2.0   NaN2       4.0   NaN3       3.0   NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于<code>inputs</code>中的类别值或离散值，我们将“NaN”<strong>视为一个类别</strong>。 由于“巷子类型”（“Alley”）列只接受两种类型的类别值“Pave”和“NaN”， <code>pandas</code>可以自动将此列转换为两列“Alley_Pave”和“Alley_nan”。 巷子类型为“Pave”的行会将“Alley_Pave”的值设置为1，“Alley_nan”的值设置为0。 缺少巷子类型的行会将“Alley_Pave”和“Alley_nan”分别设置为0和1。</p><ul><li><code>pd.get_dummies()</code>：将 <strong>类别特征</strong>（<code>object</code> 或 <code>category</code> 类型的列）转换为 <strong>独热编码（One-Hot Encoding）</strong><ul><li>每个唯一的类别都会变成一个新的二进制列（0 或 1）</li></ul></li><li><code>(dummy_na=True)</code>：让 <strong>缺失值（NaN）</strong> 也作为一个单独的类别，并生成一个额外的列</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">inputs <span class="token operator">=</span> pd<span class="token punctuation">.</span>get_dummies<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> dummy_na<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">   NumRooms  Alley_Pave  Alley_nan0       3.0           1          01       2.0           0          12       4.0           0          13       3.0           0          1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-转换为张量格式"><a href="#3-转换为张量格式" class="headerlink" title="3.转换为张量格式"></a>3.转换为张量格式</h2><p>现在<code>inputs</code>和<code>outputs</code>中的所有条目都是<strong>数值类型</strong>，它们<strong>可以转换为张量格式</strong>。 当数据采用张量格式后，可以通过在 第一节中引入的那些张量函数来进一步操作。</p><ul><li>潜台词是，<strong>只有数值类型(int,float,bool)才能转换为张量格式</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">X <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>to_numpy<span class="token punctuation">(</span>dtype<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span>y <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>outputs<span class="token punctuation">.</span>to_numpy<span class="token punctuation">(</span>dtype<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span>X<span class="token punctuation">,</span> y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">(tensor([[3., 1., 0.],         [2., 0., 1.],         [4., 0., 1.],         [3., 0., 1.]], dtype=torch.float64), tensor([127500., 106000., 178100., 140000.], dtype=torch.float64))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><ul><li><code>pandas</code>软件包是Python中常用的数据分析工具中，<code>pandas</code>可以与张量兼容。</li><li>用<code>pandas</code>处理缺失的数据时，我们可根据情况选择用插值法和删除法。</li></ul><hr><h1 id="3-线性代数"><a href="#3-线性代数" class="headerlink" title="3.线性代数"></a>3.线性代数</h1><h2 id="1-标量"><a href="#1-标量" class="headerlink" title="1.标量"></a>1.标量</h2><p>标量由<strong>只有一个元素的张量表示</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchx <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">)</span>y <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span>x <span class="token operator">+</span> y<span class="token punctuation">,</span> x <span class="token operator">*</span> y<span class="token punctuation">,</span> x <span class="token operator">/</span> y<span class="token punctuation">,</span> x <span class="token operator">**</span> y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">(tensor(5.), tensor(6.), tensor(1.5000), tensor(9.))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="2-向量"><a href="#2-向量" class="headerlink" title="2.向量"></a>2.向量</h2><p>向量可以被视为标量值组成的列表。 这些标量值被称为向量的<em>元素</em>（element）或<em>分量</em>（component）</p><p>人们通过<strong>一维张量表示向量</strong>。一般来说，张量可以具有任意长度，取决于机器的内存限制。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">tensor([0, 1, 2, 3])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以使用下标来引用向量的任一元素，例如可以通过<code>xi</code>来引用第i个元素。 注意，元素<code>xi</code>是一个标量，所以我们在引用它时不会加粗。 </p><p><strong>大量文献认为列向量是向量的默认方向</strong></p><p>在代码中，我们通过张量的索引来访问任一元素</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>tensor<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-长度"><a href="#1-长度" class="headerlink" title="1.长度"></a>1.长度</h3><p>向量只是一个数字数组，就像每个数组都有一个长度一样，每个向量也是如此。 在数学表示法中，如果我们想说一个向量x由n个实值标量组成， 可以将其表示为$x∈R^n$。 <strong>向量的长度通常称为向量的<em>维度</em>（dimension）</strong></p><p>与普通的Python数组一样，我们可以通过调用Python的内置<code>len()</code>函数来访问张量的长度</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果：4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-形状"><a href="#2-形状" class="headerlink" title="2.形状"></a>2.形状</h3><p>当用张量表示一个向量（只有一个轴）时，我们也可以通过<code>.shape</code>属性访问向量的长度。 形状（shape）是一个<strong>元素组</strong>，<strong>列出了张量沿每个轴的长度（维数）</strong>。 对于只有一个轴的张量，形状只有一个元素。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment"># 结果：torch.Size([4])</span>y <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment"># 结果：torch.Size([3, 4])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-维度"><a href="#3-维度" class="headerlink" title="3.维度"></a>3.维度</h3><p>请注意，<em>维度</em>（dimension）这个词在不同上下文时往往会有不同的含义，这经常会使人感到困惑。 为了清楚起见，我们在此明确一下： </p><ul><li><em>*<em>向量</em>或*轴</em>的维度被用来表示<em>向量</em>或<em>轴</em>的长度，即向量或轴的元素数量**</li><li><strong>张量的维度用来表示张量具有的轴数</strong>。 在这个意义上，张量的某个轴的维数就是这个轴的长度。</li></ul><hr><h2 id="3-矩阵"><a href="#3-矩阵" class="headerlink" title="3.矩阵"></a>3.矩阵</h2><p>正如向量将标量从零阶推广到一阶，矩阵将向量从一阶推广到二阶。 矩阵，我们通常用粗体、大写字母来表示 （例如，$X,Y,Z$）， 在代码中表示为具有两个轴的张量。</p><p>对于任意$A∈R^{m×n}$， A的形状是（m,n）或m×n。 当矩阵具有相同数量的行和列时，其形状将变为正方形； 因此，它被称为<em>方阵</em>（square matrix）。</p><p>当调用函数来实例化张量时， 我们可以通过指定两个分量m和n来创建一个形状为$m×n$的矩阵。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">A <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''结果:tensor([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11],        [12, 13, 14, 15],        [16, 17, 18, 19]])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以通过行索引<code>（i）</code>和列索引<code>（j）</code>来访问矩阵中的标量元素$a_{ij}$， 例如$[A]<em>{ij}$。 如果没有给出矩阵A的标量元素，我们可以简单地使用矩阵A的小写字母索引下标$a</em>{ij}$ 来引用$[A]<em>{ij}$。 为了表示起来简单，只有在必要时才会将逗号插入到单独的索引中， 例如$a</em>{2,3j}$和$[A]_{2i−1,3}$。</p><p><strong>转置</strong></p><p>当我们交换矩阵的行和列时，结果称为矩阵的<em>转置</em>（transpose）。 通常用$a^{\top}$来表示矩阵的转置，如果$B&#x3D;A^{\top}$， 则对于任意i和j，都有$b_{ij}&#x3D;a_{ji}$。</p><p>现在在代码中访问矩阵的转置</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">B <span class="token operator">=</span> A<span class="token punctuation">.</span>T<span class="token keyword">print</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''结果:tensor([[ 0,  4,  8, 12, 16],        [ 1,  5,  9, 13, 17],        [ 2,  6, 10, 14, 18],        [ 3,  7, 11, 15, 19]])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作为<strong>方阵的一种特殊类型</strong>，<em>对称矩阵</em>（symmetric matrix）<strong>A等于其转置</strong>：$A&#x3D;A^{\top}$。</p><hr><h2 id="4-张量"><a href="#4-张量" class="headerlink" title="4.张量"></a>4.张量</h2><p>就像向量是标量的推广，矩阵是向量的推广一样，我们可以构建具有更多轴的数据结构。 张量（本小节中的“张量”指代数对象）是描述具有任意数量轴的n维数组的通用方法。</p><p>当我们开始处理图像时，张量将变得更加重要，图像以n维数组形式出现， 其中3个轴对应于<strong>高度、宽度，以及一个<em>通道</em>（channel）轴</strong>， 用于表示颜色通道（红色、绿色和蓝色）。 现在先将高阶张量暂放一边，而是专注学习其基础知识。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">X <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''结果:tensor([[[ 0,  1,  2,  3],         [ 4,  5,  6,  7],         [ 8,  9, 10, 11]],        [[12, 13, 14, 15],         [16, 17, 18, 19],         [20, 21, 22, 23]]])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="5-张量算法的基本性质"><a href="#5-张量算法的基本性质" class="headerlink" title="5.张量算法的基本性质"></a>5.张量算法的基本性质</h2><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250305165327149.png" alt="image-20250305165327149"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250305165352114.png" alt="image-20250305165352114"></p><hr><h2 id="6-降维"><a href="#6-降维" class="headerlink" title="6.降维"></a>6.降维</h2><h3 id="1-求和"><a href="#1-求和" class="headerlink" title="1.求和"></a>1.求和</h3><p>求和函数<code>sum()</code>实际上可以视为<strong>将张量沿所有的轴降低维度，使之成为一个标量</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''结果:tensor(6.)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-指定轴降维"><a href="#2-指定轴降维" class="headerlink" title="2.指定轴降维"></a>2.指定轴降维</h3><p>我们还可以指定张量沿哪一个轴来通过求和降低维度。 </p><p>以矩阵为例，为了通过求和所有行的元素来降维（轴0），可以在调用函数时指定<code>axis=0</code>。</p><p> 由于输入矩阵沿0轴降维以生成输出向量，因此输入轴0的维数在输出形状中消失。</p><ul><li>什么是<strong>沿0轴降维</strong>——即<strong>行数&#x3D;1，同列元素相加</strong><ul><li>此时，输入轴0的维数在输出形状中消失</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">y <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>z <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> z<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''结果:tensor([60, 66, 72, 78]) torch.Size([4])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>指定<code>axis=1</code>将通过汇总所有列的元素降维（轴1）<ul><li>输入轴1的维数在输出形状中消失</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">z <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> z<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''结果:tensor([ 6, 22, 38, 54, 70, 86]) torch.Size([6])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>沿着行和列对矩阵求和，等价于对矩阵的所有元素进行求和</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">z <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> z<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment"># 结果与y.sum()相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-平均值"><a href="#3-平均值" class="headerlink" title="3.平均值"></a>3.平均值</h3><p>一个与求和相关的量是<em>平均值</em>（mean或average）。 我们通过将总和除以元素总数来计算平均值。 在代码中，我们可以调用函数来计算任意形状张量的平均值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">A<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> A<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> A<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样，<strong>计算平均值的函数也可以沿指定轴降低张量的维度</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">A<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> A<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">/</span> A<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>但是尝试后，<code>mean()</code>函数似乎已经不支持<code>axis</code>参数了？</p></blockquote><h3 id="4-非降维求和"><a href="#4-非降维求和" class="headerlink" title="4.非降维求和"></a>4.非降维求和</h3><p>有时在调用函数来计算总和或均值时保持轴数不变会很有用</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">A <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>sum_A <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> keepdims<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>sum_A<span class="token triple-quoted-string string">'''res:tensor([[ 6.],        [22.],        [38.],        [54.],        [70.]])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于<code>sum_A</code>在对每行进行求和后仍保持两个轴，我们可以通过<strong>广播</strong>将<code>A</code>除以<code>sum_A</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">A <span class="token operator">/</span> sum_A <span class="token comment"># sum_A扩列，复制第一列的元素</span><span class="token triple-quoted-string string">'''res:tensor([[0.0000, 0.1667, 0.3333, 0.5000],        [0.1818, 0.2273, 0.2727, 0.3182],        [0.2105, 0.2368, 0.2632, 0.2895],        [0.2222, 0.2407, 0.2593, 0.2778],        [0.2286, 0.2429, 0.2571, 0.2714]])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们想沿某个轴计算<code>A</code>元素的累积总和， 比如<code>axis=0</code>（按行计算），可以调用<code>cumsum</code>函数。 此函数不会沿任何轴降低输入张量的维度</p><ul><li><code>cumsum(axis=0)</code>，$a_{mn} &#x3D; a_{0n} + a_{1n} + a_{2n} + … + a_{mn}$</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">A<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor([[ 0.,  1.,  2.,  3.],        [ 4.,  6.,  8., 10.],        [12., 15., 18., 21.],        [24., 28., 32., 36.],        [40., 45., 50., 55.]])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="7-点积"><a href="#7-点积" class="headerlink" title="7.点积"></a>7.点积</h2><p>点积的函数是<code>torch.dot()</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>y <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>torch<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>点积在很多场合都很有用。 例如，给定一组由向量$x∈R_d$表示的值， 和一组由$w∈R_d$表示的权重。 x中的值根据权重w的加权和， 可以表示为点积$x^{\top}w$。 当权重为非负数且和为1（即($∑_{i&#x3D;1}^{d} wi&#x3D;1$)）时， 点积表示<em>加权平均</em>（weighted average）。 将两个向量规范化得到单位长度后，点积表示它们夹角的余弦。</p><hr><h2 id="8-矩阵向量积"><a href="#8-矩阵向量积" class="headerlink" title="8.矩阵向量积"></a>8.矩阵向量积</h2><p>在代码中使用张量表示矩阵-向量积，我们使用<code>mv</code>函数。 当我们为矩阵<code>A</code>和向量<code>x</code>调用<code>torch.mv(A, x)</code>时，会执行矩阵-向量积。 注意，<strong><code>A</code>的列维数（沿轴1的长度）必须与<code>x</code>的维数（其长度）相同。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>mv<span class="token punctuation">(</span>A<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="9-矩阵乘法"><a href="#9-矩阵乘法" class="headerlink" title="9.矩阵乘法"></a>9.矩阵乘法</h2><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250305172242701.png" alt="image-20250305172242701"></p><p>矩阵乘法的函数是<code>torch.mm()</code></p><p>矩阵乘法可以简单地称为<strong>矩阵乘法</strong>，不应与“Hadamard积”混淆。</p><hr><h2 id="10-范数-norm"><a href="#10-范数-norm" class="headerlink" title="10.范数(norm)"></a>10.范数(norm)</h2><p>线性代数中最有用的一些运算符是<em>范数</em>（norm）。 非正式地说，向量的<em>范数</em>是表示一个向量有多大。 这里考虑的<em>大小</em>（size）概念不涉及维度，而是<strong>分量的大小</strong></p><p>在线性代数中，向量范数是将向量映射到标量的函数$f$。 给定任意向量$x$，向量范数要满足一些属性。 </p><p>第一个性质是：如果我们按常数因子α缩放向量的所有元素， 其范数也会按相同常数因子的<em>绝对值</em>缩放：</p><p>$$f(\alpha x) &#x3D; | \alpha | f(x)$$</p><p>第二个性质是熟悉的三角不等式:</p><p>$$f(x+y) \leq f(x) + f(y)$$</p><p>第三个性质简单地说范数必须是非负的:</p><p>$$f(x) \geq 0$$</p><p>最后一个性质要求范数最小为0，当且仅当向量全由0组成：</p><p>$$\forall i, [x]_{i}&#x3D;0 \Leftrightarrow f(x) &#x3D; 0$$</p><p><strong>范数听起来很像距离的度量</strong></p><h3 id="1-L2范数"><a href="#1-L2范数" class="headerlink" title="1.L2范数"></a>1.L2范数</h3><p>假设n维向量$x$中的元素是$x_1,…,x_n$，其L2<em>范数</em>是向量元素平方和的平方根：<br>$$<br>\lVert \mathbf{x} \rVert_2 &#x3D; \sqrt{\sum_{i&#x3D;1}^{n} x_i^2}<br>$$<br>其中，在L2范数中常常省略下标2，也就是说$|\mathbf{x}|$等同于$|\mathbf{x}|_2$。</p><p>代码中，我们可以按如下方式计算向量的L2范数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">u <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor(5.)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-L1范数"><a href="#2-L1范数" class="headerlink" title="2.L1范数"></a>2.L1范数</h3><p>假设n维向量$x$中的元素是$x_1,…,x_n$，其L1<em>范数</em>是向量元素的绝对值之和</p><p>$$<br>\lVert \mathbf{x} \rVert_1 &#x3D; \sum_{i&#x3D;1}^{n} |x_i|<br>$$<br>与L2范数相比，L1范数受异常值的影响较小。</p><p> 为了计算L1范数，我们将绝对值函数和按元素求和组合起来：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">u <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:array(7.)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-其他范数"><a href="#3-其他范数" class="headerlink" title="3.其他范数"></a>3.其他范数</h3><p>实际上，$L_2$范数和$L_1$范数都是更一般的$L_p$范数的<strong>特例</strong>：</p><p>$$<br>\lVert \mathbf{x} \rVert_p &#x3D; \left( \sum_{i&#x3D;1}^{n} |x_i|^p \right)^{\frac{1}{p}}<br>$$<br>类似于向量的$L_2$范数，矩阵$X∈R^{m×n}$的<em>Frobenius范数</em>（Frobenius norm）是矩阵元素平方和的平方根：</p><p>$$<br>\lVert A \rVert_F &#x3D; \sqrt{\sum_{i&#x3D;1}^{m} \sum_{j&#x3D;1}^{n} |a_{ij}|^2}<br>$$<br>Frobenius范数满足向量范数的所有性质，它就像是矩阵形向量的L2范数。 调用以下函数将计算矩阵的Frobenius范数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:array(6.)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-范数和目标"><a href="#4-范数和目标" class="headerlink" title="4.范数和目标"></a>4.范数和目标</h3><p>在深度学习中，我们经常试图解决优化问题： <em>最大化</em>分配给观测数据的概率; <em>最小化</em>预测和真实观测之间的距离。 用向量表示物品（如单词、产品或新闻文章），以便最小化相似项目之间的距离，最大化不同项目之间的距离。 <strong>目标，或许是深度学习算法最重要的组成部分（除了数据），通常被表达为范数。</strong></p><h2 id="11-小结"><a href="#11-小结" class="headerlink" title="11.小结"></a>11.小结</h2><ul><li>标量、向量、矩阵和张量是线性代数中的基本数学对象。</li><li>向量泛化自标量，矩阵泛化自向量。</li><li>标量、向量、矩阵和张量分别具有零、一、二和任意数量的轴。</li><li>一个张量可以通过<code>sum</code>和<code>mean</code>沿指定的轴降低维度。</li><li>两个矩阵的按元素乘法被称为他们的Hadamard积。它与矩阵乘法不同。</li><li>在深度学习中，我们经常使用范数，如L1范数、L2范数和Frobenius范数。</li><li>我们可以对标量、向量、矩阵和张量执行各种操作。</li></ul><hr><h1 id="4-微积分"><a href="#4-微积分" class="headerlink" title="4.微积分"></a>4.微积分</h1><p>在微分学，最重要的应用是优化问题，即考虑如何把事情做到最好。 这种问题在深度学习中是无处不在的。</p><p>在深度学习中，我们“训练”模型，不断更新它们，使它们在看到越来越多的数据时变得越来越好。 通常情况下，变得更好意味着最小化一个<em>损失函数</em>（loss function）， 即一个衡量“模型有多糟糕”这个问题的分数。 最终，我们真正关心的是生成一个模型，它能够在从未见过的数据上表现良好。 但“训练”模型只能将模型与我们实际能看到的数据相拟合。 因此，我们可以将拟合模型的任务分解为两个关键问题：</p><ul><li><em>优化</em>（optimization）：用模型拟合观测数据的过程；</li><li><em>泛化</em>（generalization）：数学原理和实践者的智慧，能够指导我们生成出有效性超出用于训练的数据集本身的模型。</li></ul><p><strong>本章节不做求导、偏导的重新描述，仅介绍梯度(grad)和链式法则。微积分具体内容请复习高数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250307111726396.png" alt="image-20250307111726396"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250307111735391.png" alt="image-20250307111735391"></p><p><strong>小结：</strong></p><ul><li>微分和积分是微积分的两个分支，前者可以应用于深度学习中的优化问题。</li><li>导数可以被解释为函数相对于其变量的瞬时变化率，它也是函数曲线的切线的斜率。</li><li>梯度是一个向量，其分量是多变量函数相对于其所有变量的偏导数。</li><li>链式法则可以用来微分复合函数。</li></ul><hr><h1 id="5-自动微分"><a href="#5-自动微分" class="headerlink" title="5.自动微分"></a>5.自动微分</h1><p>求导是几乎所有深度学习优化算法的关键步骤。 虽然求导的计算很简单，只需要一些基本的微积分。 但对于复杂的模型，手工进行更新是一件很痛苦的事情（而且经常容易出错）。</p><p>深度学习框架通过自动计算导数，即<em>自动微分</em>（automatic differentiation）来加快求导。 实际中，根据设计好的模型，系统会构建一个<em>计算图</em>（computational graph）， 来跟踪计算是哪些数据通过哪些操作组合起来产生输出。 <strong>自动微分使系统能够随后反向传播梯度</strong>。 这里，<em>反向传播</em>（backpropagate）意味着跟踪整个计算图，填充关于每个参数的偏导数。</p><hr><h2 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h2><p>假设我们对函数$y &#x3D; 2 x^T x$关于列向量$x$求导。</p><p>首先，我们创建变量$x$并为之分配一个初始值</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchx <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">4.0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor([0., 1., 2., 3.])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我们计算$y$关于$x$的梯度前，<strong>需要一个地方来存储梯度</strong></p><ul><li>我们<strong>不会</strong>在每次对一个参数求导时都分配新的内存<ul><li>因为我们经常会成千上万次地更新相同的参数，每次分配新的内存会很快将内存耗尽</li></ul></li><li><strong>注意：一个标量函数关于向量$x$的梯度是向量，并且与$x$具有相同的形状</strong><ul><li>比如示例函数，$y$显然是一个标量，而$x$是向量</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment"># grad后面的下划线不能省</span><span class="token comment"># 等价于 x = torch.arange(4.0, requires_grad=True)</span>x<span class="token punctuation">.</span>grad<span class="token comment"># 默认值是None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在计算$y$</p><p><code>x</code>是一个长度为4的向量，计算<code>x</code>和<code>x</code>的点积，得到了我们赋值给<code>y</code>的标量输出——也就是<code>28</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> torch<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor(28., grad_fn=&lt;MulBackward0>)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，通过<strong>调用反向传播函数来自动计算<code>y</code>关于<code>x</code>每个分量的梯度</strong>，并打印这些梯度</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>grad<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor([0., 4., 8., 12.])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么我们大概可以判断，函数$y &#x3D; 2 x^T x$关于$x$的梯度应为$4x$。</p><p><strong>验证</strong>上述判断的正确性</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>grad <span class="token operator">==</span> <span class="token number">4</span><span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor([True, True, True, True])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>假如现在要继续计算关于x的另一个函数呢？</strong></p><ul><li>在默认情况下，<strong>Pytorch会累积梯度</strong>，因此需要<strong>清除之前的值</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">.</span>grad<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 清除x梯度的旧值,grad的zero_()函数</span>z <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>z<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>grad<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor([1., 1., 1., 1.])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="2-非标量变量的反向传播"><a href="#2-非标量变量的反向传播" class="headerlink" title="2.非标量变量的反向传播"></a>2.非标量变量的反向传播</h2><p>当<code>y</code>不是标量时，向量<code>y</code>关于向量<code>x</code>的导数的最自然解释是一个矩阵。 对于高阶和高维的<code>y</code>和<code>x</code>，求导的结果可以是一个高阶张量。</p><p>然而，虽然这些更奇特的对象确实出现在高级机器学习中（包括深度学习中）， 但当调用向量的反向计算时，我们通常会试图<strong>计算一批训练样本中每个组成部分的损失函数的导数</strong>。 这里，我们的目的不是计算微分矩阵，而是<strong>单独计算批量中每个样本的偏导数之和</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 对非标量调用backward,需要传入一个gradient(梯度)参数，该参数指定微分函数关于self的梯度</span><span class="token comment"># 实际上可以理解为,gradient是一个和变量y形状相同的张量，gradient=[g0,g1,g2,g3], y=[y0,y1,y2,y3].每个yi的梯度都会被gi加权，然后再反向传播</span><span class="token comment"># 本例只想求偏导数的和，所以传递一个1的梯度是合适的。也就是每个偏导的权重都是1，这才是求和</span>x<span class="token punctuation">.</span>grad<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span>y <span class="token operator">=</span> x <span class="token operator">*</span> xy<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 等价于y.backward(torch.ones(len(x)))</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>grad<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor([0., 2., 4., 6.])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="3-分离计算"><a href="#3-分离计算" class="headerlink" title="3.分离计算"></a>3.分离计算</h2><p>有时，我们希望将某些计算移动到记录的计算图之外</p><p>例如，假设<code>y</code>是作为<code>x</code>的函数计算的，而<code>z</code>则是作为<code>y</code>和<code>x</code>的函数计算的。 想象一下，我们想计算<code>z</code>关于<code>x</code>的梯度，但由于某种原因，希望将<code>y</code>视为一个常数， 并且只考虑到<code>x</code>在<code>y</code>被计算后发挥的作用。</p><p>这里可以分离<code>y</code>来返回一个新变量<code>u</code>，该变量与<code>y</code>具有相同的值， 但丢弃计算图中如何计算<code>y</code>的任何信息。 换句话说，梯度不会向后流经<code>u</code>到<code>x</code>。 因此，下面的反向传播函数计算<code>z=u*x</code>关于<code>x</code>的偏导数，同时将<code>u</code>作为常数处理， 而不是<code>z=x*x*x</code>关于<code>x</code>的偏导数。</p><ul><li><code>detach</code>函数：用于从<strong>计算图</strong>中分离张量，使之不参与梯度计算和反向传播。但u仍然和y共享数据(修改u会影响y)。<ul><li><code>y.clone().detach()</code>既分离计算图又复制数据，修改u不会影响y</li><li>分离出的张量<strong>只能视为常量而不能视为函数</strong>，因为计算图被截断，无法计算<code>du/dx</code></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">4.0</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>grad<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span>y <span class="token operator">=</span> x <span class="token operator">*</span> xu <span class="token operator">=</span> y<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># u=y.detach，那么u不再与相关,u也没有保存梯度。假如这时写一个z = u + 3，那么就会报错，因为z的计算图到u就被截断了，u没法再计算du/dx，那么z就没法反向传播到x</span>z <span class="token operator">=</span> u <span class="token operator">*</span> xz<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>grad <span class="token operator">==</span> u<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor([True, True, True, True])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于记录了<code>y</code>的计算结果，我们可以随后在<code>y</code>上调用反向传播， 得到<code>y=x*x</code>关于的<code>x</code>的导数，即<code>2*x</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">.</span>grad<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span>y<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>grad <span class="token operator">==</span> <span class="token number">2</span><span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor([True, True, True, True])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="4-Python控制流的梯度计算"><a href="#4-Python控制流的梯度计算" class="headerlink" title="4.Python控制流的梯度计算"></a>4.Python控制流的梯度计算</h2><p>使用自动微分的一个好处是： <strong>即使构建函数的计算图需要通过Python控制流（例如，条件、循环或任意函数调用），我们仍然可以计算得到的变量的梯度</strong>。</p><p> 在下面的代码中，<code>while</code>循环的迭代次数和<code>if</code>语句的结果都取决于输入<code>a</code>的值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>    b <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span>    <span class="token keyword">while</span> b<span class="token punctuation">.</span>norm<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">:</span>        b <span class="token operator">=</span> b <span class="token operator">*</span> <span class="token number">2</span>    <span class="token keyword">if</span> b<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        c <span class="token operator">=</span> b    <span class="token keyword">else</span><span class="token punctuation">:</span>        c <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">*</span> b    <span class="token keyword">return</span> c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们来计算梯度吧！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>d <span class="token operator">=</span> f<span class="token punctuation">(</span>a<span class="token punctuation">)</span>d<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们现在可以分析上面定义的<code>f</code>函数。 请注意，它在其输入<code>a</code>中是分段线性的。 换言之，对于任何<code>a</code>，存在某个常量标量<code>k</code>，使得<code>f(a)=k*a</code>，其中<code>k</code>的值取决于输入<code>a</code>，因此可以用<code>d/a</code>验证梯度是否正确。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>grad <span class="token operator">==</span> d<span class="token operator">/</span>a<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor(True)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><ul><li>深度学习框架可以自动计算导数：我们首先将梯度附加到想要对其计算偏导数的变量上，然后记录目标值的计算，执行它的反向传播函数，并访问得到的梯度。</li></ul><hr><h1 id="6-概率论"><a href="#6-概率论" class="headerlink" title="6.概率论"></a>6.概率论</h1><p>简单地说，机器学习就是做出预测。</p><p>根据病人的临床病史，我们可能想预测他们在下一年心脏病发作的<em>概率</em>。 在飞机喷气发动机的异常检测中，我们想要评估一组发动机读数为正常运行情况的概率有多大。 在强化学习中，我们希望智能体（agent）能在一个环境中智能地行动。 这意味着我们需要考虑在每种可行的行为下获得高奖励的概率。 当我们建立推荐系统时，我们也需要考虑概率。 例如，假设我们为一家大型在线书店工作，我们可能希望估计某些用户购买特定图书的概率。 为此，我们需要使用概率学。 有完整的课程、专业、论文、职业、甚至院系，都致力于概率学的工作。 所以很自然地，我们在这部分的目标不是教授整个科目。 相反，我们希望教给读者基础的概率知识，使读者能够开始构建第一个深度学习模型， 以便读者可以开始自己探索它。</p><blockquote><p>具体的、详细的、完整的概率论知识内容，请回顾概率论书本</p><p>本节主要是对概率论在深度学习框架下的使用，以及一些重点知识的回顾</p></blockquote><hr><h2 id="1-基本概率论"><a href="#1-基本概率论" class="headerlink" title="1.基本概率论"></a>1.基本概率论</h2><p>导入必要的软件包：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> torch<span class="token punctuation">.</span>distributions <span class="token keyword">import</span> multinomial<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在统计学中，我们把从概率分布中抽取样本的过程称为<strong>抽样</strong>（sampling）。 笼统来说，可以把<em>分布</em>（distribution）看作对事件的概率分配， 稍后我们将给出的更正式定义。 将概率分配给一些离散选择的分布称为<em>多项分布</em>（multinomial distribution）。</p><p>为了<strong>抽取一个样本</strong>，即掷骰子，我们只需传入一个<strong>概率向量</strong>。 <strong>输出是另一个相同长度的向量：它在索引i处的值是采样结果中i出现的次数。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fair_probs <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">6</span>multinomial<span class="token punctuation">.</span>Multinomial<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> fair_probs<span class="token punctuation">)</span><span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor([0., 0., 1., 0., 0., 0.])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在估计一个骰子的公平性时，我们希望<strong>从同一分布中生成多个样本</strong>。 如果用Python的for循环来完成这个任务，速度会慢得惊人。 因此我们<strong>使用深度学习框架的函数同时抽取多个样本</strong>，得到我们想要的任意形状的独立同分布样本数组。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">multinomial<span class="token punctuation">.</span>Multinomial<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> fair_probs<span class="token punctuation">)</span><span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''res:tensor([3., 1., 1., 3., 2., 0.])结果是随机的，每次执行都会变化，此处仅是一次执行的结果'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们知道如何对骰子进行采样，我们可以模拟1000次投掷。 然后，我们可以统计1000次投掷后，每个数字被投中了多少次。 具体来说，<strong>我们计算相对频率，以作为真实概率的估计。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 将结果存储为32位浮点数以进行除法</span>counts <span class="token operator">=</span> multinomial<span class="token punctuation">.</span>Multinomial<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> fair_probs<span class="token punctuation">)</span><span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token punctuation">)</span>counts <span class="token operator">/</span> <span class="token number">1000</span> <span class="token comment"># 相对频率作为概率的估计</span><span class="token triple-quoted-string string">'''res:tensor([0.1550, 0.1820, 0.1770, 0.1710, 0.1600, 0.1550])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们进行500组实验，每组抽取10个样本</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">counts <span class="token operator">=</span> multinomial<span class="token punctuation">.</span>Multinomial<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> fair_probs<span class="token punctuation">)</span><span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="1-概率论公理"><a href="#1-概率论公理" class="headerlink" title="1.概率论公理"></a>1.概率论公理</h3><p>在处理骰子掷出时，我们将集合$S&#x3D;{1,2,3,4,5,6}$ 称为<em>样本空间</em>（sample space）或<em>结果空间</em>（outcome space）， 其中每个元素都是<em>结果</em>（outcome）。 <em>事件</em>（event）是一组给定样本空间的随机结果。 例如，“看到5”（${5}$）和“看到奇数”（${1,3,5}$）都是掷出骰子的有效事件。 注意，如果一个随机实验的结果在A中，则事件A已经发生。 也就是说，如果投掷出3点，因为$3∈{1,3,5}$，我们可以说，“看到奇数”的事件发生了。</p><p><em>概率</em>（probability）可以被认为是将集合映射到真实值的函数。 在给定的样本空间$S$中，事件$A$的概率， 表示为$P(A)$，满足以下属性：</p><ul><li>对于任意事件A，其概率从不会是负数，即$P(A)≥0$；</li><li>整个样本空间的概率为1，即$P(S)&#x3D;1$；</li><li>对于<em>互斥</em>（mutually exclusive）事件（对于所有$i≠j$都有$A_i∩A_j&#x3D;\emptyset$）的任意一个可数序列$A_1,A_2,…$，序列中任意一个事件发生的概率等于它们各自发生的概率之和，即$P(⋃<em>{i&#x3D;1}^∞A_i)&#x3D;∑</em>{i&#x3D;1}^∞P(A_i)$。</li></ul><p>以上也是概率论的公理，由科尔莫戈罗夫于1933年提出。 有了这个公理系统，我们可以避免任何关于随机性的哲学争论； 相反，我们可以用数学语言严格地推理。 例如，假设事件A1为整个样本空间， 且当所有i&gt;1时的Ai&#x3D;∅， 那么我们可以证明P(∅)&#x3D;0，即不可能发生事件的概率是0。</p><hr><h3 id="2-随机变量"><a href="#2-随机变量" class="headerlink" title="2.随机变量"></a>2.随机变量</h3><p>在我们掷骰子的随机实验中，我们引入了<em>随机变量</em>（random variable）的概念。 随机变量几乎可以是任何数量，并且它可以在随机实验的一组可能性中取一个值。 考虑一个随机变量X，其值在掷骰子的样本空间S&#x3D;{1,2,3,4,5,6}中。 我们可以将事件“看到一个5”表示为{X&#x3D;5}或X&#x3D;5， 其概率表示为P({X&#x3D;5})或P(X&#x3D;5)。 通过P(X&#x3D;a)，我们区分了随机变量X和X可以采取的值（例如a）。 然而，这可能会导致繁琐的表示。 为了简化符号，一方面，我们可以将P(X)表示为随机变量X上的<em>分布</em>（distribution）： 分布告诉我们X获得某一值的概率。 另一方面，我们可以简单用P(a)表示随机变量取值a的概率。 由于概率论中的事件是来自样本空间的一组结果，因此我们可以为随机变量指定值的可取范围。 例如，P(1≤X≤3)表示事件{1≤X≤3}， 即{X&#x3D;1,2,or,3}的概率。 等价地，P(1≤X≤3)表示随机变量X从{1,2,3}中取值的概率。</p><p>请注意，<em>离散</em>（discrete）随机变量（如骰子的每一面） 和<em>连续</em>（continuous）随机变量（如人的体重和身高）之间存在微妙的区别。 现实生活中，测量两个人是否具有完全相同的身高没有太大意义。 如果我们进行足够精确的测量，最终会发现这个星球上没有两个人具有完全相同的身高。 在这种情况下，询问某人的身高是否落入给定的区间，比如是否在1.79米和1.81米之间更有意义。 在这些情况下，我们将这个看到某个数值的可能性量化为<em>密度</em>（density）。 高度恰好为1.80米的概率为0，但密度不是0。 在任何两个不同高度之间的区间，我们都有非零的概率。 <strong>在本节的其余部分中，我们将考虑离散空间中的概率。</strong></p><hr><h2 id="2-处理多个随机变量"><a href="#2-处理多个随机变量" class="headerlink" title="2.处理多个随机变量"></a>2.处理多个随机变量</h2><p>很多时候，我们会考虑多个随机变量。 比如，我们可能需要对疾病和症状之间的关系进行建模。 给定一个疾病和一个症状，比如“流感”和“咳嗽”，以某个概率存在或不存在于某个患者身上。 我们需要估计这些概率以及概率之间的关系，以便我们可以运用我们的推断来实现更好的医疗服务。</p><p>再举一个更复杂的例子：图像包含数百万像素，因此有数百万个随机变量。 在许多情况下，图像会附带一个<em>标签</em>（label），标识图像中的对象。 我们也可以将标签视为一个随机变量。 我们甚至可以将所有元数据视为随机变量，例如位置、时间、光圈、焦距、ISO、对焦距离和相机类型。 所有这些都是联合发生的随机变量。 当我们处理多个随机变量时，会有若干个变量是我们感兴趣的。</p><hr><h3 id="1-联合概率"><a href="#1-联合概率" class="headerlink" title="1.联合概率"></a>1.联合概率</h3><p>$P(A&#x3D;a,B&#x3D;b)$,可简写为$P(A,B)$</p><p>给定任意值a和b，联合概率可以回答：A&#x3D;a和B&#x3D;b同时满足的概率是多少</p><ul><li>请注意，对于任何a和b的取值，$P(A&#x3D;a,B&#x3D;b)≤P(A&#x3D;a)$</li></ul><hr><h3 id="2-条件概率"><a href="#2-条件概率" class="headerlink" title="2.条件概率"></a>2.条件概率</h3><p>$P(B&#x3D;b | A&#x3D;a) &#x3D; \frac{P(A&#x3D;a,B&#x3D;b)}{P(A&#x3D;a)}$,可简写为$P(B|A)$</p><p>它是B&#x3D;b的概率，前提是A&#x3D;a已发生</p><hr><h3 id="3-贝叶斯定理-Bayes"><a href="#3-贝叶斯定理-Bayes" class="headerlink" title="3.贝叶斯定理(Bayes)"></a>3.贝叶斯定理(Bayes)</h3><p>根据<em>乘法法则</em>（multiplication rule ）可得到$P(A,B)&#x3D;P(B∣A)P(A)$</p><p>根据对称性，可得到$P(A,B)&#x3D;P(A∣B)P(B)$</p><p>假设$P(B)&gt;0$，求解其中一个条件变量，我们得到：</p><p>$$P(A|B) &#x3D; \frac{P(B|A)P(A)}{P(B)}$$</p><ul><li>请注意，这里我们使用紧凑的表示法： 其中$P(A,B)$是一个<em>联合分布</em>，$P(A∣B)$是一个<em>条件分布</em></li></ul><hr><h3 id="4-边际化"><a href="#4-边际化" class="headerlink" title="4.边际化"></a>4.边际化</h3><p>为了能进行事件概率求和，我们需要<em>求和法则</em>（sum rule）， 即<strong>B的概率相当于计算A的所有可能选择</strong>，并将所有选择的联合概率聚合在一起：</p><p>$$P(B) &#x3D; \sum_{A}P(A,B)$$</p><p>这也称为<em><strong>边际化</strong></em>（marginalization）。 边际化结果的概率或分布称为<em>边际概率</em>（marginal probability） 或<em>边际分布</em>（marginal distribution）。</p><hr><h3 id="5-独立性"><a href="#5-独立性" class="headerlink" title="5.独立性"></a>5.独立性</h3><p>另一个有用属性是<em>依赖</em>（dependence）与<em>独立</em>（independence）。 如果两个随机变量A和B是独立的，意味着事件A的发生跟B事件的发生无关</p><p>统计学家通常将这一点表述为$A\perp B$</p><p>根据贝叶斯定理，马上就能同样得到$P(A∣B)&#x3D;P(A)$</p><p>由于$P(A∣B)&#x3D;P(A,B),P(B)&#x3D;P(A)$<strong>等价于</strong>$P(A,B)&#x3D;P(A)P(B)$</p><p> 因此两个随机变量是独立的，<strong>当且仅当两个随机变量的联合分布是其各自分布的乘积。</strong></p><p> 同样地，给定另一个随机变量C时，两个随机变量A和B是<em><strong>条件独立的</strong></em>， 当且仅当$P(A,B∣C)&#x3D;P(A∣C)P(B∣C)$</p><ul><li>这个情况表示为$A\perp B∣C$</li></ul><hr><h2 id="3-期望与方差"><a href="#3-期望与方差" class="headerlink" title="3.期望与方差"></a>3.期望与方差</h2><p>一个随机变量$X$的<em><strong>期望</strong></em>（expectation，或平均值（average））表示为：</p><p>$$E[X] &#x3D; \sum_{x} xP(X&#x3D;x)$$</p><p>当函数$f(x)$的输入是从分布P中抽取的随机变量时，$f(x)$的期望值为：</p><p>$$E_{x \sim P}[f(x)] &#x3D; \sum_xf(x)P(x)$$</p><p>在许多情况下，我们希望衡量<strong>随机变量X与其期望值的偏置</strong>。这可以通过<strong>方差</strong>来量化：</p><p>$$Var[X] &#x3D; E[(X - E[X])^2] &#x3D; E[X^2] - E[X]^2$$</p><p>方差的平方根被称为<strong>标准差</strong>。</p><p><strong>随机变量<em>函数</em>的方差</strong>衡量的是：当从该随机变量分布中采样不同值x时， 函数值偏离该函数的期望的程度：</p><p>$$Var[f(x)] &#x3D; E[(f(x)  - E[f(x)])^2]$$</p><hr><h2 id="4-小结-1"><a href="#4-小结-1" class="headerlink" title="4.小结"></a>4.小结</h2><ul><li>我们可以从概率分布中采样。</li><li>我们可以使用联合分布、条件分布、Bayes定理、边缘化和独立性假设来分析多个随机变量。</li><li>期望和方差为概率分布的关键特征的概括提供了实用的度量形式。</li></ul><hr><h1 id="7-查阅API"><a href="#7-查阅API" class="headerlink" title="7.查阅API"></a>7.查阅API</h1><p>由于篇幅限制，我们不可能介绍每一个PyTorch&#x2F;Tensorflow函数和类。 API文档、其他教程和示例提供了本书之外的大量文档。 以下提供了一些查看PyTorch&#x2F;Tensorflow API的指导。</p><h2 id="1-查找模块中所有的函数和类"><a href="#1-查找模块中所有的函数和类" class="headerlink" title="1.查找模块中所有的函数和类"></a>1.查找模块中所有的函数和类</h2><h3 id="1-Pytorch"><a href="#1-Pytorch" class="headerlink" title="1.Pytorch"></a>1.Pytorch</h3><p>为了知道模块中可以调用哪些函数和类，可以调用<code>dir</code>函数。 例如，我们可以查询<strong>随机数生成</strong>模块中的所有属性：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">dir</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>distributions<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>通常可以忽略以“<code>__</code>”（双下划线）开始和结束的函数，它们是Python中的特殊对象， 或以单个“<code>_</code>”（单下划线）开始的函数，它们通常是内部函数。</li><li>根据剩余的函数名或属性名，我们可能会猜测这个模块提供了各种生成随机数的方法， 包括从均匀分布（<code>uniform</code>）、正态分布（<code>normal</code>）和多项分布（<code>multinomial</code>）中采样。</li></ul><h3 id="2-Tensorflow"><a href="#2-Tensorflow" class="headerlink" title="2.Tensorflow"></a>2.Tensorflow</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">dir</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>random<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="2-查找特定函数和类的用法"><a href="#2-查找特定函数和类的用法" class="headerlink" title="2.查找特定函数和类的用法"></a>2.查找特定函数和类的用法</h2><h3 id="1-Pytorch-1"><a href="#1-Pytorch-1" class="headerlink" title="1.Pytorch"></a>1.Pytorch</h3><p>调用<code>help</code>函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">help</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>ones<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-Tensorflow-1"><a href="#2-Tensorflow-1" class="headerlink" title="2.Tensorflow"></a>2.Tensorflow</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">help</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>ones<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-2</title>
      <link href="/2025/02/27/bian-yi-yuan-li-2/"/>
      <url>/2025/02/27/bian-yi-yuan-li-2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="第三章-词法分析"><a href="#第三章-词法分析" class="headerlink" title="第三章 词法分析"></a>第三章 词法分析</h1><blockquote><p>第二章”一个简单的语法制导编译器”上课跳过，回头把这部分的书看一下即可</p></blockquote><p>词法分析是编译的<strong>第一阶段</strong>，负责将<strong>字符流</strong>转换成<strong>记号流</strong></p><ul><li>一套描述记号结构的格式说明(<strong>一套格式结构</strong>)</li><li>以格式说明为依据的识别方法(<strong>对格式结构进行匹配</strong>)</li></ul><p>词法分析的<strong>本质</strong>是：<strong>模式识别&#x2F;匹配</strong></p><h2 id="1-词法分析器功能"><a href="#1-词法分析器功能" class="headerlink" title="1.词法分析器功能"></a>1.词法分析器功能</h2><p>词法分析的<strong>主要任务</strong>：<strong>输入源程序，输出记号(token)</strong></p><ul><li>把构成源程序的字符串转换为<em>记号的序列</em></li><li>记号是编译器的后续处理的<strong>逻辑单元</strong></li></ul><p>词法分析的<strong>次要&#x2F;辅助任务</strong>：</p><ul><li>过滤源程序中的无效字符(注释、空格、制表符、换行符)</li><li>检测、处理词法错误</li><li>出错位置记录</li></ul><hr><h3 id="1使用方式"><a href="#1使用方式" class="headerlink" title="1使用方式"></a>1使用方式</h3><p>使用方式包括：<strong>单独一遍扫描</strong>、<strong>作为语法分析器的子程序</strong>、<strong>并行方式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250228195723878.png" alt="image-20250228195723878"></p><blockquote><p>划分词法分析和语法分析的意义：</p><ul><li><p>简化编译器的设计</p></li><li><p>提高编译器的效率</p></li><li><p>增强编译器的可移植性</p></li><li><p>便于使用工具来自动构造</p></li></ul></blockquote><hr><h3 id="2-记号-token"><a href="#2-记号-token" class="headerlink" title="2.记号(token)"></a>2.记号(token)</h3><p><strong>定义：</strong> 高级语言中有实际意义的<strong>最小语法单位</strong></p><ul><li>编译器的以后部分(通常是分析程序)处理的逻辑单元，也被称为<strong>单词</strong>、<strong>词法单元</strong></li></ul><p><strong>形式：</strong><code>&lt;class, value&gt;</code>二元组</p><ul><li>**class：**记号类型（如关键字、标识符、操作符等）<ul><li>关键字(保留字、基本字)</li><li>if、while</li><li>运算符： +、-、*</li><li>标识符：pi、anything</li><li>分界符：{，}，（，），；</li><li>常数：5，a，3.1416</li></ul></li><li>**value：**属性值（记录与记号有关的信息）<ul><li>实现时通常为<strong>指向符号表中某表项的指针</strong>(一个属性)</li><li>与记号有关的信息保存在该表项中<ul><li><strong>词素</strong></li><li><strong>词素第一次出现的行号</strong><ul><li>对应其<strong>定义</strong>，后续编译过程会用，比如存储空间大小的设置等(根据类型定义决定)</li></ul></li></ul></li></ul></li></ul><p><strong>记号、模式、词素：</strong></p><ul><li><strong>记号（Token)</strong>：词法分析器输出的基本元素，<strong>包含类型和属性值</strong></li><li><strong>词素（Lexeme）</strong>：源代码中<strong>实际的字符序列</strong>，与记号对应。具体而言，指源代码中与特定记号对应的字符序列。例如，对于标识符记号，其词素可能是<code>sum</code>、<code>total</code>等。</li><li><strong>模式（Patten）</strong>：定义<strong>词素形式的规则</strong>。描述某类词素可能形式的规则。对于关键字，模式就是具体的字符序列；对于标识符，模式可能是由字母和数字组成的字符串，以字母开头。</li></ul><blockquote><p>因此，<strong>记号 &#x3D; 记号的类别 + 记号的词素</strong></p></blockquote><hr><h3 id="3-词法错误"><a href="#3-词法错误" class="headerlink" title="3.词法错误"></a>3.词法错误</h3><ul><li><p>词法层能发现的错误很有限</p><ul><li><code>fi ( a = = f(x) ) …</code></li><li><code>fi</code> 是拼写错误？合法的标识符？</li></ul></li><li><p><strong>“紧急方式&#x2F;恐慌模式”错误恢复策略</strong></p><ul><li><strong>反复删除剩余输入最前面的字符</strong></li></ul></li></ul><hr><h3 id="4-词法分析器的实现方案"><a href="#4-词法分析器的实现方案" class="headerlink" title="4.词法分析器的实现方案"></a>4.词法分析器的实现方案</h3><ol><li>编制词法说明，使用工具<strong>自动生成</strong></li><li>使用<strong>高级程序设计</strong>语言编写词法分析器</li><li>使用<strong>汇编语言</strong>编写词法分析器</li></ol><ul><li>实现<strong>难度递增</strong>，<strong>效率递增</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250228203343355.png" alt="image-20250228203343355"></p><hr><h2 id="2-输入缓冲"><a href="#2-输入缓冲" class="headerlink" title="2.输入缓冲"></a>2.输入缓冲</h2><blockquote><p><strong>输入缓冲</strong>是词法分析器用来<strong>逐个读入、分析字符流</strong>的结构</p></blockquote><p>输入缓冲出现的<strong>原因</strong>：词法分析器需要逐个读入分析源程序的字符流</p><ul><li>频繁的磁盘读写操作</li><li>超前扫描需要回退<ul><li>例如：<strong>双字符运算符</strong>，如<code>**, /*, :=, ...</code></li></ul></li><li>耗时，影响编译器工作效率</li><li>设置输入缓冲可缓解这一问题</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250228205650778.png" alt="image-20250228205650778"></p><blockquote><p>整个输入缓冲的结构示意如上所示。问题来了：<strong>缓冲如何更新？</strong></p></blockquote><hr><h3 id="1-双缓冲区方案"><a href="#1-双缓冲区方案" class="headerlink" title="1.双缓冲区方案"></a>1.双缓冲区方案</h3><blockquote><p>又名：<strong>缓冲区对</strong>方案</p></blockquote><ul><li>一个缓冲区分为两个部分，每部分容纳N个字符</li><li>一个读命令向缓冲区某个部分读入N个字符，即<strong>一次性读入N个字符</strong>，而非一个一个读<ul><li>输入不足N时将读入<code>EOF</code></li></ul></li><li>设置两个指针跟踪字符位置<ul><li><code>lexemeBegin</code>指针：词素开始指针</li><li><code>forward</code>指针：前向指针，一直向前扫描，<strong>直到发现某个模式被匹配</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250228210019769.png" alt="image-20250228210019769"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250228210249592.png" alt="image-20250228210249592"></p><ul><li>这里向前指针移动算法的问题是：每次移动<code>forward</code>指针，都要检查是否到了缓冲区末尾。如果是，则需要加载另一个缓冲区。因此，每读入一个字符，我们需要做两次测试：一次检查是否到达缓冲区末尾，一次是确定读入的字符是什么</li><li><strong>缓解办法是：哨兵标记！</strong></li></ul><hr><h3 id="2-哨兵标记"><a href="#2-哨兵标记" class="headerlink" title="2.哨兵标记"></a>2.哨兵标记</h3><blockquote><p>哨兵标记的目的是，将<strong>检查是否到达缓冲区末尾</strong>与<strong>检查当前字符</strong>合二为一</p></blockquote><p>如何做到合二为一？——<strong>在缓冲区末尾加上一个EOF字符！</strong></p><ul><li>这样，就能减少一次测试</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250228211013814.png" alt="image-20250228211013814"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250228211019619.png" alt="image-20250228211019619"></p><hr><h2 id="3-记号描述"><a href="#3-记号描述" class="headerlink" title="3.记号描述"></a>3.记号描述</h2><p>我们回顾一下<strong>词法分析的定义</strong>：<strong>一套描述记号结构的格式说明</strong></p><p>那么，记号结构，或者严谨的说，<strong>词素形式</strong>，或者说<strong>模式</strong>，到底要如何表示？</p><p>了解模式的表示方法，就可以方便的对记号进行描述，<strong>因为模式正是词素形式的表示规则啊</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-1</title>
      <link href="/2025/02/20/bian-yi-yuan-li-1/"/>
      <url>/2025/02/20/bian-yi-yuan-li-1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h2 id="1-编译器概述"><a href="#1-编译器概述" class="headerlink" title="1.编译器概述"></a>1.编译器概述</h2><blockquote><p>笼统来说，编译器是用来完成从<strong>程序设计语言翻译到能被计算机执行的语言</strong>的<strong>软件系统</strong> </p></blockquote><p><strong>定义：</strong></p><ul><li>编译器是可以<strong>读入源语言编写的程序</strong>，并把该程序<strong>翻译</strong>成<strong>等价的、用目标语言编写的程序</strong>，同时<strong>报告在翻译过程中发现的源程序的错误</strong>的<strong>程序</strong><ul><li><strong>源语言</strong>：广义上不定义，狭义上指<strong>高级程序设计语言</strong><ul><li>示例：C&#x2F;C++，Java，C#，html，SQL……</li></ul></li><li><strong>目标语言</strong>：广义上不定义，狭义上指<strong>汇编语言&#x2F;机器语言</strong><ul><li>示例：x86，IA64，ARM，MIPS……</li></ul></li><li><strong>等价</strong>：指<strong>功能上等价</strong></li></ul></li></ul><p><strong>主要功能：</strong></p><ul><li>翻译</li><li>报错</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/35e0e44a7062c0c19f11af008f7201f.jpg" alt="35e0e44a7062c0c19f11af008f7201f"></p><p><strong>计算机语言翻译方式：</strong></p><ul><li><strong>解释程序(interpreter)：每次执行都需要翻译</strong><ul><li>每接受高级语言的<strong>一个语句输入</strong>，<strong>立即</strong>进行解释并控制计算机执行，马上得到执行结果，再执行下一语句</li><li><strong>程序执行效率低</strong></li><li><strong>在线方式online</strong></li><li>示例：Python</li></ul></li><li><strong>编译程序(compiler)：只需一次编译</strong><ul><li>将高级语言程序<strong>整体</strong>转换成低级语言程序(<strong>保存为程序，如exe</strong>)，再执行</li><li><strong>程序执行效率高</strong></li><li><strong>离线方式offline</strong></li><li>示例：C，Java</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250220134703918.png" alt="image-20250220134703918"></p><blockquote><p>使用编译器的运行过程就如上图所示。经过<strong>静态计算</strong>，也就是<strong>不执行语句内容，仅作翻译</strong>，得到目标程序(如x86汇编语言程序&#x2F;bytecode字节码程序(java))，再经由<strong>计算机</strong>(可能是实际计算机，如x86；也可能是JVM虚拟机)<strong>动态计算</strong>得到计算结果</p></blockquote><p><strong>如何从源语言程序翻译到目标语言程序？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/e60410f6c7e31761c094194d07d0d55.jpg" alt="e60410f6c7e31761c094194d07d0d55"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/1ceb9de996716d6db6805a36dd01f8d.jpg" alt="1ceb9de996716d6db6805a36dd01f8d"></p><hr><h2 id="2-编译器结构"><a href="#2-编译器结构" class="headerlink" title="2.编译器结构"></a>2.编译器结构</h2><blockquote><p>编译器实际上的功能在于，把源程序<strong>映射</strong>为<strong>在语义上等价</strong>的目标程序。</p><p>而这个映射过程，也就是<strong>编译过程</strong>，可以分解为<strong>多个步骤</strong>：</p><p><strong>词法分析</strong>——<strong>语法分析</strong>——<strong>语义分析</strong>——<strong>中间代码生成</strong>——<strong>代码优化</strong>——<strong>代码生成</strong></p></blockquote><h3 id="1-结构概述"><a href="#1-结构概述" class="headerlink" title="1.结构概述"></a>1.结构概述</h3><p>完整的编译器结构如下面2张图所示：</p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/6c28325d50dfcb2257765839335ca59.jpg" alt="6c28325d50dfcb2257765839335ca59" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/1e3cc8c6bef1338a0821bbd6f984d93.png" alt="1e3cc8c6bef1338a0821bbd6f984d93" style="zoom:50%;" /><p>总体而言，编译器的结构是<strong>6+2</strong>，即<strong>词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成+符号表、错误检查</strong></p><ul><li>上两图的区别在于，<strong>代码优化</strong>实际上确实是分成两部分的，也就是<strong>机器无关代码优化</strong>与<strong>机器相关代码优化</strong>。</li><li>所以可以认为，在实际操作的时候是做区分，在做概念的时候不做区分</li></ul><hr><h3 id="2-词法分析"><a href="#2-词法分析" class="headerlink" title="2.词法分析"></a>2.词法分析</h3><blockquote><p>编译器的第一个步骤称为<strong>词法分析</strong>，输入是<strong>字符流</strong>，输出是<strong>符号流</strong></p></blockquote><p><strong>作用：</strong></p><ul><li>读入组成源程序的<strong>字符流</strong>，将它们组织成为有意义的<strong>词素</strong>的<strong>序列</strong>，也就是<strong>符号流</strong><ul><li><strong>词素</strong>，指源代码中具有独立意义的字符序列<ul><li>示例：<code>a[index]=4+2</code>，词素分别为：<code>a, [, index, ], =, 4, +, 2</code></li></ul></li></ul></li><li>对于每个词素，词法分析器产生<strong>词法单元token</strong>作为输出<ul><li><strong>词法单元</strong>，又称<strong>记号</strong>，即<strong>token</strong>，高级语言中有意义的最小语法单位</li><li><strong>token</strong>由两部分组成：<code>&lt;class, value&gt;</code><ul><li><strong>class：</strong> <strong>token</strong>的<strong>类型</strong>，用整数表示</li><li><strong>value：</strong> <strong>token</strong>的<strong>指针</strong>，指向保存<strong>token</strong>实际值的存储空间，通常为<strong>符号表条目</strong></li></ul></li><li>示例：<code>a[index]=4+2</code><ul><li><code>a</code>被映射为token1:<code>&lt;id, 1&gt;</code><ul><li><code>id</code>指<code>a</code>的类型是<strong>标识符</strong>(a标识这个变量)，<code>1</code>指向符号表中<code>a</code>对应的条目</li><li><strong>标识符对应的符号表条目存放着该标识符有关信息，比如名字和类型</strong></li><li>其他标识符同理</li></ul></li><li><code>[</code>被映射为token2:<code>&lt;[&gt;</code><ul><li>该词法单元不需要属性值，故忽略value</li><li><strong>为标记上的方便，使用词素本身作为抽象符号的名字</strong></li><li>这类符号<strong>不计入符号表</strong></li><li><code>+</code>、<code>=</code>等符号同理</li></ul></li><li><code>4</code>被映射为token6:<code>&lt;4&gt;</code><ul><li>从技术上讲，词法单元<code>4</code>应该建立一个形如<code>&lt;number, 3&gt;</code>的词法单元，这里因为没有深入学习，所以偷懒省略一下</li></ul></li><li>最终整个语句被映射为如下的<strong>词法单元序列</strong>：<code>&lt;id,1&gt; &lt;[&gt; &lt;id,2&gt; &lt;]&gt; &lt;=&gt; &lt;4&gt; &lt;+&gt; &lt;2&gt;</code></li></ul></li></ul></li></ul><p><strong>注意事项：</strong></p><ul><li><strong>分隔词素的空格会被词法分析器忽略</strong></li><li><strong>换行符、EOF符不会被忽略</strong></li></ul><p><strong>错误处理：</strong></p><ul><li>词法分析器的错误处理很简单，词素是否有<strong>拼写问题</strong>对应着是否有错</li></ul><hr><h3 id="3-语法分析"><a href="#3-语法分析" class="headerlink" title="3.语法分析"></a>3.语法分析</h3><blockquote><p>编译器的第二个步骤称为<strong>语法分析</strong>或<strong>解析</strong>，输入是<strong>符号流</strong>，输出是<strong>语法树</strong></p></blockquote><p><strong>作用：</strong></p><ul><li><p>语法分析器使用词法分析器生成的各个词法单元(token)创建树形的中间表示，<strong>该中间表示给出了词法单元流的语法结构</strong></p><ul><li>**语法特征：**各成分的形式&#x2F;结构</li><li>如果特征不符，则有误</li></ul></li><li><p>一种常见的表示方法是<strong>语法树</strong></p><ul><li>树中的每个<strong>内部节点</strong>表示一个<strong>运算</strong>，每个<strong>子节点</strong>表示<strong>该运算的分量</strong></li><li>语法树的构建是<strong>逻辑上构建</strong>，不要求构建出物理上的语法树</li><li>示例：<code>position = initial + rate * 60</code></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/3e8dc9821899629c9fe7bfbe86ef7f2.jpg" alt="3e8dc9821899629c9fe7bfbe86ef7f2"></p><p><strong>错误处理：</strong></p><ul><li>如果某个语句<strong>不能生成语法树</strong>，那么该语句存在<strong>语法错误</strong></li></ul><hr><h3 id="4-语义分析"><a href="#4-语义分析" class="headerlink" title="4.语义分析"></a>4.语义分析</h3><blockquote><p>编译器的第三个步骤称为<strong>语义分析</strong>，输入是<strong>语法树</strong>，输出是<strong>语法树</strong></p></blockquote><p><strong>作用：</strong></p><ul><li>语义分析器使用<strong>语法树</strong>和<strong>符号表中的信息</strong>来检查源程序是否和语言定义的<strong>语义</strong>一致，同时<strong>收集类型信息</strong><ul><li><strong>语义特征</strong>：各语法成分的<strong>含义与功能</strong>，也就是规定下的<strong>属性</strong>或者<strong>执行时应进行的操作</strong></li><li>语义处理尚无公认方法，暂时使用<strong>语法制导翻译</strong>(机器式的对应)</li></ul></li><li>语义分析的重要部分是<strong>类型检查</strong>和<strong>声明检查</strong><ul><li>类型检查：检查每个运算符是否具有<strong>匹配的运算分量</strong><ul><li>比如，很多语言规定数组下标必须是<strong>整数</strong>，若源程序中以浮点数作为下标，则会报错；</li><li>再比如乘法，两个运算元规定为<strong>浮点数</strong>，若源程序中以整数作为运算分量，则会<strong>进行自动类型转换</strong><ul><li>比如下图中，经过语义分析后，将<code>&lt;60&gt;</code>转换成<code>inttofloat-&lt;60&gt;</code></li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/2c8c6987373b59f810117e7ff124729.jpg" alt="2c8c6987373b59f810117e7ff124729"></p><p><strong>错误处理：</strong></p><ul><li><strong>类型不匹配时</strong>，产生报错</li></ul><hr><h3 id="5-中间代码生成"><a href="#5-中间代码生成" class="headerlink" title="5.中间代码生成"></a>5.中间代码生成</h3><blockquote><p>编译器的第四个步骤称为<strong>中间代码生成</strong>，输入是<strong>语法树</strong>，输出是<strong>中间表示形式(中间代码)</strong></p></blockquote><p><strong>作用：</strong></p><ul><li>为处理方便、便于代码优化</li></ul><p><strong>类型：</strong></p><ul><li><strong>三地址代码(四元表示)</strong>：本课程使用的中间代码类型<ul><li>这种中间表示由一组<strong>类似于汇编语言的指令</strong>组成，<strong>每个指令具有3个运算分量</strong></li><li>每个<strong>三地址赋值指令</strong>的<strong>右部最多只有一个运算符</strong></li><li>编译器应该<strong>生成一个临时名字以存放一个三地址指令计算得到的值</strong></li><li>有些<strong>三地址指令的运算分量可以少于3个</strong></li><li>示例：</li></ul></li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">t1 = inttofloat(60)t2 = id3 * t1t3 = id2 + t2id1 = t3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>后缀表示、前缀表示、三元表示……</li></ul><hr><h3 id="6-代码优化"><a href="#6-代码优化" class="headerlink" title="6.代码优化"></a>6.代码优化</h3><blockquote><p>编译器的第五个步骤称为<strong>代码优化</strong>，输入是<strong>中间代码&#x2F;目标代码</strong>，输出是<strong>中间代码&#x2F;目标代码</strong></p></blockquote><p><strong>作用：</strong></p><ul><li><strong>提高运行速度</strong></li><li><strong>节省存储空间</strong></li></ul><p><strong>目的：</strong></p><ul><li>使<strong>执行指令尽可能少</strong></li><li><strong>使用的存储空间尽可能少</strong></li></ul><p><strong>优化方法分类：</strong></p><ul><li><strong>机器无关优化</strong>：常量合并、强度削减、代码外提<ul><li>机器无关优化是在<strong>中间代码生成</strong>步骤后进行的</li><li>核心思想是，<strong>可由编译器直接计算的，不必保留让计算机每次执行时都算一次</strong><ul><li>示例：<ul><li><code>t1=inttofloat(60)</code>——&gt;<code>t1=60.0</code>，不要每次都转换</li><li><code>t3 = id2 + t2 id1 = t3</code>——&gt;<code>id1 = id2 + t2</code>，省略一个非必须的临时变量</li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/4c1df42d9437526d3e0fe30ace3052e.jpg" alt="4c1df42d9437526d3e0fe30ace3052e"></p><ul><li><strong>机器相关优化</strong>：寄存器分配、存储策略、任务划分<ul><li>机器相关优化是在<strong>目标代码生成</strong>步骤后进行的</li></ul></li></ul><hr><h3 id="7-代码生成"><a href="#7-代码生成" class="headerlink" title="7.代码生成"></a>7.代码生成</h3><blockquote><p>编译器的第六个步骤称为<strong>代码生成</strong>，即<strong>目标代码生成</strong>，输入是<strong>中间代码(中间表示形式)</strong>，输出是<strong>目标机器语言</strong></p></blockquote><p><strong>作用：</strong></p><ul><li>代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言</li></ul><hr><h3 id="8-符号表管理"><a href="#8-符号表管理" class="headerlink" title="8.符号表管理"></a>8.符号表管理</h3><blockquote><p>编译器的辅助模块之一是<strong>符号表管理</strong></p></blockquote><p><strong>作用：</strong></p><ul><li><p>符号表数据结构为每个<strong>变量名字</strong>创建了一个记录条目，记录的字段是名字的<strong>各个属性</strong></p><ul><li>这些属性可以提供一个名字的<strong>存储分配、类型、作用域</strong>等信息</li><li>对于过程名字(函数)，这些信息还包括：<strong>它的参数数量和类型，每个参数的传递方法(比如传值或传引用)以及返回类型</strong></li></ul></li><li><p>该数据结构允许编译器<strong>迅速查找到每个名字的记录，并向记录中快速存放和获取记录中的数据</strong></p></li></ul><p><strong>类型：</strong></p><ul><li>符号表包括：常数表、变量表、关键字表……</li></ul><hr><h3 id="9-错误处理"><a href="#9-错误处理" class="headerlink" title="9.错误处理"></a>9.错误处理</h3><blockquote><p>编译器的另一个辅助模块是<strong>错误检查和处理</strong></p></blockquote><ul><li>程序中出现错误是难免的，编译器6个步骤都能检查出不同类型的问题<ul><li>词法分析：拼写</li><li>语法分析：语句结构、表达式结构</li><li>语义分析：类型不匹配</li></ul></li><li>错误处理程序能够<strong>准确报告源程序中错误的种类、位置</strong></li><li>错误处理程序能够<strong>生成一些附加的注释信息，有助于调试程序</strong></li></ul><hr><h3 id="10-多步骤组成"><a href="#10-多步骤组成" class="headerlink" title="10.多步骤组成"></a>10.多步骤组成</h3><p>编译器的<strong>遍(pass)</strong></p><ul><li>编译器将若干阶段组合起来，对源程序进行一次处理的过程</li><li><strong>单遍编译：适用于小程序</strong><ul><li>编译速度快、效率高</li><li>编译程序复杂、占用存储空间大</li><li><strong>目标程序不优化</strong>——<strong>最大的问题</strong></li></ul></li><li><strong>多遍编译：适用于大程序</strong><ul><li>编译程序较容易、存储空间节省</li><li>目标程序优化</li><li><strong>有重复工作、效率低、耗时长</strong>——<strong>问题所在</strong></li></ul></li></ul><hr><h2 id="3-编译器相关程序"><a href="#3-编译器相关程序" class="headerlink" title="3.编译器相关程序"></a>3.编译器相关程序</h2><blockquote><p>一个完整的语言开发环境除了编译器之外，往往还有很多其他程序辅助开发者工作</p></blockquote><ul><li>编辑器editor</li><li>预处理器preprocessor</li><li>编译器compiler</li><li>汇编器assembler</li><li>连接器linker</li><li>装入器loader</li><li>调试程序debugger</li><li>描述器profiler</li><li>项目管理程序project manager</li></ul><hr><h2 id="4-编译器用语"><a href="#4-编译器用语" class="headerlink" title="4.编译器用语"></a>4.编译器用语</h2><ul><li><p>编译器的<strong>分析-综合模型</strong></p><ul><li><p>分析部分：<strong>分析源程序以计算其特性的编译器操作</strong></p><ul><li>把源程序分解成为多个组成要素，并在这些要素之上加上语法结构</li><li>再使用该结构来创建该源程序的一个<strong>中间表示</strong></li><li>收集有关源程序的信息，并把信息存放在<strong>符号表</strong>数据结构中</li><li>符号表和中间表示形式(中间代码)一起传送给综合部分</li></ul></li><li><p>综合部分：<strong>生成翻译代码时所涉及到的操作</strong></p><ul><li>根据中间表示和符号表中的信息来构造目标程序</li></ul></li><li><p><strong>词法分析、语法分析、语义分析、机器无关代码优化——分析部分</strong></p></li><li><p><strong>中间代码生成、目标代码生成、机器相关代码优化——综合部分</strong></p></li></ul></li><li><p>编译器的<strong>前端-后端划分</strong></p><ul><li>前端：<strong>只依赖于源语言代码，与目标机器独立</strong><ul><li>包括：<strong>词法分析、语法分析、语义分析、中间代码生成、机器无关代码优化、符号表建立、相关错误处理</strong></li></ul></li><li>后端：<strong>只依赖于目标机器</strong><ul><li>包括：<strong>机器相关代码优化、目标代码生成、符号表操作、相关错误处理</strong></li></ul></li></ul></li><li><p>编译器<strong>前后端划分作用</strong></p><ul><li>便于编译器的<strong>移植与改写</strong></li></ul></li></ul><hr><h2 id="5-自举和移植"><a href="#5-自举和移植" class="headerlink" title="5.自举和移植"></a>5.自举和移植</h2><blockquote><p>编译器本身是一个<strong>程序</strong>，它本身也是用某种语言编写(高级语言)，<strong>也需要编译</strong></p><p>那么问题来了：</p><p>A.第一个编译器如何编译得到的？</p><p>B.有了A语言在H机器上的编译器，如何得到B语言在H机器上的编译器？</p><p>C.有了A语言在H机器上的编译器，如何得到A语言在M机器上的编译器？</p><p>D.有了A语言在H机器上的编译器，如何得到B语言在M机器上的编译器？</p></blockquote><p>在回答上述问题前，首先给出<strong>编译器的T型图表示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250220194809380.png" alt="image-20250220194809380"></p><ul><li>该T形表示图表示：任何<strong>以S语言编写的程序都可以用此编译器编译</strong>，包括<strong>用S语言编写的新编译器</strong></li></ul><h3 id="1-Question-A"><a href="#1-Question-A" class="headerlink" title="1.Question A"></a>1.Question A</h3><blockquote><p>Q:第一个编译器如何编译得到的？</p><p>A:<strong>自举</strong></p></blockquote><ul><li>用<strong>汇编或机器语言手工编写</strong>了一个<strong>不完善</strong>的S语言的编译器</li><li>用该编译器来编译用<strong>S语言编写</strong>的S语言编译器，即<strong>自举</strong>，多次重复后得到一个完善的编译器</li></ul><p><strong>自举过程推理：</strong></p><p>$S_{1}$经过$H_{0}$编译成$H_{1}$，$S_{2}$经过$H_{1}$编译成$H_{2}$，以此类推……</p><ul><li>机器语言编写的编译器$H_{i}$，S语言编写的编译器代码$S_{i}$，其中$H_{0}$是手工编写的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/72d9e725b656d4aaa5dd36a0e247c56.jpg" alt="72d9e725b656d4aaa5dd36a0e247c56"></p><hr><p>2.Question B</p><blockquote><p>Q:有了A语言在H机器上的编译器，如何得到B语言在H机器上的编译器？</p></blockquote><p><strong>移植过程推理：</strong></p><ul><li>由题可知，我们有编译器<code>A——H——H(格式：S——I——T)</code></li><li>我们可以<strong>用A语言编写一个源语言为B，目标语言为H的编译器</strong>，即<code>B——A——H</code></li><li>这个<code>BAH</code>编译器经过<code>AHH</code>编译器编译后，得到<code>BHH</code>编译器</li><li>由此，我们得到了<strong>H语言编写的源语言为B，目标语言为H的编译器</strong>，即<code>BHH</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/10294ff1a42ad419a76f92980ed6eac.jpg" alt="10294ff1a42ad419a76f92980ed6eac"></p><hr><h3 id="3-Question-C"><a href="#3-Question-C" class="headerlink" title="3.Question C"></a>3.Question C</h3><blockquote><p>Q:有了A语言在H机器上的编译器，如何得到A语言在M机器上的编译器？</p></blockquote><p><strong>移植过程推理：</strong></p><ul><li>由题可知，我们有编译器<code>A——H——H(格式：S——I——T)</code></li><li>我们<strong>用A语言编写一个源语言为A语言，目标语言为M语言的编译器</strong>，即<code>AAM</code></li><li>我们将<code>AAM</code>编译器通过<code>AHH</code>编译器转换为<strong>H语言编写的源语言为A语言，目标语言为M语言的编译器</strong>，即<code>AHM</code></li><li>我们再将<code>AAM</code>编译器通过<code>AHM</code>编译器转换为<strong>M语言编写的源语言为A语言，目标语言为M语言的编译器</strong>，即<code>AMM</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/0da7a964af09c509de966e72a7e4828.jpg" alt="0da7a964af09c509de966e72a7e4828"></p><hr><h3 id="4-Question-D"><a href="#4-Question-D" class="headerlink" title="4.Question D"></a>4.Question D</h3><blockquote><p>Q:有了A语言在H机器上的编译器，如何得到B语言在M机器上的编译器？</p></blockquote><p><strong>移植过程推理：</strong></p><ul><li><p>由题可知，我们有编译器<code>A——H——H(格式：S——I——T)</code></p></li><li><p>我们<strong>用A语言编写一个源语言为B语言，目标语言为M语言的编译器</strong>，即<code>BAM</code></p></li><li><p>我们将<code>BAM</code>编译器通过<code>AHH</code>编译器转换为<strong>H语言编写的源语言为B语言，目标语言为M语言的编译器</strong>，即<code>BHM</code></p></li><li><p>我们<strong>再用B语言编写一个源语言为B语言，目标语言为M语言的编译器</strong>，即<code>BBM</code></p></li><li><p>我们再将<code>BBM</code>编译器通过<code>BHM</code>编译器转换为<strong>M语言编写的源语言为B语言，目标语言为M语言的编译器</strong>，即<code>BMM</code></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/68de21eb33f999526d44e540c4cacb7.jpg" alt="68de21eb33f999526d44e540c4cacb7"></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程导论笔记-2</title>
      <link href="/2025/01/01/ruan-jian-gong-cheng-dao-lun-bi-ji-2/"/>
      <url>/2025/01/01/ruan-jian-gong-cheng-dao-lun-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="软件工程导论"><a href="#软件工程导论" class="headerlink" title="软件工程导论"></a>软件工程导论</h1><blockquote><p>该部分由胡军老师负责讲解</p></blockquote><h2 id="1-软件设计基础"><a href="#1-软件设计基础" class="headerlink" title="1.软件设计基础"></a>1.软件设计基础</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>何为软件设计？<ul><li>针对软件需求，综合考虑各种制约因素，探究软件实现的解决方案</li></ul></li><li>设计前提：<strong>软件需求</strong><ul><li>软件设计就是要给出软件需求实现的解决方案</li></ul></li><li>设计考虑：<strong>制约因素</strong><ul><li>资源：时间、人力、财力</li><li>技术：技术平台，如DBMS还是文件系统</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194131506.png" alt="image-20250102194131506"></p><h3 id="2-软件设计层次"><a href="#2-软件设计层次" class="headerlink" title="2.软件设计层次"></a>2.软件设计层次</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194216034.png" alt="image-20250102194216034"></p><h3 id="3-软件设计的质量需求"><a href="#3-软件设计的质量需求" class="headerlink" title="3.软件设计的质量需求"></a>3.软件设计的质量需求</h3><ul><li><strong>设计的多样性何差异性：质量</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194312298.png" alt="image-20250102194312298"></p><h3 id="4-软件设计过程"><a href="#4-软件设计过程" class="headerlink" title="4.软件设计过程"></a>4.软件设计过程</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194330033.png" alt="image-20250102194330033"></p><h4 id="1-软件体系结构设计"><a href="#1-软件体系结构设计" class="headerlink" title="1.软件体系结构设计"></a>1.软件体系结构设计</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194347217.png" alt="image-20250102194347217"></p><ul><li>风格包括：<ul><li>分层体系结构风格</li></ul></li></ul><h4 id="2-用户界面设计"><a href="#2-用户界面设计" class="headerlink" title="2.用户界面设计"></a>2.用户界面设计</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194431972.png" alt="image-20250102194431972"></p><h4 id="3-软件详细设计"><a href="#3-软件详细设计" class="headerlink" title="3.软件详细设计"></a>3.软件详细设计</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194445793.png" alt="image-20250102194445793"></p><h4 id="4-其他工作"><a href="#4-其他工作" class="headerlink" title="4.其他工作"></a>4.其他工作</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194527214.png" alt="image-20250102194527214"></p><h3 id="5-常用设计概念"><a href="#5-常用设计概念" class="headerlink" title="5.常用设计概念"></a>5.常用设计概念</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194544408.png" alt="image-20250102194544408"></p><h4 id="1-分解与抽象"><a href="#1-分解与抽象" class="headerlink" title="1.分解与抽象"></a>1.分解与抽象</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194714259.png" alt="image-20250102194714259"></p><h4 id="2-关注点分离"><a href="#2-关注点分离" class="headerlink" title="2.关注点分离"></a>2.关注点分离</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194728607.png" alt="image-20250102194728607"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194742562.png" alt="image-20250102194742562"></p><h4 id="3-模块化"><a href="#3-模块化" class="headerlink" title="3.模块化"></a>3.模块化</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194757203.png" alt="image-20250102194757203"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201912588.png" alt="image-20250102201912588"></p><p><strong>衡量模块独立性的是：内聚度何耦合度</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194827975.png" alt="image-20250102194827975"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194834948.png" alt="image-20250102194834948"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194841887.png" alt="image-20250102194841887"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194846035.png" alt="image-20250102194846035"></p><h4 id="4-信息隐藏"><a href="#4-信息隐藏" class="headerlink" title="4.信息隐藏"></a>4.信息隐藏</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194906381.png" alt="image-20250102194906381"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194912796.png" alt="image-20250102194912796"></p><h4 id="5-重构"><a href="#5-重构" class="headerlink" title="5.重构"></a>5.重构</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194925634.png" alt="image-20250102194925634"></p><h4 id="6-复用"><a href="#6-复用" class="headerlink" title="6.复用"></a>6.复用</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194935647.png" alt="image-20250102194935647"></p><h3 id="6-面向对象软件设计方法学"><a href="#6-面向对象软件设计方法学" class="headerlink" title="6.面向对象软件设计方法学"></a>6.面向对象软件设计方法学</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102194957940.png" alt="image-20250102194957940"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195009342.png" alt="image-20250102195009342"></p><ul><li><strong>面向对象软件设计的优势</strong><ul><li>高层抽象与自然过渡</li><li>多种形式和粗粒度的软件重用</li><li>系统化的软件设计</li><li>支持软件扩展、变更</li></ul></li></ul><h3 id="7-软件设计输出及评审"><a href="#7-软件设计输出及评审" class="headerlink" title="7.软件设计输出及评审"></a>7.软件设计输出及评审</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195139625.png" alt="image-20250102195139625"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195158662.png" alt="image-20250102195158662"></p><h3 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195212849.png" alt="image-20250102195212849"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195234041.png" alt="image-20250102195234041"></p><blockquote><p>C</p></blockquote><h2 id="2-软件体系结构设计"><a href="#2-软件体系结构设计" class="headerlink" title="2.软件体系结构设计"></a>2.软件体系结构设计</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195409305.png" alt="image-20250102195409305"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195416604.png" alt="1"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195427207.png" alt="image-20250102195427207"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195440512.png" alt="image-20250102195440512"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195445344.png" alt="image-20250102195445344"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195453096.png" alt="image-20250102195453096"></p><h3 id="2-软件体系结构的设计元素"><a href="#2-软件体系结构的设计元素" class="headerlink" title="2.软件体系结构的设计元素"></a>2.软件体系结构的设计元素</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195518302.png" alt="image-20250102195518302"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195525118.png" alt="image-20250102195525118"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195536408.png" alt="image-20250102195536408"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195546304.png" alt="image-20250102195546304"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195553942.png" alt="image-20250102195553942"></p><h3 id="3-体系结构视图"><a href="#3-体系结构视图" class="headerlink" title="3.体系结构视图"></a>3.体系结构视图</h3><h4 id="1-包图"><a href="#1-包图" class="headerlink" title="1.包图"></a>1.包图</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195642773.png" alt="image-20250102195642773"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195629920.png" alt="image-20250102195629920"></p><h4 id="2-构件图"><a href="#2-构件图" class="headerlink" title="2.构件图"></a>2.构件图</h4><p><img src="C:\Users\Roeland\AppData\Roaming\Typora\typora-user-images\image-20250102195724177.png" alt="image-20250102195724177"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195735093.png" alt="image-20250102195735093"></p><h4 id="3-部署视图"><a href="#3-部署视图" class="headerlink" title="3.部署视图"></a>3.部署视图</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195749093.png" alt="image-20250102195749093"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195755755.png" alt="image-20250102195755755"></p><h4 id="4-运行视图"><a href="#4-运行视图" class="headerlink" title="4.运行视图"></a>4.运行视图</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195812386.png" alt="image-20250102195812386"></p><h3 id="4-软件体系结构风格"><a href="#4-软件体系结构风格" class="headerlink" title="4.软件体系结构风格"></a>4.软件体系结构风格</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195855862.png" alt="image-20250102195855862"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195905907.png" alt="image-20250102195905907"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195912325.png" alt="image-20250102195912325"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195920839.png" alt="image-20250102195920839"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195926604.png" alt="image-20250102195926604"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195930849.png" alt="image-20250102195930849"></p><h3 id="5-体系结构设计任务"><a href="#5-体系结构设计任务" class="headerlink" title="5.体系结构设计任务"></a>5.体系结构设计任务</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102195950231.png" alt="image-20250102195950231"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200003769.png" alt="image-20250102200003769"></p><h4 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200032366.png" alt="image-20250102200032366"></p><h4 id="2-对比"><a href="#2-对比" class="headerlink" title="2.对比"></a>2.对比</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200041722.png" alt="image-20250102200041722"></p><h4 id="3-重要性"><a href="#3-重要性" class="headerlink" title="3.重要性"></a>3.重要性</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200054085.png" alt="image-20250102200054085"></p><h4 id="4-过程"><a href="#4-过程" class="headerlink" title="4.过程"></a>4.过程</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200107295.png" alt="image-20250102200107295"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200219189.png" alt="image-20250102200219189"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200224838.png" alt="image-20250102200224838"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200231037.png" alt="image-20250102200231037"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200236329.png" alt="image-20250102200236329"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200241319.png" alt="image-20250102200241319"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200247109.png" alt="image-20250102200247109"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200251431.png" alt="image-20250102200251431"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200255651.png" alt="image-20250102200255651"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200301068.png" alt="image-20250102200301068"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200313072.png" alt="image-20250102200313072"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200318754.png" alt="image-20250102200318754"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200322670.png" alt="image-20250102200322670"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200329260.png" alt="image-20250102200329260"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200341048.png" alt="image-20250102200341048"></p><h2 id="3-软件详细设计-1"><a href="#3-软件详细设计-1" class="headerlink" title="3.软件详细设计"></a>3.软件详细设计</h2><h3 id="1-面向对象的设计原则"><a href="#1-面向对象的设计原则" class="headerlink" title="1.面向对象的设计原则"></a>1.面向对象的设计原则</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200500153.png" alt="image-20250102200500153"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200507945.png" alt="image-20250102200507945"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200512546.png" alt="image-20250102200512546"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200517525.png" alt="image-20250102200517525"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200523191.png" alt="image-20250102200523191"></p><h4 id="1-基本设计原则"><a href="#1-基本设计原则" class="headerlink" title="1.基本设计原则"></a>1.基本设计原则</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200541474.png" alt="image-20250102200541474"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200613465.png" alt="image-20250102200613465"></p><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a>2.例题</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200650786.png" alt="image-20250102200650786"></p><blockquote><p>D</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200659963.png" alt="image-20250102200659963"></p><blockquote><p>AC</p></blockquote><h3 id="3-软件设计模式"><a href="#3-软件设计模式" class="headerlink" title="3.软件设计模式"></a>3.软件设计模式</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200730170.png" alt="image-20250102200730170"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200743797.png" alt="image-20250102200743797"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200750681.png" alt="image-20250102200750681"></p><h2 id="4-用户界面设计"><a href="#4-用户界面设计" class="headerlink" title="4.用户界面设计"></a>4.用户界面设计</h2><h3 id="1-用户界面不同形式"><a href="#1-用户界面不同形式" class="headerlink" title="1.用户界面不同形式"></a>1.用户界面不同形式</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200855569.png" alt="image-20250102200855569"></p><h3 id="2-用户界面布局管理"><a href="#2-用户界面布局管理" class="headerlink" title="2.用户界面布局管理"></a>2.用户界面布局管理</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200912288.png" alt="image-20250102200912288"></p><h4 id="1-网页布局"><a href="#1-网页布局" class="headerlink" title="1.网页布局"></a>1.网页布局</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200932328.png" alt="image-20250102200932328"></p><h4 id="2-APP布局"><a href="#2-APP布局" class="headerlink" title="2.APP布局"></a>2.APP布局</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102200959784.png" alt="image-20250102200959784"></p><h4 id="3-桌面应用布局"><a href="#3-桌面应用布局" class="headerlink" title="3.桌面应用布局"></a>3.桌面应用布局</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201015562.png" alt="image-20250102201015562"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201034755.png" alt="image-20250102201034755"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201041852.png" alt="image-20250102201041852"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201046911.png" alt="image-20250102201046911"></p><h3 id="3-用户界面设计原则"><a href="#3-用户界面设计原则" class="headerlink" title="3.用户界面设计原则"></a>3.用户界面设计原则</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201104158.png" alt="image-20250102201104158"></p><p>除了上述4个，还有：</p><ul><li>保持始终如一<ul><li>相同软件在不同设备的一致性</li><li>页面风格</li><li>行为一致</li><li>错误提示</li></ul></li><li>保持有用反馈</li></ul><h3 id="4-用户界面设计方法"><a href="#4-用户界面设计方法" class="headerlink" title="4.用户界面设计方法"></a>4.用户界面设计方法</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201221102.png" alt="image-20250102201221102"></p><h3 id="5-用户界面审查"><a href="#5-用户界面审查" class="headerlink" title="5.用户界面审查"></a>5.用户界面审查</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201240825.png" alt="image-20250102201240825"></p><ul><li>两阶段用户界面走查</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201246643.png" alt="image-20250102201246643"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201251623.png" alt="image-20250102201251623"></p><ul><li>用户功能走查</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201325585.png" alt="image-20250102201325585"></p><ul><li>界面元素走查</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102201422248.png" alt="image-20250102201422248"></p><h2 id="5-用户体验与可用性"><a href="#5-用户体验与可用性" class="headerlink" title="5.用户体验与可用性"></a>5.用户体验与可用性</h2><h3 id="1-用户体验"><a href="#1-用户体验" class="headerlink" title="1.用户体验"></a>1.用户体验</h3><p><strong>什么是用户体验</strong></p><ul><li><p>“用户体验”涵盖了终端用户与公司、其服务及其产品互动的所有方面。</p><ul><li>出色用户体验的首要要求是<strong>准确满足客户的需求</strong>，无需麻烦或困扰。</li><li>其次是<strong>简洁和优雅</strong>，让产品成为一种<strong>拥有的乐趣，使用的乐趣</strong>。</li><li>真正的用户体验<strong>远远超出</strong>仅仅提供客户所说的需求或清单式功能。</li></ul></li><li><p>为了在公司产品中实现高质量的用户体验，必须将多学科的服务<strong>无缝融合</strong>：</p><ul><li><p><strong>工程学</strong></p></li><li><p><strong>市场营销</strong></p></li><li><p><strong>图形与工业设计</strong></p></li><li><p><strong>界面设计</strong></p></li></ul></li></ul><p><strong>设计的三个层次</strong></p><ul><li>本能层次设计<ul><li>Visceral design</li></ul></li><li>行为层次设计<ul><li>Behavioral design</li></ul></li><li>反思层次设计<ul><li>Reflective design</li></ul></li></ul><h3 id="2-可用性"><a href="#2-可用性" class="headerlink" title="2.可用性"></a>2.可用性</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>可用性</strong>是一种开发方法，融入了用户反馈，贯穿整个开发周期，以减少成本，并创建符合用户需求的产品和工具</p><p>“可用性实际上是确保某个东西能<strong>良好运行</strong>：即使是普通或低于普通能力和经验的人，也可以毫无挫败感地将该事物用于其预定的用途。”</p><h4 id="2-属性与目标"><a href="#2-属性与目标" class="headerlink" title="2.属性与目标"></a>2.属性与目标</h4><ul><li>有效性</li><li>效率性</li><li>可学习性</li><li>满意度</li></ul><h4 id="3-重要性-1"><a href="#3-重要性-1" class="headerlink" title="3.重要性"></a>3.重要性</h4><p><strong>为什么可用性重要？（Why Does Usability Matter?）</strong></p><ol><li><strong>可用性有时关系到生死存亡。</strong><ul><li>说明在一些关键场景中（例如医疗设备、飞行仪表等），设计的可用性直接影响到用户的生命安全。一个不直观或容易出错的设计可能导致严重后果。</li></ul></li><li><strong>可用性在我们的生活中发挥了比大多数人意识到的更广泛的作用。</strong><ul><li>许多人可能没有意识到，可用性设计对我们日常生活的便利性、效率和安全性有着深远影响。从手机界面到自动售票机，可用性贯穿我们生活的方方面面。</li></ul></li><li><strong>可用性每天都影响着每一个人。</strong><ul><li>无论是专业工具还是日常用品，每个人在使用产品时都会受到可用性的影响。一个好的可用性设计可以提高我们的工作效率，减少困惑和挫折感。</li></ul></li></ol><p><strong>用户体验 vs 可用性</strong></p><ul><li><strong>可用性</strong>通常被认为是用户使用某一产品成功完成任务的能力。</li><li><strong>用户体验</strong>则具有更广泛的视角，关注用户与产品的整个交互过程，以及从这种交互中产生的思想、感受和感知。</li></ul><h3 id="3-用户画像"><a href="#3-用户画像" class="headerlink" title="3.用户画像"></a>3.用户画像</h3><p><strong>什么是用户画像</strong></p><ul><li>用户画像是为了代表目标用户群中的不同用户类型而创造的虚拟角色。</li><li>用户画像在考虑用户的目标、需求和限制时非常有用，从而帮助产品决策。</li><li>用户画像最常用作用户中心设计的一部分。</li></ul><p><strong>用户画像的目的</strong></p><ul><li>帮助设计团队理解目标受众。</li><li>为讨论用户需求建立共同的语言。</li><li>帮助设计团队做出与设计相关的决策。</li></ul><p><strong>用户画像和目标</strong></p><ul><li>用户的三种目标与Norman提出的本能、行为和反思三个层次相对应：<ul><li><strong>生活目标</strong>：用户希望成为怎样的人。</li><li><strong>体验目标</strong>：用户希望感受到什么。</li><li><strong>终极目标</strong>：用户希望完成什么。</li></ul></li></ul><h3 id="4-UCD"><a href="#4-UCD" class="headerlink" title="4.UCD"></a>4.UCD</h3><p><strong>以用户为中心的设计（UCD）</strong></p><ul><li>以用户为中心的设计是一种以产品的最终用户为核心的开发方法。</li><li>其理念是：<strong>产品应该适应用户，而不是让用户去适应产品</strong>。</li><li>通过在产品生命周期中采用技术、流程和方法来实现这一点。</li></ul><p><strong>以用户为中心设计的活动（UCD Activities）</strong></p><ul><li>理解用户的愿望、需求、动机和使用场景。</li><li>理解商业、技术和领域内的机会、需求和限制。</li><li>将这些知识作为基础，用于制定计划，设计出形式、内容和行为都<strong>有用、可用且令人满意</strong>的产品，同时确保经济可行和技术可行。</li></ul><p><strong>以用户为中心设计的生命周期（UCD Lifecycle）</strong></p><p><strong>1. Concept（概念阶段）</strong></p><ul><li><strong>目标：</strong> 确定用户的需求和产品开发的总体方向。</li></ul><p><strong>2. Design（设计阶段）</strong></p><ul><li><strong>目标：</strong> 将用户需求转化为实际的产品设计。</li></ul><p><strong>3. Develop（开发阶段）</strong></p><ul><li><strong>目标：</strong> 将设计转化为实际的产品，同时确保可用性和质量。</li></ul><p><strong>4. Release（发布阶段）</strong></p><ul><li><strong>目标：</strong> 将产品发布给用户，并进行最终验证。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250102203941294.png" alt="image-20250102203941294"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程导论笔记-1</title>
      <link href="/2024/12/31/ruan-jian-gong-cheng-dao-lun-bi-ji-1/"/>
      <url>/2024/12/31/ruan-jian-gong-cheng-dao-lun-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="软件工程导论"><a href="#软件工程导论" class="headerlink" title="软件工程导论"></a>软件工程导论</h1><blockquote><p>该部分由金敏老师讲解</p></blockquote><h2 id="1-软件工程概述"><a href="#1-软件工程概述" class="headerlink" title="1.软件工程概述"></a>1.软件工程概述</h2><h3 id="1-软件的本质"><a href="#1-软件的本质" class="headerlink" title="1.软件的本质"></a>1.软件的本质</h3><p>特点：</p><ul><li>不可见无磨损</li><li>一致性</li><li>持续变更</li><li>日趋复杂</li></ul><hr><h3 id="2-软件工程的概念与发展历程"><a href="#2-软件工程的概念与发展历程" class="headerlink" title="2.软件工程的概念与发展历程"></a>2.软件工程的概念与发展历程</h3><h4 id="1-历程"><a href="#1-历程" class="headerlink" title="1.历程"></a>1.历程</h4><ul><li>第一阶段：<strong>程序设计</strong>阶段<ul><li>时间：计算机诞生后(1946)</li><li>特点：<ul><li>软件工作：代码编写</li><li>软件评估：<strong>程序&#x3D;数据结构+算法</strong>、<strong>编程技巧</strong></li></ul></li></ul></li><li>第二阶段：<strong>软件工程</strong>阶段<ul><li>时间：大容量、高速度计算机出现，NL、OS、DB出现</li><li>特点：<strong>上述情况导致了软件危机，催生了软件工程</strong><ul><li>软件工作：<ul><li>代码编写+需求分析、测试、维护——软件工程</li><li>系统化、规范、可度量的工程化方法应用于软件</li></ul></li><li>软件评估：<ul><li><strong>可读性、可理解性、可测试性和易修改性</strong></li></ul></li></ul></li></ul></li></ul><h4 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a>2.例题</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231191352253.png" alt="image-20241231191352253"></p><blockquote><p>D</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231191358134.png" alt="image-20241231191358134"></p><blockquote><p>ABCD</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231191423069.png" alt="image-20241231191423069"></p><blockquote><p>C</p></blockquote><hr><h3 id="3-软件过程概念与软件过程模型"><a href="#3-软件过程概念与软件过程模型" class="headerlink" title="3.软件过程概念与软件过程模型"></a>3.软件过程概念与软件过程模型</h3><h4 id="1-历程-1"><a href="#1-历程-1" class="headerlink" title="1.历程"></a>1.历程</h4><ul><li>第三阶段：<strong>软件过程</strong>阶段<ul><li>时间：互联网、物联网广泛应用后</li><li>特点：<strong>快速变化的需求、技术、市场</strong><ul><li>软件工作：<ul><li>流程活动(时序逻辑关系)</li><li>流程活动各要素(如人员、方法、产品等)</li></ul></li><li>软件评估：<ul><li>多目标函数(软件质量、开发效率、开发成本)</li></ul></li></ul></li></ul></li></ul><hr><h4 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h4><p><strong>软件过程是从软件项目需求定义开始直至软件经使用后废弃为止的跨越软件整个生存期内的系统开发、运行和维护等全部活动及其相关项的总和</strong></p><hr><h4 id="3-软件过程框架"><a href="#3-软件过程框架" class="headerlink" title="3.软件过程框架"></a>3.软件过程框架</h4><p>软件过程框架，分为<strong>四项基本活动</strong></p><ul><li>软件需求分析&#x2F;软件规格说明</li><li>软件开发</li><li>软件确认</li><li>软件演化</li></ul><hr><h4 id="4-软件过程模型"><a href="#4-软件过程模型" class="headerlink" title="4.软件过程模型"></a>4.软件过程模型</h4><h5 id="1-瀑布模型"><a href="#1-瀑布模型" class="headerlink" title="1.瀑布模型"></a>1.瀑布模型</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231192143312.png" alt="image-20241231192143312"></p><h5 id="2-原型模型"><a href="#2-原型模型" class="headerlink" title="2.原型模型"></a>2.原型模型</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231192157819.png" alt="image-20241231192157819"></p><h5 id="3-螺旋模型"><a href="#3-螺旋模型" class="headerlink" title="3.螺旋模型"></a>3.螺旋模型</h5><blockquote><p>螺旋模型是绕不开的重点</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231192208790.png" alt="image-20241231192208790"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231192238104.png" alt="image-20241231192238104"></p><h5 id="4-增量模型"><a href="#4-增量模型" class="headerlink" title="4.增量模型"></a>4.增量模型</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231192248254.png" alt="image-20241231192248254"></p><hr><h4 id="5-软件能力评估标准"><a href="#5-软件能力评估标准" class="headerlink" title="5.软件能力评估标准"></a>5.软件能力评估标准</h4><ul><li>CMM</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231192428898.png" alt="image-20241231192428898"></p><ul><li>CMMI</li></ul><hr><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><ul><li>软件过程模型<ul><li>瀑布模型：需求较明确、且较稳定</li><li>原型模型：需求不明确</li><li>螺旋模型：需求不明确、不稳定</li><li>增量模型：需求不稳定、强调快速交付</li></ul></li><li>软件发展历程<ul><li>第一阶段：计算机诞生后——<strong>程序设计</strong>——个体软件</li><li>第二阶段：高速计算机&#x2F;OS——<strong>软件工程</strong>——大规模软件</li><li>第三阶段：互联网&#x2F;物联网——<strong>软件过程</strong>——变化的复杂软件</li></ul></li></ul><hr><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231192805776.png" alt="image-20241231192805776"></p><blockquote><p>C</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231192815436.png" alt="image-20241231192815436"></p><blockquote><p>AD</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231192829544.png" alt="image-20241231192829544"></p><blockquote><p>B</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231192840147.png" alt="image-20241231192840147"></p><blockquote><p>BCD</p></blockquote><hr><h2 id="2-需求工程概述"><a href="#2-需求工程概述" class="headerlink" title="2.需求工程概述"></a>2.需求工程概述</h2><h3 id="1-需求的定义"><a href="#1-需求的定义" class="headerlink" title="1.需求的定义"></a>1.需求的定义</h3><p><strong>定义</strong>：</p><p>需求就是以一种<strong>清晰、简洁、一致、无二义性</strong>的方式，对一个待开发软件系统中各个有意义功能和性能等方面的陈述的集合</p><p><strong>需求的基本性质</strong></p><ul><li>必要性</li><li>无歧义性</li><li>可测试性</li><li>可跟踪性</li><li>可测量性</li></ul><hr><h3 id="2-需求的意义"><a href="#2-需求的意义" class="headerlink" title="2.需求的意义"></a>2.需求的意义</h3><ul><li><p>需求体现软件价值、决定软件命运</p><ul><li><p>需求本质反映的是如何为客户和用户等利益相关者拟定新的目标组织前景</p></li><li><p>错误与缺乏创新的需求将导致软件的失败</p></li></ul></li><li><p>需求是软件项目和产品的<strong>根源</strong>，是后续设计、实现、测试、维护等所有活动的依据</p></li></ul><hr><h3 id="3-需求的层次"><a href="#3-需求的层次" class="headerlink" title="3.需求的层次"></a>3.需求的层次</h3><ul><li>业务需求<ul><li>对应<strong>前景与范围文档</strong></li></ul></li><li>用户需求<ul><li>对应<strong>用户需求文档(用例文档)</strong></li></ul></li><li>系统需求<ul><li>对应<strong>软件需求规格说明文档(系统需求规格SRS)</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231202518140.png" alt="image-20241231202518140"></p><blockquote><p>C</p></blockquote><hr><h3 id="4-需求的类型"><a href="#4-需求的类型" class="headerlink" title="4.需求的类型"></a>4.需求的类型</h3><ul><li><strong>功能性需求</strong><ul><li>解释：是对系统应该提供的服务、系统应该如何响应特定的输入、系统在特定的情形中应该如何表现等的陈述</li><li>在某些情况下，功能性需求还可以明确的陈述系统**”不应该做什么”**</li></ul></li><li><strong>非功能性需求</strong><ul><li><strong>业务规则</strong><ul><li>公司政策、政府法规、工业标准、计算算法……</li></ul></li><li><strong>质量属性</strong><ul><li>外部质量<ul><li>可靠性<ul><li>成熟性、容错性、可恢复性</li></ul></li><li>易用性<ul><li>易理解性、易学性、易操作性、吸引性</li></ul></li><li>效率&#x2F;性能<ul><li>时间特性、资源利用、安全性</li></ul></li></ul></li><li>内部质量<ul><li>可维护性<ul><li>易分析性、易改变行、稳定性、易测试性</li></ul></li><li>可移植性<ul><li>适应性、易安装行、共存性、替换行</li></ul></li></ul></li></ul></li><li><strong>外部接口</strong><ul><li>系统接口：描述一个应用如何与系统的其他应用交互</li><li>用户接口：规约了软件产品与用户之间接口的逻辑特性</li><li>硬件接口：系统所要求的支持和协议类型</li><li>软件接口：允许与其他软件产品交互</li><li>内存约束：易失性存储和永久性存储的特性和限制</li><li>操作：规约用户如何使系统进入正常和异常的运行，以及在系统正常和异常运行下如何与系统进行交互</li><li>地点需求：描述系统安装以及如何调整一个地点，以适应新的系统</li></ul></li><li><strong>设计约束</strong><ul><li>限制系统或系统构件的设计方案</li><li>设计约束本身，对其进行权衡调整很困难，甚至不可能</li><li>示例：<ul><li>系统必须用C++或其他面向对象语言编写</li><li>特定应用消耗算力平均不超过50%</li></ul></li></ul></li></ul></li></ul><hr><h3 id="5-层次与类型的关系"><a href="#5-层次与类型的关系" class="headerlink" title="5.层次与类型的关系"></a>5.层次与类型的关系</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231203620209.png" alt="image-20241231203620209"></p><hr><h3 id="6-需求工程过程"><a href="#6-需求工程过程" class="headerlink" title="6.需求工程过程"></a>6.需求工程过程</h3><h4 id="1-需求工程"><a href="#1-需求工程" class="headerlink" title="1.需求工程"></a>1.需求工程</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231203757509.png" alt="image-20241231203757509"></p><hr><h4 id="2-需求工程过程"><a href="#2-需求工程过程" class="headerlink" title="2.需求工程过程"></a>2.需求工程过程</h4><p>使用<strong>螺旋迭代过程</strong></p><ul><li>需求获取+需求分析</li><li>需求规格说明</li><li>需求确认</li><li>系统需求文档</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231203917603.png" alt="image-20241231203917603"></p><h4 id="3-需求工程方法"><a href="#3-需求工程方法" class="headerlink" title="3.需求工程方法"></a>3.需求工程方法</h4><p><strong>方法使用原则：</strong></p><ul><li>从低到高、先易后难</li><li>方法有效性判定</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231203938831.png" alt="image-20241231203938831"></p><hr><h3 id="7-例题"><a href="#7-例题" class="headerlink" title="7.例题"></a>7.例题</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231204103855.png" alt="image-20241231204103855"></p><blockquote><p>D</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231204115445.png" alt="image-20241231204115445"></p><blockquote><p>B</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231204125059.png" alt="image-20241231204125059"></p><blockquote><p>A</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231204135294.png" alt="image-20241231204135294"></p><blockquote><p>B</p></blockquote><h2 id="3-需求获取与分析"><a href="#3-需求获取与分析" class="headerlink" title="3.需求获取与分析"></a>3.需求获取与分析</h2><blockquote><p>需求螺旋迭代过程的第一部分</p></blockquote><h3 id="1-基本路径与方法"><a href="#1-基本路径与方法" class="headerlink" title="1.基本路径与方法"></a>1.基本路径与方法</h3><ul><li><strong>用户调研</strong><ul><li>基本方法包括</li><li>用户访谈</li><li>调查问卷</li><li>用户反馈</li></ul></li></ul><hr><h3 id="2-面临的挑战"><a href="#2-面临的挑战" class="headerlink" title="2.面临的挑战"></a>2.面临的挑战</h3><ul><li>需求的<strong>模糊性和隐蔽性</strong></li><li>需求的<strong>多样性</strong></li><li>需求的<strong>领域专业性</strong></li><li>需求的<strong>易变性</strong></li></ul><hr><h3 id="3-获取与分析方法"><a href="#3-获取与分析方法" class="headerlink" title="3.获取与分析方法"></a>3.获取与分析方法</h3><h4 id="1-用户调研"><a href="#1-用户调研" class="headerlink" title="1.用户调研"></a>1.用户调研</h4><p>目的是解决<strong>需求的模糊性</strong>(说不清楚要什么)</p><p>最有效的方法：</p><ul><li><p><strong>原型法</strong></p><ul><li><p>用户调研+原型法——解决<strong>需求的模糊性</strong></p></li><li><p>原型既可以是可操作的软件界面，也可以是草图原型等</p></li><li><p>根据运用原型的目的与方式不同，可分为：</p><ul><li><p>快速原型</p></li><li><p>进化原型</p></li></ul></li></ul></li></ul><h4 id="2-深入观察与挖掘"><a href="#2-深入观察与挖掘" class="headerlink" title="2.深入观察与挖掘"></a>2.深入观察与挖掘</h4><p>目的是解决<strong>需求的隐蔽性</strong>(客户告知的需求是表象&#x2F;客户不愿告知&#x2F;客户未知)</p><p>方法包括：</p><ul><li>现场观察与挖掘</li><li>数据分析</li><li>市场行业分析</li><li>竞品分析</li><li>头脑风暴</li><li>群体化方法</li></ul><p>最有效的方法(理论)：</p><ul><li><strong>扎根蘑菇群理论</strong></li><li><strong>黄金圈理论</strong><ul><li>都属于<strong>现场观察与挖掘</strong>方法</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231205730694.png" alt="image-20241231205730694"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231205721846.png" alt="image-20241231205721846"></p><h4 id="3-用例"><a href="#3-用例" class="headerlink" title="3.用例"></a>3.用例</h4><p>目的是解决<strong>需求的多样性</strong></p><p>方法：</p><ul><li>针对不同用户的不同需求，回答：<ul><li>系统应该为每个用户做什么<ul><li>从每个用户case或story进行各项需求评判</li></ul></li><li>有效界定系统范围，为整个用户提供最大价值</li></ul></li></ul><p>步骤：</p><ul><li>识别User类型</li><li>Case&#x2F;Story构建(为所有用户)</li><li>汇总、协商确定与优先级排序</li></ul><hr><h3 id="4-例题-1"><a href="#4-例题-1" class="headerlink" title="4.例题"></a>4.例题</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231210002380.png" alt="image-20241231210002380"></p><blockquote><p>C</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231210011501.png" alt="image-20241231210011501"></p><blockquote><p>AB</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231210019979.png" alt="image-20241231210019979"></p><blockquote><p>BD</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231210027334.png" alt="image-20241231210027334"></p><blockquote><p>C</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231210933065.png" alt="image-20241231210933065"></p><blockquote><p>D</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231210943463.png" alt="image-20241231210943463"></p><blockquote><p>D</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231210951459.png" alt="image-20241231210951459"></p><blockquote><p>AD</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231211002068.png" alt="image-20241231211002068"></p><blockquote><p>ABCD</p></blockquote><hr><h2 id="4-需求文档编写"><a href="#4-需求文档编写" class="headerlink" title="4.需求文档编写"></a>4.需求文档编写</h2><blockquote><p>需求螺旋迭代过程的第二部分</p></blockquote><h3 id="1-需求规格说明的作用与要求"><a href="#1-需求规格说明的作用与要求" class="headerlink" title="1.需求规格说明的作用与要求"></a>1.需求规格说明的作用与要求</h3><p><strong>软件需求规格说明</strong>，简称<strong>SRS</strong>，也称为<strong>功能规格说明、产品规格说明、需求文档</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231211213825.png" alt="image-20241231211213825"></p><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><ul><li>记录共识</li><li>确认共识</li><li>完整正确地传递共识给开发人员</li></ul><hr><h4 id="2-撰写要求"><a href="#2-撰写要求" class="headerlink" title="2.撰写要求"></a>2.撰写要求</h4><p>撰写要求需要符合<strong>文档的软工原则</strong></p><ul><li>完整性<ul><li>三个需求层次的需求都要在SRS中有对应的文档信息</li><li>应涵盖需求两大类型</li><li>涵盖不同用户需求</li></ul></li><li>一致性<ul><li>同一文档的需求一致</li><li>不同用户的需求不相互矛盾</li><li>不同层次需求的一致性</li></ul></li><li>可阅读性<ul><li>长度适当，版面规整，条理清楚，层次分明</li></ul></li><li>无二义性<ul><li>字面意思</li></ul></li><li>可修改性<ul><li>能依据该需求成功设计测试用例</li></ul></li><li>可跟踪性</li><li>可测试性</li><li>可维护性</li></ul><hr><h3 id="2-需求规格说明的撰写方法"><a href="#2-需求规格说明的撰写方法" class="headerlink" title="2.需求规格说明的撰写方法"></a>2.需求规格说明的撰写方法</h3><p>一般性方法：<strong>套用模板法</strong></p><p>步骤：</p><ul><li>第一步：选择文档模板<ul><li>行业内认可度高的模板&#x2F;企业已有模板</li></ul></li><li>第二步：裁剪文档模板</li><li>第三步：选择描述语言，进行文档写作<ul><li>满足SRS的一般性要求</li><li>描述语言包括<ul><li>自然语言</li><li>结构化语言(例如标准化的表格模板)</li><li><strong>图形化的建模语言(如UML)</strong></li></ul></li></ul></li></ul><h4 id="1-业务需求规格说明"><a href="#1-业务需求规格说明" class="headerlink" title="1.业务需求规格说明"></a>1.业务需求规格说明</h4><ul><li>模板：<strong>项目前景与范围文档</strong></li><li>来源：微软开发过程&#x2F;统一过程</li><li>描述语言：<ul><li>自然语言</li><li>结构化自然语言(如标准化的表格模板)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231212037087.png" alt="image-20241231212037087"></p><h4 id="2-用户需求规格说明"><a href="#2-用户需求规格说明" class="headerlink" title="2.用户需求规格说明"></a>2.用户需求规格说明</h4><ul><li>模板：<strong>用例文档</strong></li><li>来源：统一过程RUP的模板</li><li>描述语言：<ul><li>自然语言</li><li>结构化自然语言</li><li>图形化建模语言——UML</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231212126429.png" alt="image-20241231212126429"></p><h4 id="3-系统需求规格说明"><a href="#3-系统需求规格说明" class="headerlink" title="3.系统需求规格说明"></a>3.系统需求规格说明</h4><ul><li>模板：<strong>系统需求规格说明(系统SRS)</strong></li><li>来源：IEEE 830-1998</li><li>描述语言<ul><li>自然语言</li><li>结构化自然语言(如标准化的表格模板)</li><li>图形(如用户界面原型图)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231212234587.png" alt="image-20241231212234587"></p><hr><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>SRS的高效撰写</p><ul><li>方法：<strong>套用模板+UML可视化建模</strong></li><li>对模板内容的深入理解<ul><li>三个层次需求文档的依赖关系</li></ul></li></ul><hr><h3 id="3-需求分析建模与统一建模语言UML"><a href="#3-需求分析建模与统一建模语言UML" class="headerlink" title="3.需求分析建模与统一建模语言UML"></a>3.需求分析建模与统一建模语言UML</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231214112754.png" alt="image-20241231214112754"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231214119606.png" alt="image-20241231214119606"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231214130110.png" alt="image-20241231214130110"></p><blockquote><p>现在最新的UML标准是UML2.5</p></blockquote><p>具体的UML绘图会在后续章节讲述，此处省略</p><hr><h3 id="4-例题-2"><a href="#4-例题-2" class="headerlink" title="4.例题"></a>4.例题</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231214234759.png" alt="image-20241231214234759"></p><blockquote><p>D</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231214241696.png" alt="image-20241231214241696"></p><blockquote><p>C</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231214305121.png" alt="image-20241231214305121"></p><blockquote><p>C</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231214312172.png" alt="image-20241231214312172"></p><blockquote><p>A</p></blockquote><hr><h2 id="5-需求验证与变更"><a href="#5-需求验证与变更" class="headerlink" title="5.需求验证与变更"></a>5.需求验证与变更</h2><h3 id="1-需求验证"><a href="#1-需求验证" class="headerlink" title="1.需求验证"></a>1.需求验证</h3><h4 id="1-意义"><a href="#1-意义" class="headerlink" title="1.意义"></a>1.意义</h4><p>需求验证的<strong>重要性</strong>：如果后续开发或系统投入使用时才发现需求文档中的错误，那么<strong>返工的代价更大</strong></p><hr><h4 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h4><p><strong>验证需求文档，发现错误&#x2F;伪需求并修改</strong></p><ul><li>有效性检查</li><li>一致性检查</li><li>完备性检查</li><li>现实性检查&#x2F;可行性分析</li></ul><hr><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h4><ul><li>需求评审<ul><li>正式技术评审、非正式技术评审</li><li>参与评审人员：用户&#x2F;客户、开发人员、测试人员、文档编写人员，项目经理等，7人左右</li></ul></li><li>原型法<ul><li>确定合适原型</li><li>将需求验证涉及的<strong>业务过程或场景</strong>定义出来</li><li>原型法与用例法结合</li></ul></li><li>需求验证漏斗<ul><li><strong>依据黄金圈法则</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231214814521.png" alt="image-20241231214814521"></p><ul><li>需求强调评估<ul><li><strong>需求强度&#x3D;潜在用户数+使用频率</strong></li></ul></li><li>编写测试用例</li><li>编写用户手册</li><li>自动的一致性分析(如CASE工具)</li></ul><hr><h3 id="2-需求签约"><a href="#2-需求签约" class="headerlink" title="2.需求签约"></a>2.需求签约</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p>需求验证结束后的重要工作——<strong>需求签约</strong></p><ul><li>软件需求签约，是<strong>软件项目最关键的一步</strong></li><li>强调签约的必要性、权威性、严肃性、实用性是软件成功的基本保证</li></ul><h4 id="2-意义与内容"><a href="#2-意义与内容" class="headerlink" title="2.意义与内容"></a>2.意义与内容</h4><p><strong>意义：</strong></p><ul><li>对需求分析不断沟通完善的<strong>过程</strong>和过程产生的<strong>结果SRS</strong>的<strong>确认</strong></li><li>签约一旦生效，表明：<ul><li>同意了这份文档代表此刻对项目需求的最佳理解</li><li>被确认的SRS是<strong>软件需求的基线</strong>，是<strong>后续软件开发和验收的依据</strong></li></ul></li><li>对未来可能出现的需求变化的<strong>应对指南</strong><ul><li>进一步变更将在此<strong>基线</strong>的基础上，依照项目的<strong>变更过程</strong>进行</li><li>变更批准后，<strong>重新协商</strong>项目成本、资源、进度的约定</li></ul></li></ul><hr><h3 id="3-需求变更管理"><a href="#3-需求变更管理" class="headerlink" title="3.需求变更管理"></a>3.需求变更管理</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231215243053.png" alt="image-20241231215243053"></p><hr><h3 id="4-例题-3"><a href="#4-例题-3" class="headerlink" title="4.例题"></a>4.例题</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231215256022.png" alt="image-20241231215256022"></p><blockquote><p>A</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231215318031.png" alt="image-20241231215318031"></p><blockquote><p>D</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231215325316.png" alt="image-20241231215325316"></p><blockquote><p>C</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231215332655.png" alt="image-20241231215332655"></p><blockquote><p>AD</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241231215342284.png" alt="image-20241231215342284"></p><blockquote><p>D</p></blockquote><hr><h2 id="6-统一过程"><a href="#6-统一过程" class="headerlink" title="6.统一过程"></a>6.统一过程</h2><blockquote><p>统一过程，全称<strong>Rational Unified Process</strong>，即<strong>RUP</strong></p><p>基于UML的过程框架</p></blockquote><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>提出者：Rational公司+UML的创立者</li><li><strong>RUP内容及特点</strong><ul><li>一种典型完整的软件过程模式<ul><li><strong>生命周期模型(过程模型)</strong></li><li>人员</li><li>方法</li><li>产品</li></ul></li><li>一种软件过程产品<ul><li>Rational&#x2F;IBM开发维护</li><li>与Rational一系列其他软件开发工具集成</li></ul></li></ul></li></ul><hr><h3 id="2-RUP软件过程模型"><a href="#2-RUP软件过程模型" class="headerlink" title="2.RUP软件过程模型"></a>2.RUP软件过程模型</h3><h4 id="1-概要"><a href="#1-概要" class="headerlink" title="1.概要"></a>1.概要</h4><p><strong>迭代与增量的生命周期结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101193532446.png" alt="image-20250101193532446"></p><ul><li>横轴<ul><li>时间组织</li><li>体现动态结构<ul><li><strong>生命周期中的动态结构——四个阶段</strong></li></ul></li><li>术语：阶段、里程碑、迭代和增量<ul><li>四个阶段：<strong>先启阶段</strong>，<strong>精化阶段</strong>，<strong>构建阶段</strong>，<strong>产品化阶段</strong></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101193748180.png" alt="image-20250101193748180"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101193940309.png" alt="image-20250101193940309"></p><ul><li>纵轴<ul><li>内容组织为<strong>逻辑活动</strong></li><li>体现静态结构<ul><li><strong>生命周期中的静态结构——9个核心工作流程</strong></li></ul></li><li>术语：工作流程、活动、角色、工件<ul><li>工作流程代表了所有角色、活动与工件的逻辑分组情况，即<strong>软件过程模式中的3个要素</strong></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101194152360.png" alt="image-20250101194152360"></p><hr><h4 id="2-核心工作流程"><a href="#2-核心工作流程" class="headerlink" title="2.核心工作流程"></a>2.核心工作流程</h4><blockquote><p><strong>生命周期中的静态结构——9个核心工作流程</strong></p></blockquote><p><strong>核心工作流程组成：</strong></p><ul><li><strong>核心过程工作流程</strong>：前6个<ul><li>业务建模</li><li>需求</li><li>分析设计</li><li>实施</li><li>测试</li><li>部署</li></ul></li><li><strong>核心支持工作流程</strong>：后3个<ul><li>配置与变更管理</li><li>项目管理</li><li>环境</li></ul></li></ul><p><strong>表示方法：</strong></p><ul><li>UML中：协同图、时序图、活动图</li><li>RUP中：<strong>活动图</strong></li></ul><p><strong>内容：</strong></p><ul><li>一套完整的UML全色i官方使用指南</li></ul><hr><h5 id="1-业务建模"><a href="#1-业务建模" class="headerlink" title="1.业务建模"></a>1.业务建模</h5><p>意义：</p><ul><li>打造软件核心竞争力</li><li>不同的业务建模决定软件不同的命运</li></ul><p>启示：</p><ul><li>创新能力</li><li>具备不同行业专业领域的专业知识</li></ul><h5 id="2-需求"><a href="#2-需求" class="headerlink" title="2.需求"></a>2.需求</h5><p>捕获需求，并使开发人员与客户就该需求达成共识</p><p>使用<strong>用例方法</strong>——对需要的功能和约束进行提取、组织、文档化，理解系统所解决问题的定义和范围</p><h5 id="3-分析设计"><a href="#3-分析设计" class="headerlink" title="3.分析设计"></a>3.分析设计</h5><p>将需求转化为未来系统的设计</p><p><strong>以架构设计为核心</strong>——产品的适应性、可扩展性</p><h5 id="7-配置与变更管理"><a href="#7-配置与变更管理" class="headerlink" title="7.配置与变更管理"></a>7.配置与变更管理</h5><p>描述如何再多个成员组成的项目中控制大量的产物，并提供了准则来管理演化系统中的多个变体，跟踪软件创建过程中的版本</p><h5 id="8-项目管理"><a href="#8-项目管理" class="headerlink" title="8.项目管理"></a>8.项目管理</h5><p>平衡竞争的目标、管理风险、克服各种约束，从而成功交付使用户满意的产品</p><h5 id="9-环境"><a href="#9-环境" class="headerlink" title="9.环境"></a>9.环境</h5><p>向软件开发组织提供软件开发的环境，包括过程和CASE工具</p><hr><h4 id="3-四个阶段"><a href="#3-四个阶段" class="headerlink" title="3.四个阶段"></a>3.四个阶段</h4><blockquote><p><strong>生命周期中的动态结构——四个阶段</strong></p></blockquote><ul><li>每个阶段：由1次或多次迭代完成</li><li>迭代过程是受控的：<ul><li>项目计划中：制定<ul><li>迭代的次数</li><li>每次迭代的持续时间</li><li>每次迭代的目标</li></ul></li><li>详细迭代计划中：制定<ul><li>具体的工作流程</li></ul></li></ul></li></ul><h5 id="1-先启阶段"><a href="#1-先启阶段" class="headerlink" title="1.先启阶段"></a>1.先启阶段</h5><ul><li>目标：建立业务用例、确定项目的范围和边界</li><li>结束里程碑：<strong>生命周期目标里程碑</strong></li><li>评审标准：</li></ul><h5 id="2-精化阶段"><a href="#2-精化阶段" class="headerlink" title="2.精化阶段"></a>2.精化阶段</h5><ul><li>目标：建立稳定的架构、编址项目计划、淘汰项目中最高风险元素</li><li>结束里程碑：<strong>生命周期架构里程碑</strong></li><li>评审标准：</li></ul><h5 id="3-构建阶段"><a href="#3-构建阶段" class="headerlink" title="3.构建阶段"></a>3.构建阶段</h5><ul><li>目标：所有构件和应用程序功能被开发并集成为产品、所有功能被详尽的测试</li><li>结束里程碑：<strong>最初操作性能里程碑</strong></li><li>评审标准：</li></ul><h5 id="4-产品化阶段"><a href="#4-产品化阶段" class="headerlink" title="4.产品化阶段"></a>4.产品化阶段</h5><ul><li>目标：将软件产品交付给用户群体</li><li>结束里程碑：<strong>产品发布里程碑</strong></li><li>评审标准：</li></ul><hr><h3 id="3-RUP与螺旋模型异同"><a href="#3-RUP与螺旋模型异同" class="headerlink" title="3.RUP与螺旋模型异同"></a>3.RUP与螺旋模型异同</h3><p><strong>相似点：</strong></p><ul><li>**迭代与增量：**都采用迭代和增量式开发</li><li><strong>风险管理</strong>：高度重视风险管理</li></ul><p><strong>不同点：</strong></p><ul><li><strong>生命周期的结构：</strong><ul><li>RUP的生命周期模型分了4个阶段</li><li>螺旋模型采用螺旋式的周期结构</li></ul></li><li><strong>开发进程的管理方式：</strong><ul><li>RUP采用相对严格的迭代流程，一个迭代周期内，多个工作流程可以并行</li><li>螺旋模型强调串行的活动和连续的反馈</li></ul></li><li><strong>关注的重点：</strong><ul><li>RUP重视过程和质量管理</li><li>螺旋模型重视风险管理</li></ul></li><li><strong>适用范围与灵活性</strong><ul><li>RUP适合中到大型的软件开发项目，特别适用于有多个团队协作的复杂项目</li><li>螺旋模型适用于风险较高的项目，特别是在需求不确定或项目规模较大时</li></ul></li></ul><hr><h3 id="4-例题-4"><a href="#4-例题-4" class="headerlink" title="4.例题"></a>4.例题</h3><blockquote><p>在统一过程的九大核心工作流程中，第一项工作流程为什么不是<strong>需求</strong>？是否与软件过程框架冲突？</p></blockquote><ul><li>统一过程强调的不仅是技术问题，还涉及商业和组织方面的考虑。<strong>业务建模优先的稳定性强</strong></li><li>RUP中，<strong>通过业务建模提前确保开发工作与业务需求保持一致，是一种增强需求管理的方式</strong>，不冲突</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101200630699.png" alt="image-20250101200630699"></p><blockquote><p>B</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101200639209.png" alt="image-20250101200639209"></p><blockquote><p>B</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101200646351.png" alt="image-20250101200646351"></p><blockquote><p>ACD</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101200739676.png" alt="image-20250101200739676"></p><blockquote><p>并行的关键在于，第n步的设计是基于第n-1步需求的，这样才能<strong>并行</strong></p></blockquote><h2 id="7-敏捷过程"><a href="#7-敏捷过程" class="headerlink" title="7.敏捷过程"></a>7.敏捷过程</h2><blockquote><p><strong>敏捷过程</strong>，全称<strong>Agile Process</strong>，即<strong>AP</strong>，中文名又称<strong>敏捷开发&#x2F;敏捷实践</strong></p></blockquote><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li><p>AP的提出</p><ul><li>互联网广泛应用后</li><li>为了矫正繁琐的软件过程</li><li><strong>2001年2月正式发布敏捷软件宣言</strong></li></ul></li><li><p>AP内容及特点</p><ul><li><strong>软件开发宣言</strong><ul><li><strong>使用AP的软件团队具有快速工作、快速响应变化的能力</strong></li></ul></li><li><strong>4条基本价值观+12条原则</strong><ul><li>过程模型+人员+方法+产品及关系</li></ul></li></ul></li><li><p>AP旗下的敏捷型软件过程流派</p><ul><li>重点讲述<strong>SCRUM</strong>和<strong>极限编程XP(eXtreme Programming)</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101201240320.png" alt="image-20250101201240320"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101201256723.png" alt="image-20250101201256723"></p><ul><li>AP的掌握与应用<ul><li>思想方式较为<strong>前卫</strong></li><li><strong>宣言定义的只是偏好，并不是说完全排斥某些东西，而是更重视一方</strong></li></ul></li></ul><hr><h3 id="2-敏捷过程的价值观与原则"><a href="#2-敏捷过程的价值观与原则" class="headerlink" title="2.敏捷过程的价值观与原则"></a>2.敏捷过程的价值观与原则</h3><h4 id="1-12条原则"><a href="#1-12条原则" class="headerlink" title="1.12条原则"></a>1.12条原则</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101201445449.png" alt="image-20250101201445449"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101201456253.png" alt="image-20250101201456253"></p><hr><h4 id="2-4条价值观"><a href="#2-4条价值观" class="headerlink" title="2.4条价值观"></a>2.4条价值观</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101201537241.png" alt="image-20250101201537241"></p><ul><li><strong>个体和交互</strong>胜过<strong>过程和工具</strong><ul><li>人是最重要因素</li><li>当然不用过程和工具也很蠢</li></ul></li><li><strong>可以工作的软件</strong>胜过<strong>面面俱到的文档</strong><ul><li>软件开发的主要目标，是交付给用户可以工作的软件</li><li><strong>过多</strong>的面面俱到文档比<strong>过少</strong>的文档更糟<ul><li>耗费时间精力，甚至与代码不同步时产生误导</li></ul></li></ul></li><li><strong>客户合作</strong>胜过<strong>合同谈判</strong><ul><li>客户不可能一次性把需求全搞清楚发给乙方</li></ul></li><li><strong>响应变化</strong>胜过<strong>遵循计划</strong><ul><li>变化是事实</li><li><strong>响应变化胜过遵循计划的意义在于——变更代表机遇</strong></li></ul></li></ul><hr><h3 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101201959159.png" alt="image-20250101201959159"></p><blockquote><p>AB</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101202009564.png" alt="image-20250101202009564"></p><blockquote><p>A</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101202047695.png" alt="image-20250101202047695"></p><blockquote><p>B</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101202103360.png" alt="image-20250101202103360"></p><blockquote><p>D</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101202109298.png" alt="image-20250101202109298"></p><blockquote><p>A</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101202114672.png" alt="image-20250101202114672"></p><blockquote><p>AD</p></blockquote><h3 id="4-极限编程"><a href="#4-极限编程" class="headerlink" title="4.极限编程"></a>4.极限编程</h3><blockquote><p>极限编程，全称<strong>eXtreme Programming</strong>，即<strong>XP</strong></p><ul><li>敏捷过程模型+方法技术</li></ul></blockquote><h4 id="1-过程模型"><a href="#1-过程模型" class="headerlink" title="1.过程模型"></a>1.过程模型</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101202312113.png" alt="image-20250101202312113"></p><hr><h4 id="2-技术方法"><a href="#2-技术方法" class="headerlink" title="2.技术方法"></a>2.技术方法</h4><p><strong>提出了14项最佳实践(技术方法)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101202352420.png" alt="image-20250101202352420"></p><ul><li><p>用户素材与用户故事</p><ul><li>用户素材<ul><li>正在进行的关于需求谈话的<strong>助记符</strong></li><li>一个<strong>计划工具</strong>，客户使用它并根据它的优先级和估算代价来安排实现该需求的时间</li></ul></li><li>用户故事(User Story)<ul><li>将故事分解为任务用于规划系统迭代</li><li>类似于RUP的User Case</li></ul></li></ul></li><li><p>结对编程</p><ul><li>两个开发人员，同一台电脑，一个编程，一个保证代码正确性可读性</li><li>作用：<strong>非正式的同级评审-代码复审</strong></li><li>注意：结对编程是加强开发人员沟通评审的一种方式，但<strong>不唯一</strong></li></ul></li><li><p>测试驱动开发</p><ul><li><strong>XP强调测试先行</strong><ul><li>编码前，先把测试写好</li></ul></li><li><strong>测试自动化是测试先行的必要条件</strong></li><li>与RUP相比：<ul><li>RUP和XP对测试都很重视，但是<strong>两者对于测试在整个项目开发周期内首先出现的位置的处理不同</strong></li></ul></li></ul></li><li><p>重构</p><ul><li>调整、优化系统内部结构，减少复杂性、消除冗余、增加灵活性、提高性能</li><li><strong>运用方法：</strong><ul><li>代码重构与<strong>简单化设计思想</strong>一脉相承</li><li>注意不要过分依赖重构，而轻视设计</li></ul></li><li>对比RUP：RUP<strong>以构架为中心</strong></li></ul></li></ul><hr><h4 id="3-内核"><a href="#3-内核" class="headerlink" title="3.内核"></a>3.内核</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101203032473.png" alt="image-20250101203032473"></p><hr><h3 id="5-SCRUM"><a href="#5-SCRUM" class="headerlink" title="5.SCRUM"></a>5.SCRUM</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h4><ul><li>发展史：<ul><li>1980，两个人在IBM项目合作中诞生SCRUM</li></ul></li><li>内容：<ul><li><strong>包括一系列实践的过程框架和预定义角色</strong></li></ul></li><li>目的：<ul><li><strong>一定程度上提供敏捷项目进展状况的外部可见性</strong></li></ul></li><li>影响力：<ul><li>被PLOP作为组织和过程模式的标准</li></ul></li></ul><hr><h4 id="2-过程模型"><a href="#2-过程模型" class="headerlink" title="2.过程模型"></a>2.过程模型</h4><p><strong>SCRUM过程模型也是一种迭代式增量的过程</strong></p><ul><li>SCRUM的生命周期是<strong>不停循环</strong>的</li><li>整个生命周期在<strong>固定的时间段内完成</strong>，称为<strong>Sprint</strong><ul><li><strong>Sprint</strong>通常需要2-4周</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101203530183.png" alt="image-20250101203530183"></p><h5 id="1-计划和体系结构设计"><a href="#1-计划和体系结构设计" class="headerlink" title="1.计划和体系结构设计"></a>1.计划和体系结构设计</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101203543527.png" alt="image-20250101203543527"></p><hr><h5 id="2-Sprint"><a href="#2-Sprint" class="headerlink" title="2.Sprint"></a>2.Sprint</h5><ul><li>Sprint周期在<strong>2-4周</strong></li><li>Spring产出是可用的、潜在可发布的产品增量</li><li>Sprint迭代周期长度<strong>一旦确定就保持不变</strong></li><li>Sprint进行过程中，<strong>开发目标、质量验收标准、团队构成不再变化</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101203551006.png" alt="image-20250101203551006"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101203641452.png" alt="image-20250101203641452"></p><hr><h5 id="3-交付和巩固"><a href="#3-交付和巩固" class="headerlink" title="3.交付和巩固"></a>3.交付和巩固</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101203722844.png" alt="image-20250101203722844"></p><hr><h5 id="4-SCRUM特点"><a href="#4-SCRUM特点" class="headerlink" title="4.SCRUM特点"></a>4.SCRUM特点</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101203834211.png" alt="image-20250101203834211"></p><h4 id="3-与螺旋模型的对比"><a href="#3-与螺旋模型的对比" class="headerlink" title="3.与螺旋模型的对比"></a>3.与螺旋模型的对比</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101203903251.png" alt="image-20250101203903251"></p><h4 id="4-角色"><a href="#4-角色" class="headerlink" title="4.角色"></a>4.角色</h4><p>分为了<strong>猪组角色和鸡组角色</strong></p><ul><li>猪组：无退路，开发人员</li><li>鸡组：参与项目，失败了损失不大，用户、客户等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101203923636.png" alt="image-20250101203923636"></p><hr><h3 id="6-例题2"><a href="#6-例题2" class="headerlink" title="6.例题2"></a>6.例题2</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101204043059.png" alt="image-20250101204043059"></p><blockquote><p>C</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101204057314.png" alt="image-20250101204057314"></p><blockquote><p>A</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20250101204103311.png" alt="image-20250101204103311"></p><blockquote><p>ABC</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件工程导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记-链路层</title>
      <link href="/2024/12/24/ji-wang-xue-xi-bi-ji-lian-lu-ceng/"/>
      <url>/2024/12/24/ji-wang-xue-xi-bi-ji-lian-lu-ceng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="第六章-链路层和局域网"><a href="#第六章-链路层和局域网" class="headerlink" title="第六章 链路层和局域网"></a>第六章 链路层和局域网</h1><h2 id="1-概述与服务"><a href="#1-概述与服务" class="headerlink" title="1.概述与服务"></a>1.概述与服务</h2><h3 id="1-网络层与链路层"><a href="#1-网络层与链路层" class="headerlink" title="1.网络层与链路层"></a>1.网络层与链路层</h3><ul><li>网络层：提供<strong>主机之间</strong>的通信服务，将传输层报文段<strong>从源主机传送到目的主机</strong><ul><li>能够在各段**链路层提供异构服务(不同协议)**的情况下，完成端到端的工作</li></ul></li><li>链路层：提供<strong>节点之间</strong>的通信服务，将网络层数据报<strong>从一个节点传送到下一个节点</strong><ul><li><strong>不同的链路采用不同的链路层协议</strong>，提供的服务不同</li></ul></li></ul><hr><h3 id="2-链路层信道类型"><a href="#2-链路层信道类型" class="headerlink" title="2.链路层信道类型"></a>2.链路层信道类型</h3><p>链路层信道分为：<strong>广播链路</strong>和<strong>点对点通信链路</strong></p><p><strong>广播链路(共享线路或媒体)：</strong></p><ul><li>许多主机被<strong>连接到相同的通信信道</strong><ul><li>需要**媒体访问协议(MAC)**来协调传输和避免”碰撞”</li><li>链路层协议及其实现包括：<ul><li><strong>以太网</strong>：802.3协议的实现</li><li><strong>无线局域网</strong>：802.11协议的实现</li><li><strong>卫星网</strong>等</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224153718256.png" alt="image-20241224153718256"></p><p><strong>点对点通信链路：</strong></p><ul><li><strong>直接链接2个节点的链路，每一端有一个节点</strong><ul><li>访问控制简单</li><li>主要解决的问题：成帧、可靠数据传输、差错检测、流量控制</li></ul></li><li>常用于两台路由器之间的通信链路，拨号调制解调器与ISP路由器之间的通信链路</li></ul><hr><h3 id="3-一些术语"><a href="#3-一些术语" class="headerlink" title="3.一些术语"></a>3.一些术语</h3><ul><li>主机和路由器是<strong>节点</strong></li><li>连接了沿通信路径的相邻节点的路径是<strong>链路</strong><ul><li>分为：有线链路，无线链路</li></ul></li><li>第二层(链路层)的分组叫<strong>帧</strong>，封装数据报</li></ul><p><strong>数据链路层具有经一条链路从 <em>一个节点</em> 传输数据到 <em>相邻节点</em> 的能力</strong></p><ul><li>不同的链路会采用不同的<strong>链路层协议</strong>，这些协议包括<ul><li>以太网(802.3协议)</li><li>帧中继</li><li>无线局域网(802.11协议)</li><li>…</li></ul></li><li>每个链路协议提供不同的服务<ul><li>可靠数据传输</li><li>不可靠数据传输</li></ul></li></ul><hr><h3 id="4-链路层服务"><a href="#4-链路层服务" class="headerlink" title="4.链路层服务"></a>4.链路层服务</h3><p>链路层的<strong>基本服务</strong>：将网络层数据报通过单一通信链路从一个节点移动到<strong>相邻节点</strong></p><p>具体服务如下：</p><ul><li><p><strong>成帧，链路访问</strong></p><ul><li>将数据报封装进<strong>帧</strong>，加上<strong>首部</strong>和<strong>尾部</strong></li><li>如果是<strong>共享媒体</strong>，<strong>MAC协议</strong>协调多路访问</li><li>位于帧首部的**”MAC地址”**标识源、目的地<ul><li><strong>MAC地址与IP地址不同</strong></li></ul></li></ul></li><li><p>相连节点间的可靠交付</p><ul><li>可靠交付保证的是帧能够无差错的从节点A传输到下一个节点B</li><li>这在比特差错低的链路很少使用(如光纤，部分双绞线)</li><li><strong>无线链路</strong>：<strong>高差错率</strong><ul><li>需要差错检测、纠错功能</li></ul></li></ul></li><li><p>流量控制</p><ul><li>相邻发送和接收节点的步调一致</li></ul></li><li><p>差错检测</p><ul><li>差错由信号衰减、噪声所致</li><li><strong>接收方检测差错的存在(即确认)，发送方负责重传</strong></li></ul></li><li><p>纠错</p><ul><li><strong>接收方纠正比特差错，不采取重传</strong></li></ul></li><li><p>半双工+全双工</p><ul><li>半双工：通信设备可以<strong>双向传输数据</strong>，但<strong>只能在某一时刻</strong>进行发送或接收，而不能同时进行发送和接收。</li></ul></li></ul><blockquote><p>Question1：为什么同时使用链路级和端到端可靠性?</p><ul><li><strong>链路级可靠性</strong>保证的是每个<strong>链路段</strong>的数据传输质量，通常适用于点对点的链路或单一的传输媒介</li><li><strong>端到端可靠性</strong>则确保的是从<strong>源端到目标端</strong>整个网络路径中的数据传输可靠性，涉及多个路由和链路的传输问题</li></ul></blockquote><blockquote><p>Question2：如果在因特网中的所有链路都提供可靠交付服务，TCP可靠传输服务是多余的吗？</p><p><strong>需要！TCP可靠传输可以将失序报文重排，但链路层的可靠传输服务无法做到，因为他们没法去对多个报文进行可靠服务</strong></p></blockquote><blockquote><p>Question3：是否所有的链路层协议都提供可靠数据传输服务？</p><p><strong>否！以太网协议就没有可靠数据传输服务，但这是因为他本身的出错率低，不太需要</strong></p><p><strong>以太网协议是无连接的不可靠服务</strong></p></blockquote><hr><h3 id="5-网络适配器"><a href="#5-网络适配器" class="headerlink" title="5.网络适配器"></a>5.网络适配器</h3><p>每个节点是通过什么来实现链路层通信的？</p><p>——<strong>网络适配器</strong></p><p>节点在**适配器(NIC)**中实现链路层</p><ul><li>比较知名的就是，<strong>以太网卡</strong>和<strong>802.11卡</strong></li></ul><p><strong>发送侧适配器</strong></p><ul><li>将数据报封装在帧中</li><li>增加差错检测比特，可靠数据传输，流量控制等</li></ul><p><strong>接收侧适配器</strong></p><ul><li><p>提取数据报，传递到接收节点</p></li><li><p>查找差错，可靠数据传输，流量控制</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224160304249.png" alt="image-20241224160304249"></p><hr><h2 id="2-差错检测和纠错"><a href="#2-差错检测和纠错" class="headerlink" title="2.差错检测和纠错"></a>2.差错检测和纠错</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><p>发送方在信息数据(<strong>帧</strong>)的<strong>尾部</strong>添加冗余数据<strong>EDC</strong>用于差错检测和纠正</p><p>接收方检查帧与EDC之间的关系，发现差错</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224160709347.png" alt="image-20241224160709347"></p><hr><h3 id="2-奇偶校验"><a href="#2-奇偶校验" class="headerlink" title="2.奇偶校验"></a>2.奇偶校验</h3><h4 id="1-单比特奇偶校验"><a href="#1-单比特奇偶校验" class="headerlink" title="1.单比特奇偶校验"></a>1.单比特奇偶校验</h4><p>单比特奇偶校验的EDC&#x3D;1位，用它来使<code>D+EDC</code>中<code>1</code>的个数为奇数&#x2F;偶数</p><ul><li>奇校验：<code>D+EDC</code>的<code>1</code>的个数为奇数</li><li>偶校验：<code>D+EDC</code>的<code>1</code>的个数为偶数</li></ul><p><strong>单比特奇偶校验错误率为50%</strong></p><hr><h4 id="2-二维比特奇偶校验"><a href="#2-二维比特奇偶校验" class="headerlink" title="2.二维比特奇偶校验"></a>2.二维比特奇偶校验</h4><p>二维比特奇偶校验，可以<strong>检测2个比特差错</strong>，<strong>纠正单个比特差错</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224161159102.png" alt="image-20241224161159102"></p><hr><h3 id="3-Internet校验和"><a href="#3-Internet校验和" class="headerlink" title="3.Internet校验和"></a>3.Internet校验和</h3><p>这个差错检验方式在TCP，UDP，IP的校验和字段都使用过，此处不再详述，只是再强调一下过程：</p><ul><li>求和</li><li>回卷(高位溢出，回卷)</li><li>取反</li></ul><hr><h3 id="4-循环冗余码校验CRC"><a href="#4-循环冗余码校验CRC" class="headerlink" title="4.循环冗余码校验CRC"></a>4.循环冗余码校验CRC</h3><p>循环冗余校验码CRC是计算机网络和数据通信中使用最为广泛的检错码之一</p><p><strong>原理：</strong></p><ul><li>发送方和接收方约定一个**<code>r+1</code>比特的生成多项式G(x)**<ul><li>G(x)可以看成系数为0&#x2F;1的多项式</li><li>以下图为例，考题可能会以多项式的形式给出G(x)，转换为二进制即可</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224161628390.png" alt="image-20241224161628390"></p><ul><li><p>发送方用<strong>帧信息D</strong>对<strong>G(x)<strong>进行</strong>模2除法</strong>，得到余数，并首部补0扩充为**<code>r</code>比特的校验和R**</p><ul><li>模2运算：加减法不进位&#x2F;借位(可以当成每一位的异或运算)</li></ul></li><li><p>发送方在<strong>帧信息D</strong>的末尾添加<strong>校验和R</strong>，得到带CRC校验和的帧<strong>DR</strong></p></li><li><p>接收方收到后，用<strong>DR’<strong>对</strong>G(x)<strong>进行</strong>模2除法</strong>，若不能整除，则传输有错</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224162216104.png" alt="image-20241224162216104"></p><blockquote><p>Question：如果传输过程中，DR最后2个比特翻转，用G是否可以检测出来？</p><p><strong>当然！</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224162850004.png" alt="image-20241224162850004"></p><blockquote><p>Question2：如何可以检测出连续r比特的突发差错?</p><ul><li><strong>检测条件</strong>：当 <strong>r ≤ k-1</strong>（生成多项式的度数），CRC 就能检测到长度为 <strong>r</strong> 的突发差错。</li></ul><p>Question3：何时能够检查两位比特错误？</p><ul><li>CRC 校验能够 <strong>检测到两位比特错误</strong>，但这取决于选择的 <strong>生成多项式</strong></li><li>如果生成多项式的度数较高（如 CRC-16 或 CRC-32），则能够有效检测到两位比特错误<ul><li><strong>CRC-16</strong>：生成多项式通常是 <code>x^16 + x^12 + x^5 + 1</code>（即 <code>11000000000000101</code>），通常可以检测到 <strong>两位比特错误</strong></li><li><strong>CRC-32</strong>：生成多项式通常是 <code>x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1</code>（即 <code>11000000000000000000000000011011</code>），能够有效检测出 <strong>两位比特错误</strong> 以及更多种类的错误</li></ul></li></ul></blockquote><hr><h2 id="3-多路访问协议"><a href="#3-多路访问协议" class="headerlink" title="3.多路访问协议"></a>3.多路访问协议</h2><p>前文中我们提到，链路有两种类型：<strong>广播</strong>和<strong>点对点</strong></p><p>点对点链路只有2个节点，不存在多节点共享信道的情况，因此不在这一节的讨论范围。我们要讨论的就是<strong>广播链路</strong>引起的<strong>共享信道问题</strong></p><p>如果一个信道由多个节点共享，那么一个问题势必出现：<strong>碰撞</strong></p><ul><li>两个或更多的并行传输会带来碰撞</li><li>一旦碰撞，没有节点可以获得有效帧，造成信道浪费</li></ul><p>于是乎，<strong>多路访问协议MAC</strong>应运而生</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p><strong>多路访问协议MAC：</strong></p><ul><li>决定节点怎样共享信道的<strong>分布式算法</strong><ul><li>如决定何时节点能够传输</li></ul></li><li>必须基于信道本身，由通信信道共享协调信息<ul><li>无带外信道用于协调</li></ul></li></ul><p>理想中的MAC协议，支持一个R bps的广播信道：</p><ul><li>效率：节点传输，可以R bps传输</li><li>公平：M个节点发送，每个有 R&#x2F;M bps</li><li>全分散：<ul><li>无特殊节点协调传输</li><li>无同步时钟、时隙</li></ul></li><li>简单</li></ul><hr><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h3><ul><li><p><strong>信道划分</strong></p><ul><li>将信道划分为较小的”段”(如：<strong>时隙</strong>，<strong>频率</strong>，<strong>编码</strong>)</li><li>为节点分配一部分专用</li><li>示例：TDMA(时隙)，FDMA(频率)，CDMA(编码)</li></ul></li><li><p><strong>随机访问</strong></p><ul><li>不划分信道，允许碰撞</li><li>从碰撞中恢复</li><li>示例：时隙ALOHA，纯ALOHA，CSMA，CSMA&#x2F;CD</li></ul></li><li><p><strong>轮流协议</strong></p><ul><li>节点轮流，无碰撞</li><li>兼顾效率和公平</li><li>单点失效、轮流时延</li></ul></li></ul><hr><h3 id="3-信道划分"><a href="#3-信道划分" class="headerlink" title="3.信道划分"></a>3.信道划分</h3><ul><li><strong>优势：在高负载时高效、公平地共享信道</strong></li><li><strong>劣势：低负载时低效：信道访问中延时，当1个活跃节点时，甚至仅有分配了 1&#x2F;N 带宽!</strong></li></ul><h4 id="1-TDMA"><a href="#1-TDMA" class="headerlink" title="1.TDMA"></a>1.TDMA</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224165217971.png" alt="image-20241224165217971"></p><h4 id="2-FDMA"><a href="#2-FDMA" class="headerlink" title="2.FDMA"></a>2.FDMA</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224165233627.png" alt="image-20241224165233627"></p><hr><h3 id="4-随机访问"><a href="#4-随机访问" class="headerlink" title="4.随机访问"></a>4.随机访问</h3><p>随机访问类型的MAC协议，在节点有分组要发送时：</p><ul><li>以信道全部速率R传输</li><li>没有事先的节点间协调</li></ul><p><strong>优势：低负载时有效：单个节点能够全面利用信道</strong></p><p><strong>劣势：高负载：碰撞开销</strong></p><h4 id="1-时隙ALOHA"><a href="#1-时隙ALOHA" class="headerlink" title="1.时隙ALOHA"></a>1.时隙ALOHA</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224165415701.png" alt="image-20241224165415701"></p><p><strong>优点：</strong></p><ul><li>单个活跃节点能够连续地以信道的全速传输</li><li>高速分散：仅节点中的时隙需要同步，检测到碰撞之后，独立决定何时重传</li><li>简单</li></ul><p><strong>缺点：</strong></p><ul><li>碰撞，浪费时隙</li><li>空闲时隙(下个时隙都不传)</li><li>时钟同步麻烦</li></ul><p>**效率：**当有许多节点，且每个都有许多帧要发送时，成功时隙与总时隙的长期比值</p><ul><li>采用时隙ALOHA协议的信道，用于有效传输的时间效率是<strong>37%</strong></li></ul><hr><h4 id="2-纯ALOHA"><a href="#2-纯ALOHA" class="headerlink" title="2.纯ALOHA"></a>2.纯ALOHA</h4><blockquote><p>纯ALOHA，即<strong>非时隙ALOHA</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224165717845.png" alt="image-20241224165717845"></p><hr><h4 id="3-CSMA"><a href="#3-CSMA" class="headerlink" title="3.CSMA"></a>3.CSMA</h4><p>CSMA协议，意思是<strong>在传输前侦听</strong></p><ul><li>如果侦听到信道空闲：传输整个帧</li><li>如果侦听到信道繁忙：<strong>推迟传输</strong></li></ul><p>但即便如此，碰撞还是会出现</p><ul><li><strong>传播时延</strong>影响了一切</li><li>传播时延的存在，意味着两个节点不能听到对方节点在传输</li></ul><p><strong>CSMA协议中，发生碰撞之后<em>不会</em>立刻停止发送</strong></p><ul><li>整个分组传输时间被浪费</li></ul><blockquote><p>有一个很有意思的东西，容易被忽视：<strong>碰撞是怎么被检测出来的？</strong></p><ul><li>一言以蔽之：<strong>A和B发生碰撞，A在没传递完分组时，收到了B的分组，就说明发生了碰撞！</strong></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224170040988.png" alt="image-20241224170040988"></p><hr><h4 id="4-CSMA-CD"><a href="#4-CSMA-CD" class="headerlink" title="4.CSMA&#x2F;CD"></a>4.CSMA&#x2F;CD</h4><blockquote><p>CSMA&#x2F;CD：带碰撞检测的载波侦听多路访问协议</p></blockquote><p><strong>CSMA&#x2F;CD：</strong></p><ul><li>载波侦听</li><li>碰撞检测<ul><li>检测到碰撞，<strong>立刻停止传输</strong></li><li>等待一段<strong>随机时间</strong>后，继续侦听<ul><li>如果侦听到信道繁忙，还要<strong>继续等待直到信道空闲</strong></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224170226584.png" alt="image-20241224170226584"></p><p><strong>1.确定等待的随机时间：</strong></p><ul><li>需要注意的是：<strong>二进制指数后退算法</strong>是有上限的，也就是图中的<strong>n&lt;&#x3D;10</strong>。如果碰撞次数大于10，<strong>都按照10来计算</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224170318733.png" alt="image-20241224170318733"></p><blockquote><p>Question:CSMA&#x2F;CD在第5次碰撞之后，选择K&#x3D;4的概率是多少？结果K&#x3D;4在10Mbps以太网上对应多少秒时延？</p><p><strong>第5次碰撞后，2^n-1&#x3D;2^5-1&#x3D;31，p(k&#x3D;4) &#x3D; 1&#x2F;32</strong></p><p><strong>总比特时间&#x3D;4*512&#x3D;2048 比特时间</strong></p><p><strong>比特时间&#x3D;1&#x2F;传输速率&#x3D;1&#x2F;10Mbps &#x3D; 10^-7 s&#x2F;bit</strong></p><p><strong>时延&#x3D;2048*10^-7&#x3D;2*10^-4&#x3D;0.2ms</strong></p></blockquote><p><strong>2.传播时延对CSMA&#x2F;CD的影响</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224170409405.png" alt="image-20241224170409405"></p><blockquote><p>Question:假设节点A和B在10Mbps的广播信道上，传播时延为325比特时间。如果传输一个帧需要576比特时间，通过CSMA&#x2F;CD是否无法检查碰撞？</p><p><strong>无法检查到碰撞！</strong></p><p><strong>传播时延&#x3D;325，2*传播时延&#x3D;650 &gt; 576, 检测到碰撞时，帧已传输完毕！</strong></p></blockquote><p><strong>3.例题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224171423901.png" alt="image-20241224171423901"></p><hr><h3 id="5-轮流协议"><a href="#5-轮流协议" class="headerlink" title="5.轮流协议"></a>5.轮流协议</h3><p>兼有信道划分和随机访问MAC协议的优点</p><h4 id="1-轮询协议"><a href="#1-轮询协议" class="headerlink" title="1.轮询协议"></a>1.轮询协议</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224171706643.png" alt="image-20241224171706643"></p><hr><h4 id="2-令牌协议"><a href="#2-令牌协议" class="headerlink" title="2.令牌协议"></a>2.令牌协议</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224171725259.png" alt="image-20241224171725259"></p><h2 id="4-以太网"><a href="#4-以太网" class="headerlink" title="4.以太网"></a>4.以太网</h2><blockquote><p>以太网标准协议：802.3</p><p><strong>以太网技术提供的是无连接的不可靠服务</strong></p></blockquote><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>以太网是目前<strong>最流行</strong>的LAN技术，市场占有率98%</p><p>以太网的网络拓扑：</p><ul><li>总线：上世纪90年代中期流行<ul><li>存储转发技术尚未发明</li></ul></li><li>星型：目前最主流<ul><li>连接选择：switch(交换机)为中心</li><li>每个节点以及相连的交换机端口使用（独立的）以太网协议（不会 和其他节点的发送产生碰撞）</li><li>使用的是<strong>存储转发交换机</strong>，解决了<strong>共享信道碰撞的问题</strong></li><li>工作在第二层(链路层)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224172529437.png" alt="image-20241224172529437"></p><p>传统的以太网(指使用集线器&#x2F;HUB的以太网)采用的是<strong>广播链路</strong>，所有连接在同一物理网络上的设备（主机、路由器、交换机等）共享一个通信信道</p><ul><li>因此，该以太网下，主机A发给主机B的帧，实际上链路上的<strong>所有节点都收到了</strong>，但<strong>只有目的节点的适配器会将帧的数据(数据报)发给网络层</strong></li></ul><hr><h3 id="2-以太网帧结构"><a href="#2-以太网帧结构" class="headerlink" title="2.以太网帧结构"></a>2.以太网帧结构</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224172935129.png" alt="image-20241224172935129"></p><ul><li><p><strong>前导码(preamble)</strong></p><ul><li><strong>8字节</strong>，<strong>不算在以太网帧的大小内</strong></li><li>模式为<code>10101010</code> 的7个字节，后跟模式为 <code>10101011</code> 的一个字节</li><li>用于同步接收方，发送方时钟速率</li></ul></li><li><p><strong>MAC地址</strong></p><ul><li><strong>6字节</strong>，目的MAC地址6字节，源MAC地址6字节</li><li>如果适配器接收具有匹配的目的地址或广播地址的帧, 它将帧中的数据提交给网络层协议</li><li>否则, 适配器丢弃帧</li></ul></li><li><p><strong>类型(type)</strong></p><ul><li><strong>2字节</strong>，指示较高层协议(如：IP&#x2F;AppleTalk&#x2F;Novell IPX)</li></ul></li><li><p><strong>数据字段(data)</strong></p><ul><li><strong>46字节到1500字节</strong>，存储IP数据报</li><li>最大长度1500字节：<strong>以太网的MTU是1500字节，超过该大小将被分片</strong></li><li>最小长度46字节：发送data&#x3D;46字节的以太网帧时，L&#x2F;R正好等于2倍传播时延。<strong>为了能够在传输结束前检测到冲突</strong>，最小长度设定在46字节。不足46字节，则末尾填充0<ul><li>该值是一个经验值，基于实际链路的传输速率和链路长度决定</li></ul></li></ul></li><li><p><strong>循环冗余校验码</strong></p><ul><li><strong>4字节</strong></li><li>检测到差错，丢弃该帧</li><li><strong>以太网技术提供的是无连接的不可靠服务</strong></li></ul></li></ul><hr><h3 id="3-802-3"><a href="#3-802-3" class="headerlink" title="3.802.3"></a>3.802.3</h3><p>实际上，虽然协议都是802.3，但是有着很多<strong>不同的以太网标准</strong></p><ul><li>相同的MAC协议(介质访问控制)和帧结构</li><li>不同的速率：2Mbps，10Mbps，100Mbps，1Gbps，10Gbps…</li><li>不同的物理层标准</li><li>不同的物理层媒介：光纤、同轴电缆、双绞线</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224173951240.png" alt="image-20241224173951240"></p><hr><h2 id="5-链路层编址"><a href="#5-链路层编址" class="headerlink" title="5.链路层编址"></a>5.链路层编址</h2><h3 id="1-IP地址与MAC地址"><a href="#1-IP地址与MAC地址" class="headerlink" title="1.IP地址与MAC地址"></a>1.IP地址与MAC地址</h3><p>每个<strong>节点</strong>的<strong>接口</strong>有<strong>网络层地址</strong>和<strong>链路层地址</strong></p><ul><li>网络层地址：节点接口在互连网络中动态分配的一个IP地址<ul><li>用于把分组送到目的IP网络</li></ul></li><li>链路层地址：MAC地址写入网卡(适配器)的ROM中<ul><li>用于把数据帧从一个节点传送到另一个节点(<strong>同一网络中</strong>)</li></ul></li></ul><blockquote><p>有一个一直没有提及的点：<strong>交换机</strong></p><p><strong>交换机不具备MAC地址，可以将之视为不存在&#x2F;透明</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224175153159.png" alt="image-20241224175153159"></p><hr><h3 id="2-MAC地址"><a href="#2-MAC地址" class="headerlink" title="2.MAC地址"></a>2.MAC地址</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224174619544.png" alt="image-20241224174619544"></p><p><strong>MAC地址：</strong></p><ul><li>6字节，每个字节用1个16进制数表示</li><li>是网卡的唯一标识，不会变化<ul><li>特殊：MAC地址&#x3D;<code>FF-FF-FF-FF-FF-FF</code>，即<strong>广播地址</strong></li></ul></li></ul><blockquote><p>是否可以只用MAC地址或IP地址？</p><ul><li>不能只用MAC地址：转发表爆了</li><li>可以只用IP地址：但是性能下降，原因是MAC地址写在网卡的ROM中，读取快速</li></ul></blockquote><hr><h3 id="3-地址转换问题"><a href="#3-地址转换问题" class="headerlink" title="3.地址转换问题"></a>3.地址转换问题</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224174926452.png" alt="image-20241224174926452"></p><ul><li><p>两台机器A和B,它们IP地址分别是IP1、 IP6 ，物理地址分别是PA和PB。</p></li><li><p>高层程序仅希望与IP地址交往，而实际通信必须使用物理地址</p><ul><li>端到端IP寻址——&gt;链路节点之间的MAC地址通信</li></ul></li></ul><p><em>如何从节点的IP地址得到它的物理地址？</em></p><hr><h2 id="6-ARP协议"><a href="#6-ARP协议" class="headerlink" title="6.ARP协议"></a>6.ARP协议</h2><blockquote><p>ARP协议，全称<strong>地址解析协议</strong></p><p>ARP协议是<strong>链路层协议</strong></p></blockquote><h3 id="1-ARP表"><a href="#1-ARP表" class="headerlink" title="1.ARP表"></a>1.ARP表</h3><p>LAN(局域网)上的每个<strong>节点</strong>(主机&#x2F;路由器)都有ARP表</p><ul><li>ARP表：对某些局域网节点的<code>IP/MAC</code>地址映射</li><li>ARP表表项：<code>&lt;IP地址；MAC地址；TTL&gt;</code><ul><li>TTL：<code>time to live</code>，该映射的寿命。通常为20分钟</li></ul></li></ul><hr><h3 id="2-ARP协议"><a href="#2-ARP协议" class="headerlink" title="2.ARP协议"></a>2.ARP协议</h3><p>ARP协议的功能在于：<strong>为同一子网上的节点解析IP地址</strong></p><ul><li>再次强调——“<strong>同一子网</strong>“</li></ul><blockquote><p><strong>情景1：主机A、B在同一子网中</strong></p><p>如果主机A的ARP表中没有B的ARP映射，但现在A需要知道B的MAC地址，获取的流程是？</p></blockquote><ul><li>首先，A<strong>广播</strong> <strong>ARP查询分组(实际是链路层帧)</strong>，包含B的IP地址<ul><li>ARP查询分组样例：<code>(IP.A，IP.B，MAC.A，MAC.Dest)</code></li><li>目的MAC地址，即<code>MAC.Dest = FF-FF-FF-FF-FF-FF</code><ul><li>该MAC地址为局域网内广播地址</li></ul></li><li>在LAN上的<strong>所有节点</strong>都会收到该ARP请求<ul><li>但是看到IP不是自己的，其他节点就会丢弃该分组</li></ul></li></ul></li><li>于是B收到了ARP查询分组，并向A<strong>单播</strong> <strong>ARP响应分组</strong><ul><li>ARP响应分组样例：<code>(IP.A，IP.B，MAC.A，MAC.B)</code></li><li>因为<strong>单播</strong>，LAN中只有A节点收到了该分组</li></ul></li><li>A在自己的ARP表中缓存了B的(IP,MAC)映射，<strong>直到超时</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224192351229.png" alt="image-20241224192351229"></p><blockquote><p><strong>情景2：主机A、B不在同一子网中</strong></p><p>如果主机A的ARP表中没有B的ARP映射，但现在A需要知道B的MAC地址，获取的流程是？</p></blockquote><ul><li>当两台主机在同一个子网，数据报可以从发送方直接交付接收方</li><li>当两台主机在不同子网<ul><li>源主机-源路由器间接交付</li><li>路由器之间间接交付</li><li>目的路由器与目的主机直接交付</li></ul></li></ul><p>与此同时，我们知道，通过IP地址的子网号可以判定是否在同一子网中。ARP协议会根据子网号判定A、B不在同一子网，因此<strong>不会广播ARP查询分组</strong>，而是向路由器发送<strong>查询MAC地址的IP数据报</strong></p><ul><li>同时还有一点值得注意：<strong>路由器会屏蔽广播的ARP查询分组，因为ARP分组是链路层帧，不是IP数据报，且不同子网不使用ARP来解析MAC</strong></li></ul><p>我们假设A的ARP表中也没有路由器的IP&#x2F;MAC映射</p><p>具体过程：</p><ul><li>第一步，主机A通过ARP询问获得路由器的MAC地址(详细步骤如上所示)</li><li>第二步，A发送帧给路由器R<ul><li><code>(MAC.A，MAC.R，IP.A，IP.B)</code></li><li>为什么帧中，目的MAC不是MAC.B？<ul><li>这就回到了链路层概念。链路层是提供了<strong>节点到节点的交付</strong>，主机A和主机B不是节点邻居，主机A和路由器R才是(忽略透明的交换机)</li></ul></li></ul></li><li>第三步，路由器R从帧中获取目的IP地址，查询转发表确定输出端口</li><li>第四步，路由器R发送帧到主机B<ul><li><code>(MAC.R，MAC.B，IP.A，IP.B)</code></li><li>这里我们假设了AB之间只有一个路由器，路径如果更复杂，还会有更多的间接交付。但无论如何交付，都要记住一点：<strong>以太网帧中，只有源MAC地址和目的MAC地址一致在变，因为链路层是节点与节点间的交付；源IP和目的IP是始终不变的(抛开NAT不谈的情况下)</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224193544996.png" alt="image-20241224193544996"></p><hr><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>地址间的转换：</p><p>主机名————&gt;IP地址————&gt;MAC地址</p><ul><li>DNS域名系统：将主机名解析到IP地址<ul><li>DNS可以为<strong>因特网中任何地方的主机</strong>解析主机名</li></ul></li><li>ARP地址解析协议：将IP地址解析到MAC地址<ul><li>ARP只为<strong>在同一LAN下的节点</strong>解析IP地址</li><li>不同子网间解析IP地址，需要<strong>间接交付</strong></li></ul></li></ul><hr><h3 id="4-细节"><a href="#4-细节" class="headerlink" title="4.细节"></a>4.细节</h3><ul><li>ARP将保存在高速缓存中的每一映射地址项目都设置生存时间，凡是超过生存时间的项目就从高速缓存中删掉</li><li>从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的</li><li>ARP 是解决同一个子网中的主机或路由器的 IP 地址和硬件地址的映射问题</li></ul><hr><h3 id="5-风险"><a href="#5-风险" class="headerlink" title="5.风险"></a>5.风险</h3><ul><li>ARP欺骗</li><li>ARP泛洪攻击</li><li>欺骗主机攻击</li><li>欺骗网关攻击</li><li>中间人攻击</li><li>…</li></ul><hr><h3 id="6-例题"><a href="#6-例题" class="headerlink" title="6.例题"></a>6.例题</h3><p>1.书P333-14</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224202253000.png" alt="image-20241224202253000"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224202523976.png" alt="image-20241224202523976"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/54a22996137d5a803bf2664afd3aa77.jpg" alt="54a22996137d5a803bf2664afd3aa77"></p><p>2.书P333-15</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241224194752038.png" alt="image-20241224194752038"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/aebf13240b741e8282074dbe2435b6e.jpg" alt="aebf13240b741e8282074dbe2435b6e"></p><p>这道例题提到了一个一直被忽视的点：<strong>交换机的转发表</strong></p><h2 id="7-交换机"><a href="#7-交换机" class="headerlink" title="7.交换机"></a>7.交换机</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><p>交换机的任务是接收<strong>入链路层</strong>的帧，并将它们转发到<strong>出链路</strong>。</p><p>交换机对于子网中的主机和路由器来说是<strong>透明</strong>的！</p><ul><li>过滤：决定一个帧是应该转发到某个接口还是丢弃！</li><li>转发：决定帧应该被导向哪个接口。</li></ul><p>特色：即插即用，自学习</p><h4 id="2-交换机表"><a href="#2-交换机表" class="headerlink" title="2.交换机表"></a>2.交换机表</h4><p>交换机的转发表通常包含以下几部分内容：</p><ul><li><strong>MAC地址</strong>：每个连接到交换机的设备的物理地址（即网卡的MAC地址）</li><li><strong>端口号</strong>：交换机上对应的端口号，表示该MAC地址所在的设备通过哪个端口连接到交换机</li><li><strong>时间戳</strong>：记录该条目被添加到转发表中的时间，帮助交换机决定是否清除过期的条目。</li></ul><hr><h4 id="2-转发-过滤"><a href="#2-转发-过滤" class="headerlink" title="2.转发&#x2F;过滤"></a>2.转发&#x2F;过滤</h4><p>当交换机接收到一个数据帧时，它会检查帧的目标MAC地址，然后查看转发表中是否有该MAC地址的映射。</p><ul><li>如果找到了对应的端口，交换机会将数据帧转发到该端口<ul><li><strong>如果表中对应的端口&#x3D;接收端口，则过滤该帧</strong>（很重要！！！）</li></ul></li><li>如果没有找到，交换机会进行广播，将帧发送到所有其他端口（除了接收端口）</li></ul><p>如果目标MAC地址就是广播地址<code>FF-FF-FF-FF-FF-FF</code>呢？</p><ul><li>交换机会直接进行广播，将帧发送到所有其他端口（除了接收端口，避免重复发送）</li></ul><hr><h4 id="3-转发表更新"><a href="#3-转发表更新" class="headerlink" title="3.转发表更新"></a>3.转发表更新</h4><p>交换机的转发表是动态更新的，它会根据接收到的数据帧来更新。当交换机收到数据帧时，它会检查数据帧的源MAC地址，并记录下源MAC地址与接收到该帧的端口之间的映射关系。具体更新过程如下：</p><ul><li><strong>接收数据帧</strong>：交换机接收到数据帧后，会提取源MAC地址和目标MAC地址。</li><li><strong>记录源MAC地址和端口号</strong>：交换机会将源MAC地址和接收到该帧的端口号存储到转发表中。<ul><li>如果该MAC地址已经存在于转发表中，交换机会更新该条目，以确保源MAC地址与最新端口映射保持一致。</li><li>如果该MAC地址不存在于转发表中，交换机会新增一条映射记录。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记-网络层(控制平面)</title>
      <link href="/2024/12/23/ji-wang-xue-xi-bi-ji-wang-luo-ceng-kong-zhi-ping-mian/"/>
      <url>/2024/12/23/ji-wang-xue-xi-bi-ji-wang-luo-ceng-kong-zhi-ping-mian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="第五章-网络层-控制平面"><a href="#第五章-网络层-控制平面" class="headerlink" title="第五章 网络层:控制平面"></a>第五章 网络层:控制平面</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>首先，我们回顾一下<strong>网络层的2个功能：</strong></p><ul><li><strong>转发</strong><ul><li><strong>数据平面实现</strong></li><li>将分组从路由器的一个输入端口移到合适的输出端口</li></ul></li><li><strong>路由</strong><ul><li><strong>控制平面实现</strong></li><li>确定分组从源到目标的路径</li></ul></li></ul><p>其次，我们回顾一下<strong>构建网络控制平面功能的2种方法：</strong></p><ul><li><strong>传统方式</strong><ul><li>每个路由器单独控制自己的功能实现</li><li>分布式</li></ul></li><li><strong>SDN方式(software defined networking)</strong><ul><li>一个远程控制器与本地控制代理交互</li><li>逻辑上集中式</li></ul></li></ul><p>本章节就是介绍控制平面的内容，<strong>主要介绍的是传统方式及相关协议</strong></p><hr><h2 id="2-路由选择算法"><a href="#2-路由选择算法" class="headerlink" title="2.路由选择算法"></a>2.路由选择算法</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><h4 id="1-路由-route-概念"><a href="#1-路由-route-概念" class="headerlink" title="1.路由(route)概念"></a>1.路由(route)概念</h4><ul><li><p><strong>路由</strong></p><ul><li>按照某种指标(传输延迟&#x2F;经过的站点数目&#x2F;…)找到一条从源节点到目标节点的<strong>较好路径</strong>(不要求最好，寻找最好的代价太高)</li></ul></li><li><p>以<strong>网络</strong>为单位进行路由</p><ul><li>以网络为单位进行路由时，路由信息传输、计算和匹配的代价低</li></ul></li><li><p><strong>默认路由器</strong></p><ul><li>与主机直接相连的路由器称为<strong>默认路由器</strong></li><li>源主机的默认路由器-源路由器</li><li>目的主机的默认路由器-目的路由器</li></ul></li><li><p>网络到网络的路由&#x3D;&#x3D;路由器到路由器之间的路由</p><ul><li>网络内部中，路由器与主机间的通信，<strong>链路层解决</strong></li><li>因此，到达该网络的路由器就等同于到达该网络</li></ul></li><li><p><strong>路由选择算法</strong></p><ul><li>网络层软件的一部分，完成路由功能</li></ul></li></ul><hr><h4 id="2-选路算法图抽象"><a href="#2-选路算法图抽象" class="headerlink" title="2.选路算法图抽象"></a>2.选路算法图抽象</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241218213616171.png" alt="image-20241218213616171"></p><ul><li>图中的节点是路由器</li><li>图中的边是物理链路</li><li>链路代价时延&#x2F;带宽倒数&#x2F;费用&#x2F;拥塞等级&#x2F;…</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241218213754963.png" alt="image-20241218213754963"></p><ul><li><strong>好的路径</strong>通常意味着最小费用的路径</li></ul><hr><h4 id="3-选路算法原则"><a href="#3-选路算法原则" class="headerlink" title="3.选路算法原则"></a>3.选路算法原则</h4><ul><li>正确性</li><li>简单性</li><li>健壮性：适应通信量和网络拓扑的变化</li><li>稳定性</li><li>公平性</li><li>最优性：某个指标上的最优(实际情况下较优即可)</li></ul><hr><h4 id="4-选路算法分类"><a href="#4-选路算法分类" class="headerlink" title="4.选路算法分类"></a>4.选路算法分类</h4><p>选路算法的分类方式有两种。</p><p><strong>全局信息or分散信息(局部信息)：即路由器获得的是全局信息还是局部</strong></p><ul><li>全局信息<ul><li><strong>所有</strong>的路由器拥有<strong>完整的拓扑、链路代价信息</strong></li><li>代表：<strong>链路状态(LS)算法</strong></li></ul></li><li>分散信息<ul><li>一开始，路由器<strong>仅知道与其<em>直接相连</em>的链路的代价信息</strong></li><li>迭代地与邻居交换路由信息</li><li>代表：<strong>距离矢量(DV)算法</strong></li></ul></li></ul><p><strong>静态or动态：即路由是静态不变的还是动态变化的</strong></p><ul><li>静态<ul><li>路由随时间缓慢变化</li><li>手工配置</li></ul></li><li>动态<ul><li>路由变化更快<ul><li>周期性更新</li><li>根据链路代价与网络拓扑而变化</li></ul></li></ul></li></ul><blockquote><p>因特网路由选择算法是<strong>负载迟钝</strong>的，链路开销<strong>不会反映</strong>当前拥塞水平</p></blockquote><hr><h3 id="2-LS算法"><a href="#2-LS算法" class="headerlink" title="2.LS算法"></a>2.LS算法</h3><blockquote><p>LS算法，全名Link State，即<strong>链路状态</strong>路由选择算法</p></blockquote><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p><strong>LS算法</strong>本质上是采用了<strong>Dijkstra算法</strong></p><p>我们都知道，Dijkstra是需要知道所有边代价的，那么LS算法如何实现？</p><ul><li>所有节点知道网络拓扑、链路费用<ul><li>经<strong>链路状态广播</strong>完成</li><li>所有节点拥有相同的信息</li></ul></li><li>从一个节点(源)到所有其他节点计算最低的费用路径<ul><li>给出对这些节点的<strong>转发表</strong></li></ul></li><li>**迭代：**k次迭代后，得知到k个目的地的最低费用路径</li></ul><p><strong>约定的参数标识：</strong></p><ul><li>$C(x, y)$：从节点x到y的链路费用<ul><li>如果x，y不是直接邻居，$C(x, y) &#x3D; \infty$</li></ul></li><li>$D(v)$：从<strong>源到目的地v</strong>的路径的费用的<strong>当前值</strong><ul><li>源是一开始就定好的</li></ul></li><li>$p(v)$：从源到目的地v的路径的<strong>前任节点</strong><ul><li>比如x-&gt;y-&gt;z-&gt;t-&gt;v，x是源，那么t就是x到v路径的前任节点</li></ul></li><li>$N^{‘}$：已知最小费用路径中的节点集合</li></ul><hr><h4 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241219151626291.png" alt="image-20241219151626291"></p><hr><h4 id="3-过程"><a href="#3-过程" class="headerlink" title="3.过程"></a>3.过程</h4><ul><li>第一步：发现邻接节点</li><li>第二步：测量链路成本</li><li>第三步：封装链路状态包</li><li>第四步：广播链路状态信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241219152139431.png" alt="image-20241219152139431"></p><hr><h4 id="4-讨论"><a href="#4-讨论" class="headerlink" title="4.讨论"></a>4.讨论</h4><ul><li>算法复杂性<ul><li>n个节点，每次迭代检查不在N’中的所有节点w</li><li>(n+1)*n&#x2F;2——O(n^2)</li><li>更有效的实现可以做到O(nlogn)</li></ul></li><li><strong>路由震荡</strong><ul><li>路由随着链路成本的变化而来回切换</li></ul></li></ul><hr><h4 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h4><p>1.根据下图，给出以u为源的<strong>最短路径树</strong>和<strong>最终转发表</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/ae25db37ace2f24eed9dab9f663283f.jpg" alt="ae25db37ace2f24eed9dab9f663283f"></p><p>推算$N^{‘}$时需要注意，<strong>每次因为w被添加入N’而更新D(v)时，v一定是w的直接邻居</strong></p><ul><li>就比如上述推算过程中，x添加到N’，只能更新D(y)，D(z)是不动的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241219154359742.png" alt="image-20241219154359742"></p><p><strong>最短路径树</strong>和<strong>转发表</strong>如上图所示</p><ul><li>需要非常注意的是，<strong>转发表记录的是下一跳</strong>，因此即便目的地是z，u的转发表中也是将数据包转发给x。</li></ul><p>2.书P279 Problem3</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/7fac65e4f5984b93816b01810fa509e.jpg" alt="7fac65e4f5984b93816b01810fa509e"></p><hr><h3 id="3-DV算法"><a href="#3-DV算法" class="headerlink" title="3.DV算法"></a>3.DV算法</h3><blockquote><p>DV算法，全称Distance Vector，即<strong>距离矢量</strong>算法</p><ul><li>DV算法适用于<strong>小型网络</strong>，现在已基本不使用了</li></ul></blockquote><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h4><p>DV算法，是一种<strong>分布式、迭代、异步算法</strong></p><p><strong>约定的参数标识：</strong></p><ul><li>$d_{x}(y)$：从x到y的最”短”路径(最低费用)的费用</li><li>$C(x, y)$：从x到<strong>直接邻居</strong>y的费用</li><li>$D_{x}(y)$：从x到y的最小费用的<strong>估计</strong><ul><li>$D_{x} &#x3D; [D_{x}(y): y \in N]$：节点x维护自己的距离矢量(DV)<ul><li>此处N指所有节点</li></ul></li></ul></li><li>$min_{v}{…}$：对于x所有的直接邻居v的某个参数取最小值<ul><li>上述的解释是没法单独看懂的，需要结合下面的内容</li></ul></li></ul><p><strong>DV算法</strong>是基于<strong>Bellman-Ford方程</strong>的</p><p><strong>Bellman-Ford方程：</strong></p><p>$$d_{x}(y) &#x3D; min_{v}{C(x, y) + d_{v}(y)}$$</p><ul><li>其中，$min_{v}$指的是对于x的所有直接邻居v，取$C(x, y) + d_{v}(y)$的最小值</li></ul><hr><h4 id="2-算法-1"><a href="#2-算法-1" class="headerlink" title="2.算法"></a>2.算法</h4><p><strong>基本思想</strong></p><ul><li><p>每个节点周期性的发送它自己维护的<strong>距离矢量(DV)<strong>给</strong>直接邻居</strong></p><ul><li>只给直接邻居，不给间接邻居——不做洪泛广播</li></ul></li><li><p>当节点x接收到来自邻居的新DV<strong>估计</strong>，它使用B-F方程更新自己维护的DV</p><ul><li><p>$D_{x}(y) \leftarrow min_{v}{C(x, v) + D_{v}(y)} \quad for each node \quad y \in N$</p></li><li><p>这里需要注意，<strong>DV算法</strong>计算的都是<strong>最小费用估计</strong>而不是<strong>最小费用</strong>，因此是用大写D而不是小写d</p></li></ul></li><li><p>在规模较小、正常的条件下，估计值$D_{x}(y)$收敛在实际最小费用$d_{x}(y)$</p></li></ul><hr><h4 id="3-过程-1"><a href="#3-过程-1" class="headerlink" title="3.过程"></a>3.过程</h4><p>首先，要搞清楚，每个节点维护的DV表是什么样的</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241219162758554.png" alt="image-20241219162758554"></p><ul><li><p>DV表保存的是<strong>节点自身以及直接邻居</strong>的DV</p></li><li><p>DV表的行，是<strong>节点自身以及直接邻居</strong></p><ul><li>所以可以把DV表分为：<strong>自身节点DV</strong>和<strong>邻居节点DV</strong></li></ul></li><li><p>DV表的列，是<strong>网络的所有节点</strong></p></li></ul><p>DV算法的过程：</p><ul><li><p>第一步：初始化DV</p><ul><li>邻居节点DV设为空(每项都是无穷)</li><li>计算自身节点DV(只有直接邻居不是无穷)</li></ul></li><li><p>第二步：等待</p><ul><li>等待自身与直接邻居的链路费用变化</li><li>等待收到邻居的DV更新</li></ul></li><li><p>第三步：重新计算</p><ul><li>根据邻居发来的DV&#x2F;链路变化<strong>更新自身节点DV</strong></li><li>更新DV表中的邻居节点DV</li></ul></li><li><p>第四步：通知邻居</p><ul><li>如果DV表中<strong>自身节点DV</strong>变化，通知<strong>直接邻居</strong></li><li>反之则不通知</li></ul></li><li><p>第五步：返回第二步，等待，<strong>持续迭代，直至稳定</strong></p></li></ul><hr><h4 id="4-讨论-1"><a href="#4-讨论-1" class="headerlink" title="4.讨论"></a>4.讨论</h4><h5 id="无穷计算问题"><a href="#无穷计算问题" class="headerlink" title="无穷计算问题"></a><strong>无穷计算问题</strong></h5><ul><li>DV算法的最大弊端在于，好消息传播的快，坏消息反应迟钝</li><li>具体来说就是，如果链路代价降低，这条信息会<strong>快速迭代</strong><ul><li><strong>迭代次数最多为网络直径</strong></li></ul></li><li>如果链路代价提高，这条消息会<strong>无穷迭代</strong><ul><li>迭代无穷，<strong>难以收敛</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241222210831371.png" alt="image-20241222210831371"></p><p>从上述图中即可看到，$D_{y}(x)$因为$C(x, y)$从4变成60，经过B-F方程迭代成了$C(y, z) + D_{z}(x)$，即5+1&#x3D;6；但实际上，$D_{z}(x)$是原来的z-y-x路径产生的，现在的$D_{y}(x)$实际上的路径变成了y-z-y-x，形成了事实上的<strong>路由环路</strong>，这就出现了<strong>无穷计算问题</strong>。</p><p>上图中，由于$C(x, y)$还只是60，所以迭代44次即可。但是，如果$C(x, y) &#x3D; \infty$呢？那就是货真价实的<strong>无穷迭代</strong>了</p><ul><li>44次怎么来的？<ul><li>只要$D_{z}(x)$在重复迭代的过程中超过了$C(x, z)&#x3D;50$就会稳定下来，而$D_{y}(x)$也会在下一迭代中稳定</li><li>迭代多少次，$D_{z}(x)$会等于50呢？50&#x2F;2 - 3 &#x3D; 22</li><li>$D_{z}(x)$每变化一次，迭代2次。故迭代次数&#x3D;22*2&#x3D;44</li></ul></li></ul><blockquote><p>如何解决无穷计算问题？或者退而求其次，如何缓解无穷计算问题？</p></blockquote><h5 id="毒性逆转"><a href="#毒性逆转" class="headerlink" title="毒性逆转"></a><strong>毒性逆转</strong></h5><p>归根到底，无穷计算的问题在于，节点B因A,B间代价提高而选择走节点C时，节点C到A的最短路径实际上是通过节点B的。也就是，<strong>更新节点的路径时，确保节点之前不存在于新路径中</strong></p><p>如何做到呢？</p><p>假设，节点Z到节点X的路径是：Z-&gt;Y-&gt;X，那么，Z就会告诉Y，$D_{z}(x)&#x3D;\infty$</p><ul><li>这样一来，$C(x, y)$无穷时，Y也不会通过Z走向X，因为从Y的视角来看，走Z也是死路！</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241222212438150.png" alt="image-20241222212438150"></p><blockquote><p>但是，毒性逆转并不能解决无穷计算问题。</p><p>毒性逆转是为了<strong>防止两个节点间通过错误的链路形成环路</strong>，但它在涉及<strong>三个或更多节点</strong>时，可能会面临“局限性”。在多节点或多路径的拓扑下，毒性逆转无法确保整个网络的收敛，因为它只对直接邻居生效，而<strong>无法阻止跨越多跳链路的错误路由信息传播</strong>。</p></blockquote><h5 id="最大度量"><a href="#最大度量" class="headerlink" title="最大度量"></a>最大度量</h5><p>那么，怎么去尽可能降低DV算法出错的风险？</p><ul><li>定义<strong>最大度量</strong><ul><li>即定义一个最大的有效费用值</li><li>如<strong>RIP协议</strong>定义最大跳数是15跳，16跳步表示$\infty$</li></ul></li></ul><p><strong>但这样就限制了DV算法的使用</strong></p><ul><li>DV算法因此只能在<strong>小规模网络中使用</strong></li></ul><hr><h4 id="5-例题-1"><a href="#5-例题-1" class="headerlink" title="5.例题"></a>5.例题</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241222213304493.png" alt="image-20241222213304493"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241222213314965.png" alt="image-20241222213314965"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/5ccdad7573e267c09357f258f3399f1.jpg" alt="5ccdad7573e267c09357f258f3399f1"></p><hr><h3 id="4-比较"><a href="#4-比较" class="headerlink" title="4.比较"></a>4.比较</h3><ul><li>报文复杂性(DV胜出)<ul><li>LS：对n个节点，E条链路，发送O(nE)报文</li><li>DV：仅在邻居间交换</li></ul></li><li>收敛速度(LS胜出)<ul><li>LS：O(n^2)<ul><li>可能具有振荡</li></ul></li><li>DV：收敛时间变化<ul><li>可能有选路环路，计数到无穷问题</li></ul></li></ul></li><li>健壮性(如果路由器异常会如何)(LS胜出)<ul><li>LS：<ul><li>节点可能通告不正确的<strong>链路</strong>费用</li><li>每个节点仅计算它自己的表</li></ul></li><li>DV：<ul><li>DV节点通告不正确的<strong>路径</strong>费用</li><li>每个节点表能由他人使用</li></ul></li></ul></li></ul><p>从整体上看，LS算法适用于大规模网络，DV算法适用于小规模网络</p><hr><h2 id="3-自治系统"><a href="#3-自治系统" class="headerlink" title="3.自治系统"></a>3.自治系统</h2><blockquote><p>至此以来，我们对路由选择的研究都是理想的，我们认为：</p><ul><li>所有的路由器是等同</li><li>网络”扁平”，互联路由器的集合</li></ul><p>但这在实践中<strong>并不现实</strong></p><ul><li><p>网络具有上亿个路由目的，选路表中不能存储所有的目的地</p></li><li><p>因此，<strong>每个ISP要控制自己网络中的选路</strong></p></li><li><p>我们常说的**”互联网”**，本质含义就是：<strong>网络的网络</strong></p></li></ul></blockquote><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h3><p>出于<strong>管理</strong>和<strong>扩展</strong>的目的，因特网可以被分割成许多不同的<strong>自治系统(AS)</strong></p><ul><li><strong>自治系统</strong>是指在互联网中，一个或多个实体管辖下的所有IP网络和路由器的组合<ul><li>在课程学习中，我们通常可以认为<strong>自治系统是路由器的组合</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241222220134536.png" alt="image-20241222220134536"></p><ul><li>同一AS内的路由器运行<strong>相同的路由协议(算法)</strong><ul><li>自治系统内的选路协议(包括RIP，OSPF等)</li><li>不同AS内的路由器可以运行不同的选路协议</li></ul></li><li><strong>网关路由器</strong><ul><li>位于AS”边缘”</li><li>通过链路连接其他AS的网关路由器</li><li>AS之间运行着相同的自治系统间选路协议(BGP协议)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241222220152939.png" alt="image-20241222220152939"></p><hr><h3 id="2-选路协议"><a href="#2-选路协议" class="headerlink" title="2.选路协议"></a>2.选路协议</h3><p>互联网采用<strong>层次路由</strong></p><ul><li><p><strong>IGP</strong>：自治系统内部路由协议，简称<strong>内部网关协议</strong></p><ul><li><strong>路由信息协议RIP</strong>——使用DV算法</li><li><strong>开放最短路径优先OSPF</strong>——使用LS算法</li><li><strong>中间系统到中间系统IS-IS</strong>——使用LS算法</li></ul></li><li><p><strong>EGP</strong>：自治系统间接口上的路由协议，简称<strong>外部网关协议</strong></p><ul><li><strong>边界网关协议BGP-4</strong></li></ul></li></ul><hr><h2 id="4-IGP之RIP协议"><a href="#4-IGP之RIP协议" class="headerlink" title="4.IGP之RIP协议"></a>4.IGP之RIP协议</h2><blockquote><p>RIP协议，全称<strong>选路信息协议</strong>，属于IGP协议，即内部网关协议</p><p>RIP协议现已弃用</p><p>RIP协议是<strong>应用层协议</strong></p></blockquote><h3 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1.概念"></a>1.概念</h3><p>RIP协议是一种<strong>分布式</strong>的基于<strong>DV算法</strong>的路由选择协议</p><ul><li>距离度量：跳的数量(最大&#x3D;15跳)</li><li>跳：从源路由器到目的子网的最短路径所经过的子网数量</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241222221037342.png" alt="image-20241222221037342"></p><p><strong>使用RIP协议的路由：</strong></p><ul><li><strong>仅和相邻路由器</strong>交换路由选择信息<ul><li>路由选择信息包括：<strong>目的子网、下一跳路由器、跳数</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223164023849.png" alt="image-20241223164023849"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241222221210061.png" alt="image-20241222221210061"></p><ul><li><p>按<strong>固定的时间间隔</strong>交换路由信息(RIP响应报文&#x2F;RIP通告)</p></li><li><p>每次通告：<strong>最多25个目的子网(IP形式)</strong></p></li><li><p>如果<strong>180秒</strong>没有收到通告——&gt;<strong>邻居&#x2F;链路失效</strong></p></li></ul><hr><h3 id="2-RIP-DV"><a href="#2-RIP-DV" class="headerlink" title="2.RIP-DV"></a>2.RIP-DV</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223164142400.png" alt="image-20241223164142400"></p><hr><h3 id="3-RIP表处理"><a href="#3-RIP表处理" class="headerlink" title="3.RIP表处理"></a>3.RIP表处理</h3><ul><li><strong>RIP选路表</strong>由<code>route-d(守护进程)</code>的<strong>应用级进程</strong>管理</li><li><strong>RIP通告&#x2F;报文</strong>在<strong>UDP分组</strong>中发送，周期性重复</li></ul><p>因此，<strong>RIP协议</strong>是<strong>应用层协议</strong></p><hr><h3 id="4-RIP协议优缺点"><a href="#4-RIP协议优缺点" class="headerlink" title="4.RIP协议优缺点"></a>4.RIP协议优缺点</h3><p><strong>优点：</strong></p><ul><li>实现简单，开销较小</li></ul><p><strong>缺点：</strong></p><ul><li>RIP限制了网络的规模，能使用的最大距离是15(16表示不可达)</li><li><strong>使用RIP协议的</strong>路由器之间交换的路由信息是<strong>路由器中的完整路由表</strong>，因此随着网络规模的扩大，开销随之增加</li><li>当<strong>网络出现故障</strong>时，要<strong>经过比较长的时间</strong>才能将此信息传送到所有路由器<ul><li>无穷计算问题</li></ul></li></ul><hr><h3 id="5-例题-2"><a href="#5-例题-2" class="headerlink" title="5.例题"></a>5.例题</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223164725466.png" alt="image-20241223164725466"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/060cf4a0a316153ace9f398cc55d333.jpg" alt="060cf4a0a316153ace9f398cc55d333"></p><hr><h2 id="5-IGP之OSPF协议"><a href="#5-IGP之OSPF协议" class="headerlink" title="5.IGP之OSPF协议"></a>5.IGP之OSPF协议</h2><blockquote><p>OSPF协议，全称<strong>开放最短路径优先协议</strong>，是IGP协议中应用最广、性能最好的协议</p><p>OSPF协议是<strong>运输层协议</strong></p></blockquote><h3 id="1-概念-3"><a href="#1-概念-3" class="headerlink" title="1.概念"></a>1.概念</h3><p><strong>OSPF协议</strong>使用了<strong>链路状态LS算法</strong>作为选路算法</p><ul><li><p>LS分组扩散通告**(泛洪)**</p></li><li><p>每个路由器构造完整的网络(指的是<strong>AS</strong>)拓扑图</p></li><li><p>利用<strong>Dijkstra算法</strong>计算路由</p><ul><li>实际上，在实际应用中，我们却是反过来的：先确定路由，再设置cost</li></ul></li></ul><p><strong>OSPF协议</strong>可适应大规模网络——<strong>层次OSPF</strong></p><p><strong>OSPF协议</strong>的路由变化收敛速度快</p><p><strong>OSPF协议</strong>还具有如下特征：</p><ul><li>支持路由等级划分</li><li>支持组播</li><li>支持验证</li><li>支持(多路径)等值路由</li></ul><p><strong>OSPF协议</strong>是运输层协议，<strong>报文封装在IP中</strong></p><hr><h3 id="2-工作"><a href="#2-工作" class="headerlink" title="2.工作"></a>2.工作</h3><ul><li>每个路由器通过<code>&quot;HELLO&quot;</code>报文与邻居节点<strong>形成和维持</strong>邻居关系</li><li>路由器节点在与邻居的交互中掌握了本区域网络拓扑，使用Dijkstra算法完成本节点的路由计算</li><li>邻居或链路状态发生变化时，将信息<strong>通过洪泛散布</strong>到整个区域</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223200214321.png" alt="image-20241223200214321"></p><hr><h3 id="3-层次OSPF"><a href="#3-层次OSPF" class="headerlink" title="3.层次OSPF"></a>3.层次OSPF</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223200709321.png" alt="image-20241223200709321"></p><p><strong>AS</strong>由多个<strong>区域area</strong>组成，每个区域运行自己的<strong>OSPF路由选择算法</strong></p><p><strong>AS的区域area</strong>有<strong>两级层次</strong>：<strong>本地</strong>和<strong>主干</strong></p><ul><li><p><strong>主干区域</strong>包含区域边界路由器，为AS内其他区域之间提供路由</p></li><li><p><strong>本地区域</strong>：</p><ul><li><p>链路状态通告<strong>仅在本地内</strong></p></li><li><p>每个节点具有详细的<strong>区域</strong>拓扑</p></li><li><p>每个节点仅知道<strong>到达其他区域网络的方向(最短路)，也就是下一跳</strong></p></li></ul></li></ul><p><strong>AS</strong>内部具有多种路由器：</p><ul><li><strong>区域边界路由器(area border router)</strong><ul><li>负责为流向区域以外的分组提供路径选择</li></ul></li><li><strong>主干路由器(backbone router)</strong><ul><li>运行OSPF选路限制到主干</li><li>本质上，就是提供区域与区域之间的OSPF选路</li></ul></li><li><strong>边界路由器(boundary router)</strong><ul><li>连接到其他AS</li><li>就是我们通常说的<strong>网关路由器</strong></li></ul></li></ul><hr><h2 id="6-EGP之BGP协议"><a href="#6-EGP之BGP协议" class="headerlink" title="6.EGP之BGP协议"></a>6.EGP之BGP协议</h2><blockquote><p>BGP协议，全称<strong>边界网关协议</strong>，属于EGP协议(AS间路由协议)</p><p>BGP协议是<strong>应用层协议</strong></p></blockquote><p><strong>BGP</strong>为每个<strong>AS</strong>提供了一种手段：</p><ul><li>从<strong>相邻AS</strong>获得<strong>子网可达性</strong>信息</li><li>向<strong>AS</strong>内部的所有路由器传播可达性信息</li><li>基于可达性信息和<strong>策略</strong>，决定到子网的”好路由”<ul><li>基于<strong>策略</strong>，也就是说，<strong>不一定是按照代价来决定了</strong></li></ul></li></ul><p><strong>BGP</strong>实际上允许了一个子网向因特网其他部分通告<em>我在这里</em></p><hr><h3 id="1-概念-4"><a href="#1-概念-4" class="headerlink" title="1.概念"></a>1.概念</h3><p>路由器通过<strong>TCP连接：BGP会话(iBGP和eBGP)<strong>来分发路由信息(即</strong>子网&#x2F;子网集合可达信息</strong>)</p><ul><li>对于每条连接，位于该连接端点的两台路由器称为<strong>BGP对等方</strong></li></ul><p><strong>注意：BGP会话不对应着物理链路</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223204054042.png" alt="image-20241223204054042"></p><hr><h3 id="2-分发可达性信息"><a href="#2-分发可达性信息" class="headerlink" title="2.分发可达性信息"></a>2.分发可达性信息</h3><blockquote><p>首先需要提醒一点，AS是IP网络与路由器的集合，不等于子网</p></blockquote><p>分发可达性信息的过程是怎样的？我们以下图为例</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223204301063.png" alt="image-20241223204301063"></p><p>假设3b路由器所在区域有4个子网，子网集合可以表示为<code>138.16.64.0/22</code></p><ul><li><p>在3a路由器与1c路由器之间有<strong>eBGP会话</strong>，AS3向AS1发送<strong>前缀可达性信息</strong></p><ul><li>前缀：指一个子网&#x2F;子网集合，因为子网号可以视为IP地址的前缀</li></ul></li><li><p>1c路由器则使用<strong>iBGP会话</strong>向<strong>AS1内</strong>的所有路由器分发这个新前缀的可达信息</p></li><li><p>当路由器知道了一个新前缀，它将在其转发表中为该前缀创建一个新表项</p></li></ul><hr><h3 id="3-路径属性-BGP路径"><a href="#3-路径属性-BGP路径" class="headerlink" title="3.路径属性&amp;BGP路径"></a>3.路径属性&amp;BGP路径</h3><p>在<strong>eBGP会话</strong>和<strong>iBGP会话</strong>中，当通告一个前缀(即一个可达子网)时，通告中包含了<strong>BGP属性</strong></p><ul><li><strong>前缀</strong> + <strong>属性</strong> &#x3D; “<strong>路由</strong>“</li></ul><p><strong>两个重要属性：</strong></p><ul><li><strong>AS-PATH</strong>：包含了传递前缀的通告所经过的AS<ul><li>AS2向AS1通告到前缀x的AS-PATH：AS2</li><li>AS1向AS3通告到前缀x的AS-PATH：AS2，AS1</li><li>目的是<strong>防止循环通告</strong></li></ul></li><li><strong>下一跳</strong>：下一跳路由器的<strong>IP地址</strong><ul><li>方便<strong>路由器配置转发表</strong></li></ul></li></ul><p><strong>注意：<strong>当网关路由器接收了路由通告，使用</strong>输入策略</strong>来接受&#x2F;拒绝(<strong>不广播通告</strong>)</p><hr><h3 id="4-基于策略通告信息"><a href="#4-基于策略通告信息" class="headerlink" title="4.基于策略通告信息"></a>4.基于策略通告信息</h3><p><strong>BGP协议</strong>实际上是基于<strong>策略</strong>来通告前缀可达信息的。举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223205519220.png" alt="image-20241223205519220"></p><hr><h3 id="5-BGP路径选择"><a href="#5-BGP路径选择" class="headerlink" title="5.BGP路径选择"></a>5.BGP路径选择</h3><p>因为路由器对某些前缀可能找到<strong>多于1条路由</strong>，所以<strong>路由器必须选择路由</strong></p><p><strong>BGP路由选择</strong>：<strong>策略决定</strong></p><ul><li>最短AS-PATH</li><li>热土豆选路(选择下一跳路由器)</li><li>各种过滤(IP地址，接口，属性…)</li></ul><p>在课程学习中，我们认为，<strong>BGP路由选择遵循以下逻辑：</strong></p><ul><li>选<strong>AS-PATH</strong>最短</li><li><strong>AS-PATH</strong>相同，使用<strong>热土豆选路</strong></li></ul><h4 id="1-热土豆选路"><a href="#1-热土豆选路" class="headerlink" title="1.热土豆选路"></a>1.热土豆选路</h4><p>热土豆路由选择算法可以用一句话总结：</p><ul><li>选择<strong>具有到达目的前缀(子网)的最低费用的网关路由器</strong><ul><li>最低费用的计算，是使用<strong>AS内部路由协议</strong>(IGP)计算出的<strong>目的子网到网关的最低费用</strong></li><li>费用：有cost算cost，无cost算跳数</li></ul></li></ul><hr><h3 id="6-比较"><a href="#6-比较" class="headerlink" title="6.比较"></a>6.比较</h3><p><strong>AS内选路</strong>和<strong>AS间选路</strong>的不同：</p><ul><li><p>策略</p><ul><li>AS间：<strong>管理员希望控制它的流量选路的方式</strong>，决定谁能通过它的网络路由<ul><li>就比如，电信走电信的路由，而不走移动的</li><li>更多的是考虑到现实因素</li></ul></li><li>AS内：单个管理员，因此<strong>不需要策略决定</strong></li></ul></li><li><p>性能</p><ul><li>AS间：<strong>策略比性能更重要</strong></li><li>AS内：<strong>性能更重要</strong></li></ul></li></ul><hr><h3 id="7-例题"><a href="#7-例题" class="headerlink" title="7.例题"></a>7.例题</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/e1ca9cfdb65cdb1ed23b57ec382934f.jpg" alt="e1ca9cfdb65cdb1ed23b57ec382934f"></p><hr><h2 id="7-ICMP协议"><a href="#7-ICMP协议" class="headerlink" title="7.ICMP协议"></a>7.ICMP协议</h2><blockquote><p>ICMP协议，全称<strong>互联网控制报文协议</strong></p><p>ICMP协议是<strong>网络层协议</strong>，本质上是IP协议的扩展</p></blockquote><h3 id="1-概念-5"><a href="#1-概念-5" class="headerlink" title="1.概念"></a>1.概念</h3><p>**出现的原因：<strong>IP网络是</strong>尽力而为(不可靠)**的</p><p><strong>功能：<strong>ICMP协议通过</strong>差错报文</strong>和<strong>询问报文</strong>来辅助IP网络的功能</p><p><strong>具体：</strong></p><ul><li><p>由主机和路由器用于网络级信息的通信</p><ul><li><strong>差错报告</strong>：不可达主机、网络、端口、协议</li><li><strong>网络探寻</strong>：回声请求&#x2F;回答(由<code>ping</code>使用)</li></ul></li><li><p>与IP的关系</p><ul><li><strong>ICMP报文作为IP的有效载荷</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223211504911.png" alt="image-20241223211504911"></p><hr><h3 id="2-常见编码"><a href="#2-常见编码" class="headerlink" title="2.常见编码"></a>2.常见编码</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223211532377.png" alt="image-20241223211532377"></p><hr><h3 id="3-Traceroute和ICMP"><a href="#3-Traceroute和ICMP" class="headerlink" title="3.Traceroute和ICMP"></a>3.Traceroute和ICMP</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241223211629278.png" alt="image-20241223211629278"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记-网络层(数据平面)</title>
      <link href="/2024/11/01/ji-wang-xue-xi-bi-ji-wang-luo-ceng-shu-ju-ping-mian/"/>
      <url>/2024/11/01/ji-wang-xue-xi-bi-ji-wang-luo-ceng-shu-ju-ping-mian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="第四章-网络层-数据平面"><a href="#第四章-网络层-数据平面" class="headerlink" title="第四章 网络层:数据平面"></a>第四章 网络层:数据平面</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><strong>网络层服务：</strong></p><ul><li>在发送主机和接收主机对之间 传送段（segment）</li><li>在发送端将段封装到数据报中</li><li>在接收端，将段上交给传输层 实体</li><li>网络层协议存在于主机 和路由器</li><li>路由器检查每一个经过它的IP 数据报的头部</li></ul><p><strong>网络层的关键功能：</strong></p><ul><li><strong>转发</strong><ul><li>由<strong>数据平面</strong>完成，<strong>硬件实现</strong></li><li>将分组从路由器 的输入接口转发到合适的输出接口</li><li>本质上就是<strong>在路由器中</strong>，从输入端口发送到输出端口的过程</li></ul></li><li><strong>路由</strong><ul><li>由<strong>控制平面</strong>完成，<strong>软件实现</strong></li><li>使用路由算法来决定分组从发送主机到 目标接收主机的路径<ul><li>路由选择算法</li><li>路由选择协议</li></ul></li><li>本质上是选择走怎样的路径完成端到端传输，路径的节点是一个个路由器</li></ul></li></ul><p><strong>数据平面：</strong></p><ul><li>本地，每个路由器的功能</li><li>决定从路由器输入端口到达的分组如何转发到输出端口</li><li>转发功能：<ul><li>传统方式(IP转发)：基于目标地址+转发表(<strong>因特网重点，也即课程重点</strong>)</li><li>SDN方式(通用转发)：基于多个头部字段+流表</li></ul></li></ul><p><strong>控制平面：</strong></p><ul><li>网络范围内的逻辑</li><li>决定数据报如何在路由器之间路由，决定数据报从源到目标 主机之间的端到端路径</li><li>2个控制平面方法: <ul><li><strong>传统的路由算法</strong>:在路由器中被实现</li><li>software-defined networking  (<strong>SDN</strong>):在远程的服务器中实现</li></ul></li></ul><h3 id="1-传统方式"><a href="#1-传统方式" class="headerlink" title="1.传统方式"></a>1.传统方式</h3><p>在<strong>每一个路由器</strong>中的单独路由器算法元件，在控制平面进行交互</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101142542045.png" alt="image-20241101142542045"></p><p><strong>传统模式下，控制平面和数据平面都位于路由器中：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101142628019.png" alt="image-20241101142628019"></p><p><strong>路由表与转发表</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101145353380.png" alt="image-20241101145353380"></p><h3 id="2-SDN方式"><a href="#2-SDN方式" class="headerlink" title="2.SDN方式"></a>2.SDN方式</h3><blockquote><p>software-defined networking，<strong>软件定义网络</strong></p></blockquote><p>一个不同的（通常是<strong>远程控制器</strong>）控制器与<strong>本地控制代理</strong>（CAs） 交互</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101142711013.png" alt="image-20241101142711013"></p><h3 id="3-网络服务模型"><a href="#3-网络服务模型" class="headerlink" title="3.网络服务模型"></a>3.网络服务模型</h3><p>从发送方主机到接收方主机传输数据报的“通道” ，网络提供什么样的<strong>服务模型</strong>？</p><p><strong>对于单个数据报的服务</strong>: </p><ul><li>可靠传送 </li><li>延迟保证，如：少于 40ms的延迟</li></ul><p><strong>对于数据报流的服务:</strong></p><ul><li>保序数据报传送</li><li>保证流的最小带宽</li><li>分组之间的延迟差</li></ul><p><strong>因特网的网络层提供了单一的服务——尽力而为服务(best effort)</strong></p><ul><li>简而言之，什么保证也没有！</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101142948320.png" alt="image-20241101142948320"></p><h3 id="4-网络层服务"><a href="#4-网络层服务" class="headerlink" title="4.网络层服务"></a>4.网络层服务</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101150123960.png" alt="image-20241101150123960"></p><ul><li><strong>数据报网络</strong>提供网络层<strong>无连接服务</strong></li><li><strong>虚电路网络</strong>提供网络层<strong>连接服务</strong></li><li>网络层服务的对象：<strong>主机到主机</strong><ul><li>运输层：<strong>进程到进程</strong></li></ul></li><li>网络层服务<strong>不能共存</strong>，要么是<strong>数据报网络(因特网)</strong>，要么是<strong>虚电路网络(ATM)</strong></li><li>网络层服务的实现<strong>在网络内部</strong></li></ul><blockquote><p>章节须知：</p><ul><li><strong>转发</strong>和<strong>交换</strong>这两个术语是同义的</li><li>交换机分为：<strong>链路层交换机(第2层)<strong>和</strong>路由器(第3层)</strong>，本章所指的交换机都是路由器</li></ul></blockquote><h2 id="2-路由器组成"><a href="#2-路由器组成" class="headerlink" title="2.路由器组成"></a>2.路由器组成</h2><p>高层面(非常简化的)通用路由器体系架构如下：</p><ul><li><p>路由：运行选择算法／协议(RIP,OSPF,BGP)——<strong>生成路由表</strong></p></li><li><p>转发：从输入到输出链路交换数据报-<strong>根据路由表进行分组的转发</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101144242987.png" alt="image-20241101144242987"></p><p>如上图所示，路由器由<strong>4个组件</strong>构成：</p><ul><li>输入端口</li><li>交换结构</li><li>路由选择处理器</li><li>输出端口</li></ul><blockquote><p>硬件上，输入端口和输出端口是整合在一起的，从架构分析层面我们把他们分开</p></blockquote><h3 id="1-输入端口"><a href="#1-输入端口" class="headerlink" title="1.输入端口"></a>1.输入端口</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101144834576.png" alt="image-20241101144834576"></p><p>输入端口内有<strong>3个模块</strong>：</p><ul><li>物理层实体(最左侧)<ul><li>Bit级的接收</li></ul></li><li>链路层实体(中间)<ul><li>链路层协议动作、解封装 (e.g.,Ethernet 见第五章)</li></ul></li><li>网络层实体(右侧)<ul><li>根据数据报头部的信息如：目的地址 ，在输入端口内存中的转发表中查找合适的输出端口（匹配+行动）</li><li>基于目标的转发：仅仅依赖于IP数据报的目标IP地址（传统方法）</li><li>通用转发：基于头部字段的任意集合，匹配流表相应字段进行转发</li></ul></li></ul><h4 id="1-基于目标的转发"><a href="#1-基于目标的转发" class="headerlink" title="1.基于目标的转发"></a>1.基于目标的转发</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101151310227.png" alt="image-20241101151310227"></p><ul><li>上述表中，单元格内的<code>11001000... throgh 11001000...</code>指的是IP地址，<strong>目标IP在这个范围内的，跳转到指定的某个输出端口</strong></li><li>前21位是一样的，而IP是32位，故共有$2^{11}$个IP地址用一个前缀</li></ul><p><strong>最长前缀匹配</strong>：</p><p>当给定目标地址查找转发表时，采用最长地址前缀匹配的目标地址表项</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101152314268.png" alt="image-20241101152314268"></p><blockquote><p>书本P238的P5、P6、P7，很有意思，回头把解题过程写好贴上来</p></blockquote><h4 id="2-输入端口缓存"><a href="#2-输入端口缓存" class="headerlink" title="2.输入端口缓存"></a>2.输入端口缓存</h4><blockquote><p>可以观察到，输入端口的<strong>网络层实体</strong>是有一个<strong>队列</strong>，队列中是接收到的IP数据报——为什么输入端口需要<strong>队列</strong>？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101145652010.png" alt="image-20241101145652010"></p><p>当<strong>交换结构的速率</strong>小于<strong>输入端口的汇聚速率</strong>时，在输入端口可能要排队</p><ul><li>产生的后果：<strong>排队延迟</strong>以及由于输入缓存溢出造成<strong>丢包</strong>!</li></ul><p><em>为什么交换结构的速率会小于输入端口的汇聚速率？</em></p><p><strong>Head-of-the-Line (HOL) blocking-线路前部阻塞</strong>：</p><ul><li>排在队头的数据报阻止了队列中其他数据报向前移动</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101145915216.png" alt="image-20241101145915216"></p><h3 id="2-交换结构"><a href="#2-交换结构" class="headerlink" title="2.交换结构"></a>2.交换结构</h3><ul><li><p>将分组从输入缓冲区传输到合适的输出端口</p></li><li><p>交换速率：分组可以按照该速率从输入传输到输出</p><ul><li>运行速度经常是输入&#x2F;输出链路速率的若干倍</li><li>N个输入端口：<strong>交换机构的交换速度是输入线路速度的N倍比较理想</strong>，才不会成为瓶颈</li></ul></li><li><p>3种典型的交换机构</p><ul><li><strong>memory</strong>：通过内存交换</li><li><strong>bus</strong>：通过总线交换</li><li><strong>crossbar</strong>：通过互联网络交换(严格来说，crossbar纵横是互联网络的一种，互联网络包括Banyan等)</li></ul></li></ul><h4 id="1-内存交换"><a href="#1-内存交换" class="headerlink" title="1.内存交换"></a>1.内存交换</h4><ul><li>在CPU直接控制下的交换，采用传统的计算机</li><li>分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</li><li>转发速率被内存的带宽限制(<strong>数据报通过BUS两遍</strong>)<ul><li>B个分组，总的转发吞吐量(分组从输入端口传送到输出端口的总速率)小于$B&#x2F;2$</li></ul></li><li><strong>一次只能转发一个分组</strong><ul><li>与分组的输出端口是否一致<strong>无关</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101150904079.png" alt="image-20241101150904079"></p><h4 id="2-总线交换"><a href="#2-总线交换" class="headerlink" title="2.总线交换"></a>2.总线交换</h4><ul><li><p>数据报通过共享总线，从输入端口转发到输出端口</p></li><li><p>总线竞争:交换速度受限于总线带宽</p></li><li><p><strong>1次处理一个分组</strong></p><ul><li>与分组的输出端口是否一致<strong>无关</strong></li></ul></li><li><p>对于接入或企业级路由器，速度足够（ 但不适合区域或骨干网络）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101151026542.png" alt="image-20241101151026542"></p><h4 id="3-互联网络交换"><a href="#3-互联网络交换" class="headerlink" title="3.互联网络交换"></a>3.互联网络交换</h4><ul><li><p>同时并发转发多个分组，克服总线带宽限制</p><ul><li>同时转发的多个分组<strong>必须是不同输出端口的</strong>，相同输出端口的<strong>还是不能并发</strong></li></ul></li><li><p>Banyan（榕树）网络，crossbar(纵横) 和其它的互联网络被开发，将多个处理器连接成多处理器</p></li><li><p>当分组从端口A到达，转给端口Y；控制器短接相应的两个总线</p></li><li><p>高级设计：将数据报分片为固定长度的信元，通过交换网络交换</p></li><li><p>Cisco12000：以60Gbps的交换速率通过互联网络，足以作为骨干网络</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101151237280.png" alt="image-20241101151237280"></p><p>上图中，如果转发表中<strong>A转发到Y</strong>，那么将<strong>蓝色圈起的节点短路即可</strong></p><h3 id="3-输出端口"><a href="#3-输出端口" class="headerlink" title="3.输出端口"></a>3.输出端口</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101152955599.png" alt="image-20241101152955599"></p><ul><li><p>当数据报从交换机构的到达速度比传输速率快，就需要输出端口缓存</p></li><li><p>由<strong>调度规则</strong>选择排队的数据报进行传输</p></li></ul><p><strong>需要注意的是，先进入队列 不等于 先传输！！！传输先后取决于调度规则</strong></p><h4 id="1-输出端口缓存"><a href="#1-输出端口缓存" class="headerlink" title="1.输出端口缓存"></a>1.输出端口缓存</h4><ul><li>假设交换速率$R_{switch}$是$R_{line}$的N倍（N：输入端口的数量）</li><li>当多个输入端口同时向输出端口发送时，缓冲该分组（当通过交换网络到达的速率超过输出速率则<strong>缓存</strong>）</li><li>排队带来延迟，由于输出端口缓存溢出则丢弃数据报——<strong>丢包</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101153258621.png" alt="image-20241101153258621"></p><p><strong>需要多少缓存？</strong></p><ul><li>RFC 3439 拇指规则（经验性规则）：<ul><li>平均缓 存大小&#x3D;典型的RTT（例如：250ms）倍于链路容量C<ul><li>e.g., C &#x3D; 10 Gpbs link</li><li>250ms*10Gbps&#x3D;2.5 Gbit buffer</li></ul></li></ul></li><li>最近的一些推荐：有N（非常大）个流，缓存大小等于：</li></ul><p>$$\frac{RTT \cdot C}{\sqrt(N)}$$</p><h4 id="2-调度机制-不是很重要"><a href="#2-调度机制-不是很重要" class="headerlink" title="2.调度机制(不是很重要)"></a>2.调度机制(不是很重要)</h4><blockquote><p>调度: <strong>选择下一个要通过链路传输的分组</strong></p></blockquote><h5 id="1-FIFO"><a href="#1-FIFO" class="headerlink" title="1.FIFO"></a>1.FIFO</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101153739517.png" alt="image-20241101153739517"></p><h5 id="2-优先权调度"><a href="#2-优先权调度" class="headerlink" title="2.优先权调度"></a>2.优先权调度</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101153802088.png" alt="image-20241101153802088"></p><h5 id="3-循环调度RR"><a href="#3-循环调度RR" class="headerlink" title="3.循环调度RR"></a>3.循环调度RR</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101153818622.png" alt="image-20241101153818622"></p><h5 id="4-加权公平调度"><a href="#4-加权公平调度" class="headerlink" title="4.加权公平调度"></a>4.加权公平调度</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241101153841782.png" alt="image-20241101153841782"></p><h2 id="3-IP-网际协议"><a href="#3-IP-网际协议" class="headerlink" title="3.IP:网际协议"></a>3.IP:网际协议</h2><p>主机、路由器网络层功能：<br><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241103172623321.png" alt="image-20241103172623321"></p><ul><li>互联网的IP服务被定义成<strong>不可靠的、尽力而为、无连接</strong>分组交付系统</li></ul><h3 id="1-IP数据报格式"><a href="#1-IP数据报格式" class="headerlink" title="1.IP数据报格式"></a>1.IP数据报格式</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241103172752106.png" alt="image-20241103172752106"></p><p><strong>IP数据报的首部，固定部分为20字节，可变部分为40字节</strong></p><ul><li><p>版本：<strong>4bit</strong></p><ul><li>指IP协议的版本，如<code>IPv4</code>或<code>IPv6</code></li></ul></li><li><p>首部长度：<strong>4bit</strong>，可表示的最大数值是15个单位(1111)，一个单位4字节</p><ul><li>因此，<strong>IP首部最大60字节</strong>，则<strong>可选字段最长40字节</strong></li><li>可选字段如果没达到4字节，要补齐，达到一个单位</li></ul></li><li><p>服务类型：<strong>8bit</strong>，用来获得更好的服务，没有怎么用过</p></li><li><p>总长度：<strong>16bit</strong>，单位为字节</p><ul><li>指首部和数据之后的长度</li><li>最大为65535字节——数据报的最大长度<ul><li>但受限于链路层最大传输单元MTU(以太网是1500字节)</li></ul></li></ul></li><li><p>标识、标志、片偏移：<strong>标识16bit</strong>，<strong>标志3bit</strong>，<strong>片偏移13bi</strong>t</p><ul><li>用于IP分片功能(IPv6不允许在路由器上对分组分片)</li></ul></li><li><p>生存时间ttl：<strong>8bit</strong></p><ul><li>确保数据报不会永远在网络中循环</li><li>数据报每经过一台路由器，<code>ttl = ttl - 1</code></li><li><code>ttl = 0</code>时丢弃该报文</li></ul></li><li><p>协议：<strong>8bit</strong></p><ul><li>指运输层协议&#x2F;网络层相关协议，TCP:6，UDP:17，ICMP:1，IGMP:2，OSPF:89等<ul><li>TCP、UDP、OSPF是运输层协议</li><li>ICMP、IGMP是网络层协议，辅助IP协议</li></ul></li></ul></li><li><p>首部校验和：<strong>16bit</strong>，<strong>只校验数据报的首部</strong></p><ul><li><p>为什么每次都要重新计算首部校验和：<strong>TTL每传输过一个路由器就减一</strong>，所以要重新计算</p></li><li><p>为什么运输层和网络层都要进行差错检验？网络层只检验首部，运输层检验首部+PDU</p></li></ul></li><li><p>源地址、目的地址：<strong>各占4字节</strong></p></li></ul><h3 id="2-分片和重组"><a href="#2-分片和重组" class="headerlink" title="2.分片和重组"></a>2.分片和重组</h3><blockquote><p>我们都知道，一个链路层帧能承载的最大数据量叫<strong>MTU</strong>，即最大传送单元。IP数据报的大小不能超过MTU，否则需要分成多份</p><ul><li>提醒一下，MTU指的是链路层帧的有效载荷的最大值，也就是SDU的最大值，不包括帧首部</li></ul><p>但是仅仅在发送方端系统设置IP数据报小于当前链路层协议规定的MTU就可以吗？</p></blockquote><p>由于<strong>发送方与目的地路径上的每段链路可能使用不同的链路层协议</strong>，且<strong>每种协议的MTU可能各不相同</strong>：</p><ul><li>大的IP数据报**在网络上(路由器中)*<em>被</em>分片(fragmented)*<ul><li>一个数据报被分割成若干个小的数据报<ul><li>这些数据报的ID相同、偏移量不同、是否是尾部的标记不同</li></ul></li><li><strong>重组只发生在目标主机上</strong><ul><li>防止过程中还有更小的MTU，还要再拆</li><li>降低链路复杂度，尤其是路由复杂度</li></ul></li><li>IP数据报首部的<strong>标识、标志、片偏移</strong>用于标记和排序相关分片</li></ul></li></ul><h4 id="1-标识"><a href="#1-标识" class="headerlink" title="1.标识"></a>1.标识</h4><ul><li>原IP数据报的ID，由同一数据报分片出来的小数据报的<strong>标识相同</strong></li><li><strong>16bit</strong></li></ul><h4 id="2-标志"><a href="#2-标志" class="headerlink" title="2.标志"></a>2.标志</h4><ul><li><p>区分由同一数据报分片出来的若干小数据报中，哪个是<strong>末尾</strong></p></li><li><p><strong>3bit</strong>，分为保留位、DF、MF</p><ul><li><strong>DF&#x3D;0——&gt;允许分片</strong></li><li><strong>MF&#x3D;0——&gt;同标识数据报的最后一个分片</strong></li></ul></li></ul><h4 id="3-片偏移"><a href="#3-片偏移" class="headerlink" title="3.片偏移"></a>3.<strong>片偏移</strong></h4><ul><li>分片在原数据报中的偏移量(位置)</li><li><strong>13bit</strong>，但是<strong>8字节&#x2F;单位</strong>，也就是说，每偏移8字节，片偏移+1<ul><li><strong>因此，最大分片封装的数据量应该是8的整数倍</strong></li></ul></li></ul><h4 id="4-分片过程"><a href="#4-分片过程" class="headerlink" title="4.分片过程"></a>4.分片过程</h4><ul><li>假设原IP分组总长度为$L$</li><li>待转发链路的MTU为$M$</li><li>若$L&gt;M$，且$DF&#x3D;0$，则可以&#x2F;需要分片</li><li>分片时，每个分片的标识复制原IP分组的标识</li><li>通常，分片时<strong>除了最后一个分片，其他分片均分为MTU允许的最大分片</strong><ul><li>一个最大分片可封装的数据应该是<strong>8字节的倍数</strong><ul><li>因此，假设MTU&#x3D;1501，不是8的倍数，那么分片最大是1500</li><li>因此这一要求实际应该是：<strong>最大分片字节数-20必须是8的倍数</strong>，而最大分片<strong>不必等于MTU</strong></li><li><strong>最大分片-20</strong>就是IP数据报的Body部分，因为偏移量就是计算在Body部分的偏移，因此Body必须是8的倍数，而Body+20不必是</li></ul></li><li>最大分片可封装的数据(准确说，是<strong>最大分片可封装的网络层帧的载荷</strong>)为：<ul><li>$$d &#x3D; \lfloor \frac{M-20}{8} \rfloor \cdot 8$$</li><li>向下取整</li></ul></li><li>需要的总片数为：<ul><li>$$n &#x3D; \lceil \frac{L-20}{d} \rceil$$</li><li>向上取整</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241115200427806.png" alt="image-20241115200427806"></p><hr><h3 id="3-IPv4编址"><a href="#3-IPv4编址" class="headerlink" title="3.IPv4编址"></a>3.IPv4编址</h3><h4 id="1-引论"><a href="#1-引论" class="headerlink" title="1.引论"></a>1.引论</h4><p><strong>接口：</strong></p><ul><li>主机与路由器连入网络的方法：<strong>物理链路</strong></li><li>主机&#x2F;路由器与物理链路之间的边界：<strong>接口</strong><ul><li>实际上，<strong>1个IP地址与1个接口相关联，而不是与包含该接口的主机&#x2F;路由器相关联</strong></li><li>因此，主机的IP至少1个，路由器的IP至少2个</li></ul></li></ul><p><strong>IP地址：</strong></p><ul><li><strong>对主机&#x2F;路由器的接口进行编址</strong></li><li>4字节，即32bit</li><li><strong>点分十进制记法</strong>，每8bit用<code>.</code>隔开</li></ul><p><strong>接口如何连接？</strong></p><ul><li>有线以太网网口链接到以太网络交换机连接</li><li>详情会在下两章解释，下图中右侧的就是链路层交换机，这里是以太网络交换机</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241115201851090.png" alt="image-20241115201851090"></p><h4 id="2-子网"><a href="#2-子网" class="headerlink" title="2.子网"></a>2.子网</h4><blockquote><p>IP地址分成两部分：</p><ul><li>子网部分：高位bits</li><li>主机部分：低位bits</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241115202138123.png" alt="image-20241115202138123"></p><h5 id="1-什么是子网-subnet-？"><a href="#1-什么是子网-subnet-？" class="headerlink" title="1.什么是子网(subnet)？"></a>1.什么是<strong>子网(subnet)</strong>？</h5><ul><li>子网内节点(包括主机和路由器接口)的<strong>IP地址的高位部分相同</strong></li><li>子网内各主机<strong>可以物理上相互直达，无需路由器介入</strong></li></ul><p><em>上图中，<code>223.1.1.1</code>、<code>223.1.1.2</code>、<code>223.1.1.3</code>、<code>223.1.1.4</code>构成了一个子网</em></p><h5 id="2-如何判断子网？"><a href="#2-如何判断子网？" class="headerlink" title="2.如何判断子网？"></a>2.如何<strong>判断子网</strong>？</h5><ul><li>分开主机和路由器的每个接口，产生的每个<strong>隔离的网络岛</strong>就是一个<strong>子网</strong></li><li>下图的网络中，就有<strong>6个子网</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241115202646761.png" alt="image-20241115202646761"></p><h5 id="3-子网掩码"><a href="#3-子网掩码" class="headerlink" title="3.子网掩码"></a>3.<strong>子网掩码</strong></h5><p><strong>IP编址为上述的某个子网分配一个地址：</strong></p><p><code>223.1.1.0/24</code></p><ul><li>其中的<code>/24</code>记法，称为<strong>子网掩码</strong>，<strong>指示了32比特中的高24位是子网部分</strong></li></ul><p><strong>子网掩码的另一种记法是二进制的：</strong></p><ul><li>32比特中，位&#x3D;1表示该位属于子网部分，位&#x3D;0表示该位属于主机部分</li></ul><p><code>11111111 11111111 11111111 00000000</code>即<code>/24</code></p><h5 id="4-纯子网和非纯子网"><a href="#4-纯子网和非纯子网" class="headerlink" title="4.纯子网和非纯子网"></a>4.<strong>纯子网和非纯子网</strong></h5><p>我们可以看到，上述的6个子网是严格符合子网定义的，我们称之为<strong>纯子网</strong></p><p>但是我们也可以看到，这6个子网的IP地址的<strong>更高部分也是相同的</strong>，都是<code>223.1</code>；只是这6个子网之间<strong>需要路由器介入</strong>来满足主机的直达，我们称这个<strong>大的网络</strong>叫做<strong>非纯子网</strong></p><p><strong>非纯子网的作用在于路由聚集</strong></p><hr><h4 id="3-分类编址"><a href="#3-分类编址" class="headerlink" title="3.分类编址"></a>3.分类编址</h4><blockquote><p>在讲解编址前，首先需要说明一件事情：为什么需要有<strong>子网</strong>这个概念？</p><p>我们都知道转发表，路由器根据分组的目的地址和转发表决定分组的下一跳。那么，如果转发表的表项是IP地址，那就非常糟糕了。因为IP地址有32位，一共有2^32个IP，难道转发表也要有2^32项吗？<strong>显然不能！</strong></p><p>计算机网络的设计者也清楚这点。因此，他们这样设计：</p><p><strong>转发表中的表项，不是IP，而是子网(非纯子网也可)</strong></p><p><strong>网络中，是以子网为单位散播子网的可达信息(也就是路径怎么走)</strong></p></blockquote><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><p><strong>分类编址</strong>，指的是将IP地址的子网部分限制长度为8、16、24比特</p><ul><li>具有8、16、24比特子网地址的网络分别称为A、B、C类网络<ul><li>A、B、C类网络的子网掩码也是固定的</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241115213548179.png" alt="image-20241115213548179"></p><ul><li><p>A类网络：最高位&#x3D;0，7位子网，24位主机</p><ul><li>网络数为：<strong>2^7-2&#x3D;126</strong> <strong>(特殊：全0和全1不使用：7位0+首位0的网络号表示<code>本网</code>；7位1+首位0&#x3D;127的网络号用作回环测试)</strong></li><li>主机数为：<strong>2^24-2(全0指的是该网络，全1指的是直接广播地址)</strong><ul><li>每个网络有<strong>2^24个IP地址</strong>，共<strong>2^24-2</strong>个<strong>可用主机IP(全0和全1另有它用)</strong></li></ul></li></ul></li><li><p>B类网络：最高2位&#x3D;10，14位子网，16位主机</p><ul><li>网络数为：<strong>2^14</strong></li><li>主机数为：<strong>2^16-2(全0指的是该网络，全1指的是直接广播地址)</strong><ul><li>每个网络有<strong>2^16个IP地址</strong>，共<strong>2^14-2</strong>个<strong>可用主机IP(全0和全1另有它用)</strong></li></ul></li></ul></li><li><p>C类网络：最高位&#x3D;110，21位子网，8位主机</p><ul><li>网络数为：<strong>2^21</strong></li><li>主机数为：<strong>2^8-2(全0指的是该网络，全1指的是直接广播地址)</strong><ul><li>每个网络有<strong>2^8个IP地址</strong>，共<strong>2^8-2</strong>个<strong>可用主机IP(全0和全1另有它用)</strong></li></ul></li></ul></li></ul><hr><h5 id="2-特殊IP地址"><a href="#2-特殊IP地址" class="headerlink" title="2.特殊IP地址"></a>2.特殊IP地址</h5><table><thead><tr><th>子网部分</th><th>主机部分</th><th>作为IP分组源地址</th><th>作为IP分组目的地址</th><th>作用</th></tr></thead><tbody><tr><td>全0</td><td>全0</td><td>可以</td><td>不可以</td><td>在本网范围内表示本机(不知道自己处于什么网络时)<br /> 在路由表中用于表示默认路由(相当于表示整个Internet网络)</td></tr><tr><td>全0</td><td>特殊值</td><td><strong>不可以</strong></td><td>可以</td><td>表示子网(本网)内某个特定主机</td></tr><tr><td>全1</td><td>全1</td><td>不可以</td><td>不可以</td><td>子网(本网)受限广播地址，不会被路由器转发</td></tr><tr><td>特定值</td><td>全0</td><td>不可以</td><td>不可以</td><td>网络地址，表示一个网络</td></tr><tr><td>特定值</td><td>全1</td><td>不可以</td><td>可以</td><td>直接广播地址，对特定网络上的所有主机进行广播</td></tr><tr><td>127</td><td>非全0、非全1</td><td>可以</td><td>可以</td><td>用于本地软件环回测试，称为环回地址。如127.0.0.1，指向自身，测试网卡是否正常</td></tr></tbody></table><h5 id="3-私有地址"><a href="#3-私有地址" class="headerlink" title="3.私有地址"></a>3.私有地址</h5><ul><li>私有地址：在互联网中<strong>不使用</strong>，<strong>仅在局域网中使用的IP地址</strong><ul><li>A类：<code>10.xx.xx.xx</code></li><li>B类：<code>172.16.0.0</code>到<code>172.31.255.255</code></li><li>C类：<code>192.168.xx.xx</code></li></ul></li></ul><h4 id="4-无类域间路由CIDR"><a href="#4-无类域间路由CIDR" class="headerlink" title="4.无类域间路由CIDR"></a>4.无类域间路由CIDR</h4><blockquote><p>由于A、B、C类网络固定了主机数和网络数，而现实中的需求又是多变的，因此会出现冗余，这不好，资源不能浪费。</p></blockquote><p><strong>无类域间路由CIDR：</strong></p><ul><li><p>子网部分长度任意的<strong>连续地址的地址块</strong></p><ul><li>当然，<strong>子网内IP的网络部分仍然要相同</strong></li></ul></li><li><p><strong>地址块</strong>格式：<code>a.b.c.d/x</code>，<code>/x</code>即子网掩码</p><ul><li>其中，高x位的IP地址又称之为该地址的<strong>前缀</strong>，也就是<strong>子网号(子网部分)</strong></li><li>IP地址与子网掩码的按位与——得到子网号(或者通过推算)</li></ul></li><li><p><strong>网络地址是地址块的第一个地址，广播地址是地址块的最后一个地址</strong></p><ul><li>主机可用地址要减去这两个部分</li></ul></li></ul><blockquote><p>考点：</p><p>网络地址：IP地址与掩码<strong>按位与</strong></p><p>IP地址范围：计算主机数(2^(32-x))</p><p>主机可用地址范围：IP地址减去头尾(网络地址和广播地址)</p></blockquote><h4 id="5-转发表和转发算法"><a href="#5-转发表和转发算法" class="headerlink" title="5.转发表和转发算法"></a>5.转发表和转发算法</h4><blockquote><p>普及一个概念：<strong>默认网关</strong></p><p><strong>默认网关</strong>是设备通向外部网络的“出口”，用于转发不在本地子网内的通信</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241121201843197.png" alt="image-20241121201843197"></p><p>转发表中的4项：</p><ul><li><p><strong>目标子网号</strong></p><ul><li>如果表项里的都没有匹配上，就会选择<code>Default</code></li></ul></li><li><p><strong>子网掩码</strong></p></li><li><p><strong>下一跳(hop)的IP</strong></p><ul><li>转发的下一个路由器的接口的IP</li></ul></li><li><p><strong>端口</strong></p><ul><li><code>Default</code>会选择默认端口，也就是跳向路由所在网络的出口路由(即默认网关)</li></ul></li></ul><h4 id="6-层次划分子网"><a href="#6-层次划分子网" class="headerlink" title="6.层次划分子网"></a>6.层次划分子网</h4><blockquote><p>Q:如何获得一个网络的子网部分?</p><p>A:从ISP获得地址块中分配一个小地址块，而ISP从ICANN这个机构中获得地址块</p><ul><li>ICANN:工作是<strong>分配地址、管理DNS、分配域名，解决冲突</strong></li></ul></blockquote><p>ISP在获得一段连续地址块后，可以<strong>将一个网络块分成几个部分供多个内部网络使用</strong>，但是对外部世界来说仍然像单个网络</p><ul><li>ISP的地址块是由ICANN这个机构分配的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241115221710673.png" alt="image-20241115221710673"></p><blockquote><p>考点：内部网络的主机需求不同，因此子网部分长度不一。但<strong>为了保证各子网间的子网号不重复，必须注意分配连续地址块的位置</strong></p><p>诀窍：<strong>将需要的主机数从大到小排列，大的先分配</strong></p><p>默认的是，如果需要120个IP，我提供128个，方便去写；但如果因为扩大导致不够分配的，就老老实实分配120个吧</p></blockquote><h4 id="7-DHCP"><a href="#7-DHCP" class="headerlink" title="7.DHCP"></a>7.DHCP</h4><blockquote><p>Q：主机如何获得一个IP地址？</p><p>A：两种方式</p><ul><li>第一种：”硬编码”，系统管理员将地址配置在一个文件中(太麻烦)</li><li>第二种：DHCP，从服务器中<strong>动态获得一个IP地址</strong>，<code>plug-and-play</code>，<strong>使用UDP服务</strong>，<strong>UDP端口67</strong></li></ul></blockquote><p><strong>DHCP：Dynamic Host Configuration Protocol</strong></p><p>**目标：**允许主机在加入网络的时候，动态地从服务器那里获得IP地址</p><ul><li>允许续租，可以更新对主机在用IP地址的租用期-租期快到了</li><li>允许地址重用，重新启动时，允许重新使用以前用过的IP地址</li><li>允许动态接入，支持移动用户加入到该网络（短期在网）</li></ul><p><strong>工作概况：</strong></p><ul><li>主机广播<code>“DHCPdiscover”</code>报文<ul><li>因为没联网，不知道自己IP也不知道DHCP服务器IP，所以<strong>源IP&#x3D;<code>0.0.0.0</code></strong>，<strong>目的IP&#x3D;<code>255.255.255.255</code></strong>，即<strong>向子网内的所有设备<em>广播</em></strong></li></ul></li><li>DHCP服务器用<code>“DHCPoffer”</code>提供报文响应<ul><li>响应中包括：<strong>IP地址、第一跳路由器的IP地址(默认网关)、DNS服务器的域名和IP地址、子网掩码</strong><ul><li>分配给主机的IP地址：<code>yiaddrr</code>，即<code>your IP address</code></li><li>默认网关地址：<code>router</code></li><li>DNS：<code>domain-name</code>和<code>domain-name-server</code></li><li>DHCP服务器自己的地址：出现在<code>src</code>和<code>siaddrr(server IP address)</code>中</li><li>子网掩码：<code>subnet-mask</code></li></ul></li><li>因为IP地址尚未被主机收到，因此报文响应的<strong>目的IP&#x3D;<code>255.255.255.255</code></strong>，也是<strong>向子网内的所有设备<em>广播</em></strong></li></ul></li><li>主机请求IP地址：发送<code>“DHCPrequest”</code>报文<ul><li>因为主机所在域内可能<strong>不止一个DHCP服务器(不止一个子网覆盖)</strong>，报文响应不止一个，主机选择一个<strong>并向所有的DHCP服务器<em>广播</em>请求报文</strong>，表示我已经选择了某个DHCP服务器</li></ul></li><li>DHCP服务器发送地址：<code>“DHCPack”</code>报文</li><li>需要注意的是：DHCP的4次报文往返，都是<strong>广播！！！</strong><ul><li>DHCP discover：源0.0.0.0，目的255.255.255.255</li><li>DHCP offer：源(<code>DHCP ServerIP</code>)，目的255.255.255.255</li><li>DHCP request：源0.0.0.0，目的255.255.255.255</li><li>DHCP ACK：源(<code>DHCP ServerIP</code>)，目的255.255.255.255</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241121205427465.png" alt="image-20241121205427465"></p><blockquote><p><strong>注意，DHCP是建立在UDP服务上的应用层协议！！！</strong></p></blockquote><h4 id="8-路由聚合"><a href="#8-路由聚合" class="headerlink" title="8.路由聚合"></a>8.路由聚合</h4><blockquote><p>在3.2节中有解释</p></blockquote><p>路由聚合使用非纯子网的子网号，有利于减少转发表的表项数目，提高效率和性能</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241121210430721.png" alt="image-20241121210430721"></p><p>如上图所示，<code>200.23.16.0/23</code>，<code>200.23.20.0/23</code>，<code>200.23.30.0/23</code>，<code>200.23.18.0/23</code>这4个子网可以认为是一个<code>200.23.16/20</code>的<strong>非纯子网</strong></p><p>这个非纯子网告诉路由器：</p><ul><li>如果遇到子网号是<code>200.23.16.0</code>，子网掩码是<code>/20</code>的<strong>目的IP的包</strong>进入路由，就把它发给我这个非纯子网</li><li>我的IP是<code>x</code>(也就是这个<strong>非纯子网的默认网关(出口网关)的出口接口的IP</strong>)，也就是路由表里的<code>200.23.16.0</code>的<strong>下一跳</strong>就是<code>x</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241121205710037.png" alt="image-20241121205710037"></p><p>而像这张图所示，<code>200.23.16.0/20</code>不再包含所有的子网，有<strong>1个</strong>子网<code>200.23.18.0/23</code>在另一个非纯子网中，<strong>也是可以使用非纯子网做路由聚集的</strong></p><ul><li><strong>注意，如果非纯子网能概括n个子网，但只有n-m个在本机构中，m个在其他机构中，仍然可以路由聚集</strong></li><li><strong>但是另外的那m个就必须单独拿出来放在路由表中了，不能一起聚集了，因为默认网关的端口IP不同</strong><ul><li>这就是为啥需要**最长前缀匹配！！！！**最长，则最精确</li></ul></li></ul><hr><h3 id="4-NAT-网络地址转换"><a href="#4-NAT-网络地址转换" class="headerlink" title="4.NAT:网络地址转换"></a>4.NAT:网络地址转换</h3><blockquote><p>NAT出现的原因：IPv4地址不够了，总不能还是网络中有好几个公网IP地址或者每个主机一个公网IP地址吧，那也太费钱了</p><p>——不如，本地网络中只有一个有效IP地址(公网IP地址)，子网内部的设备都采用内网IP(10.xx.xx.xx&#x2F;172.16.0.0~172.31.255.255&#x2F;192.168.xx.xx)</p><p>——那这样的话，势必要进行内网向外网的地址转换——NAT应运而生</p></blockquote><p><strong>NAT：Network Address Translation</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241121215959010.png" alt="image-20241121215959010"></p><h4 id="1-动机"><a href="#1-动机" class="headerlink" title="1.动机"></a>1.动机</h4><p><strong>本地网络只有一个有效IP地址</strong> </p><ul><li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备——省钱</li><li>可以在局域网改变设备的地址情况下而无须通知外界</li><li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li><li>局域网内部的设备没有明确的地址，对外是不可见的——安全</li></ul><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h4><p><strong>NAT路由器必须：</strong></p><ul><li>内网向外发出数据包：替换源地址和端口号为**<code>NAT IP</code>地址和新的端口号**，目标IP和端口不变<ul><li>这个<strong>新的端口号</strong>对应着发出数据包的内网主机的<code>IP</code>和<code>port</code></li><li>远端的C&#x2F;S将会用<code>NAT IP</code>地址，新端口号作为目标地址</li></ul></li><li>路由器记住每个转换替换对（在<strong>NAT转换表</strong>中）<ul><li>源IP，端口vs<code>NAT IP</code>，新端口</li></ul></li><li>外网向内返回数据包：替换目标IP地址和端口号，采用存储在NAT表中的mapping表项，用（源IP，端口）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241121215008250.png" alt="image-20241121215008250"></p><h4 id="3-可行性"><a href="#3-可行性" class="headerlink" title="3.可行性"></a>3.可行性</h4><p>NAT实际上是<strong>用端口映射内网的(IP，端口)二元组</strong>，是否现实呢？</p><ul><li>端口字段是<strong>16bit</strong>，也就是NAT路由器有6万多个端口，减去转发表中已使用的端口，还是有6万多个<ul><li>谁家局域网能同时从不同IP&#x2F;不同端口发6万多个数据包啊？</li><li>可行！</li></ul></li></ul><h4 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h4><p><strong>NAT优点</strong>：</p><p><strong>解决IPv4地址耗尽问题</strong></p><ul><li>本地网络设备IP地址的变更，无需通告外界网络</li><li>变更ISP时，无需修改内部网络设备IP地址</li><li>内部网络设备对外界不可见，不可直接寻址（安全）</li></ul><p><strong>NAT争议之处</strong>：</p><ul><li>路由器应该只处理第三层功能<ul><li>明明是第三层(网络层)设备，却看到了第四层(运输层)的参数<strong>port</strong>，还去修改<strong>port</strong></li><li>违反了端到端原则应用</li></ul></li><li>设计者必须要考虑 NAT可能性，如 P2P应用程序地址</li><li>短缺应当由IPv6来解决</li></ul><h4 id="5-NAT穿越问题"><a href="#5-NAT穿越问题" class="headerlink" title="5.NAT穿越问题"></a>5.NAT穿越问题</h4><blockquote><p>不考，仅做科普</p></blockquote><p>NAT转换实际上仅针对一种情况：*<em>局域网内主机(进程)<em>主动发送数据包</em>给外网主机(进程)</em>*</p><p>但还有一种情况：*<em>外网主机(进程)<em>主动发送数据包</em>给局域网主机(进程)</em>*</p><p>在后者的情况下，由于内网主机的不可见性，外网发来的数据包进入NAT路由后不知道怎么走了</p><p>——这就是<strong>NAT穿越问题</strong></p><p><strong>方案一：</strong></p><ul><li>静态配置NAT：转发进来的对服务器特定端口连接请求<ul><li>e.g.,(<code>123.76.29.7</code>,<code>port2500</code>) 总是转发到<code>10.0.0.1</code> <code>port25000</code></li></ul></li></ul><p><strong>方案二：</strong></p><ul><li>UPnP协议&#x2F;IGD协议(同义词)：允许 NATted主机(即局域网内主机)可以: <ul><li>获知网络的公共IP地址 (e.g.138.76.29.7) </li><li>列举存在的端口映射 </li><li>增&#x2F;删端口映射(在租用时间内)<ul><li>翻译一下就是，允许局域网内主机在开通某项服务时(比如10.0.0.1主机的web服务80端口)，到NAT路由中查询NAT转发表是否包含这一转发项，没有的话就自行添加一个(比如NAT的WAN端的8080端口对应10.0.0.1主机的80端口)</li></ul></li></ul></li></ul><p><strong>方案三：</strong></p><ul><li>中继(<code>usedinSkype</code>)<ul><li>NAT后面的服务器建立和中继的连接</li><li>外部的客户端链接到中继</li><li>中继在2个连接之间桥接<ul><li>这仍然需要内网(ip+port)主动发一个数据包到中继，给中继一个记录</li></ul></li></ul></li></ul><h4 id="6-例题"><a href="#6-例题" class="headerlink" title="6.例题"></a>6.例题</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122151345182.png" alt="image-20241122151345182"></p><blockquote><p>无线路由器使用NAT，5台设备使用内网IP；这5个内网IP也是路由器通过DHCP协议动态分配给5台设备的</p></blockquote><hr><h3 id="5-IPv6"><a href="#5-IPv6" class="headerlink" title="5.IPv6"></a>5.IPv6</h3><blockquote><p>IPv6编址，共128bit，也就是16字节，远大于IPv4的32bit，即4字节。在人类无法彻底摆脱重力影响前，IPv6地址足够使用了</p></blockquote><h4 id="1-动机-1"><a href="#1-动机-1" class="headerlink" title="1.动机"></a>1.动机</h4><ul><li>初始动机:32-bit地址空间将会被很快用完</li><li>另外的动机: <ul><li>头部格式改变帮助加速处理和转发<ul><li>TTL-1 </li><li>头部checksum</li><li>分片</li></ul></li><li>头部格式改变帮助QoS(Quality of Service，服务质量)</li></ul></li></ul><h4 id="2-IPv6数据报格式"><a href="#2-IPv6数据报格式" class="headerlink" title="2.IPv6数据报格式"></a>2.IPv6数据报格式</h4><ul><li><strong>固定的40字节头部</strong></li><li>数据报传输过程中，<strong>不允许分片</strong></li></ul><h5 id="1-数据报整体结构"><a href="#1-数据报整体结构" class="headerlink" title="1.数据报整体结构"></a>1.数据报整体结构</h5><p>基本首部(40字节)+可选首部(options)+数据部分(最多64KB)</p><ul><li>options名为”可选首部”，实际上<strong>不算在首部中</strong>，而是算在<strong>有效载荷</strong>中</li><li>因此也可以将IPv6数据报分成两部分——<strong>固定的首部+有效载荷</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122130833243.png" alt="image-20241122130833243"></p><h5 id="2-首部结构"><a href="#2-首部结构" class="headerlink" title="2.首部结构"></a>2.首部结构</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122131419628.png" alt="image-20241122131419628"></p><ul><li><p><strong>版本</strong><code>ver</code>：</p><ul><li>标识当前数据报采用的网络层编址版本是<code>IPv4</code>还是<code>IPv6</code></li></ul></li><li><p><strong>流量类型</strong><code>priority</code>：</p><ul><li>标示流中数据报的传输优先级(或服务类别)</li></ul></li><li><p><strong>流标签</strong><code>flow label</code>：</p><ul><li>标识同一“流”中的数据报<ul><li>网络设备可以基于这个标识符快速分类和处理流量，无需对每个数据包进行深度分析</li></ul></li><li><strong>流量类型和流标签</strong>提供QoS区分与支持</li></ul></li><li><p><strong>有效载荷长度</strong><code>payload len</code>：</p><ul><li>标示该数据报的<strong>有效载荷</strong>长度(包括options)</li></ul></li><li><p><strong>下一个首部</strong><code>next header</code>：</p><ul><li>标识下一个选项首部(<strong>options首部</strong>)或上层协议首部(如TCP报文段首部，也就是<strong>数据部分的首部</strong>)<ul><li>而如果标识的是options扩展首部，该首部的结构是：<code>NextHeader+Len+Value</code>，也有一个<code>next header</code>，同样指向下个选项首部或上层协议(如TCP报文段)首部</li></ul></li></ul></li><li><p><strong>跳数限制</strong><code>hop limit</code>：</p><ul><li>与IPv4的<code>ttl</code>类似，都是记录跳数多少的，每经过一个路由，<code>hop limit -1</code></li></ul></li></ul><h5 id="3-与IPv4变化"><a href="#3-与IPv4变化" class="headerlink" title="3.与IPv4变化"></a>3.与IPv4变化</h5><ul><li>首部校验和Checksum:<ul><li><strong>被移除</strong>掉，该字段降低在每一路由中的处理速度</li></ul></li><li>可选项Options:<ul><li>允许，但是<strong>在头部之外</strong>,<strong>被“Next Header”字段标示</strong></li></ul></li><li>分片和重组：<ul><li>不允许路由器分片</li></ul></li><li>ICMPv6:<ul><li>ICMP的新版本</li><li>附加的报文类型，如 “分组太大”<code>packet too big</code></li><li>多播组管理功能</li></ul></li><li><em>那既然不能分片，如果分组过大，<code>IPv6</code>怎么处理？</em><ul><li>丢弃该分组</li><li>使用ICMPv6向发送方报告错误信息——分组过大，重新发送分组！</li></ul></li></ul><h4 id="3-IPv6地址"><a href="#3-IPv6地址" class="headerlink" title="3.IPv6地址"></a>3.IPv6地址</h4><p>IPv6地址一般形式[<strong>冒分十六进制</strong>]: </p><p><code>1002:003b:456c:678d:890e:0000:0000:56g7</code></p><p>URLs: <code>http://[1002:3b:456c:678d:890e::56g7]:8000</code></p><h4 id="4-从IPv4到IPv6的迁移"><a href="#4-从IPv4到IPv6的迁移" class="headerlink" title="4.从IPv4到IPv6的迁移"></a>4.从IPv4到IPv6的迁移</h4><blockquote><p>由于使用IPv4的设备&#x2F;服务太多了，没办法统一说：欸兄弟，咱们一起关机，一起更新，再一起上线吧</p><p>因此，需要平滑的进行迁移。</p><p>目前我们可以将当下的设备这样比拟：使用IPv4的设备是一片大海，使用IPv6的设备是一个个孤岛。大海内的节点通信用IPv4，孤岛内的节点通信用IPv6。</p><p>孤岛间如何通信？</p></blockquote><ul><li><strong>双栈</strong>：可以认为是孤岛与大海之间的接口路由器<ul><li>具有发送&#x2F;接收IPv6和IPv4两种数据报的能力</li></ul></li><li><strong>隧道(Tunneling)</strong>：孤岛将IPv6数据报发给双栈路由，双栈路由将之打包成IPv4数据报，IPv4数据报的有效载荷是IPv6数据报，这样就可以在大海中传递，给到另一个孤岛的双栈路由，再解封装拿到IPv6数据报，在孤岛内传递<ul><li>在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报，如下图所示</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122133516204.png" alt="image-20241122133516204"></p><p><strong>隧道</strong>的示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122133535414.png" alt="image-20241122133535414"></p><hr><h2 id="4-通用转发和SDN"><a href="#4-通用转发和SDN" class="headerlink" title="4.通用转发和SDN"></a>4.通用转发和SDN</h2><blockquote><p>在上面的介绍中，我们是使用传统方式实现的网络功能——控制平面和数据平面<strong>垂直集成在路由器中</strong></p><ul><li>转发表存储在路由器中，由路由器广播信息获得表项</li><li>路由算法也存储在路由器中，在路由器中计算转发路径</li></ul><p>这种方式的问题是：垂直集成，路由分布式计算，导致了：</p><ul><li>无法改变路由等工作逻辑，无法实现流量工程等高级特性</li><li>配置错误影响全网运行，升级和维护会涉及到全网设备</li><li>要增加新的网络功能，需要设计、实现以及部署新的特定设备，设备种类繁多</li></ul><p>因此，我们需要一种<strong>水平集成</strong>，<strong>可编程</strong>，<strong>控制平面与数据平面分离</strong>的<strong>路由器实现方式</strong>——SDN方式(软件定义网络)</p></blockquote><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h3><blockquote><p>理解即可，不太会考</p></blockquote><h4 id="1-SDN特点"><a href="#1-SDN特点" class="headerlink" title="1.SDN特点"></a>1.SDN特点</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122143335484.png" alt="image-20241122143335484"></p><h4 id="2-SDN架构"><a href="#2-SDN架构" class="headerlink" title="2.SDN架构"></a>2.SDN架构</h4><h5 id="1-数据平面交换机"><a href="#1-数据平面交换机" class="headerlink" title="1.数据平面交换机"></a>1.数据平面交换机</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122143428136.png" alt="image-20241122143428136"></p><h5 id="2-SDN控制器"><a href="#2-SDN控制器" class="headerlink" title="2.SDN控制器"></a>2.SDN控制器</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122143449780.png" alt="image-20241122143449780"></p><h5 id="3-控制应用"><a href="#3-控制应用" class="headerlink" title="3.控制应用"></a>3.控制应用</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122143510127.png" alt="image-20241122143510127"></p><h3 id="2-通用转发"><a href="#2-通用转发" class="headerlink" title="2.通用转发"></a>2.通用转发</h3><p>远程控制器计算<strong>流表</strong>，通过<strong>南向API</strong>发布到各个路由器</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122143739196.png" alt="image-20241122143739196"></p><h3 id="3-OpenFlow"><a href="#3-OpenFlow" class="headerlink" title="3.OpenFlow"></a>3.OpenFlow</h3><blockquote><p><strong>OpenFlow</strong> 是一种开放的网络通信协议，是软件定义网络（SDN，Software-Defined Networking）的核心组件之一。它允许网络设备（如交换机和路由器）将其控制平面和数据平面分离，提供了一种集中化的网络管理方式，极大地提高了网络的灵活性和可编程性。</p></blockquote><p>路由器中的流表（由<strong>远程控制器计算和发布</strong>）定义了<strong>路由器匹配+动作规则</strong></p><h4 id="1-流表数据平面抽象"><a href="#1-流表数据平面抽象" class="headerlink" title="1.流表数据平面抽象"></a>1.流表数据平面抽象</h4><p><strong>流表字段包括：</strong></p><ul><li><strong>首部值字段集合</strong>：匹配分组首部值</li><li><strong>动作</strong>：对于匹配的分组: 丢弃、转发、修改…</li><li><strong>优先级</strong>: 当匹配多个表项，执行优先级高的表项对应动作</li><li><strong>计数器</strong>: 匹配表项的分组数目，更新时间<ul><li>也就是该表项匹配了的分组的数目</li></ul></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> src=1.2.<span class="token italic"><span class="token punctuation">*</span><span class="token content">.</span><span class="token punctuation">*</span></span>, dest=3.4.5.<span class="token italic"><span class="token punctuation">*</span><span class="token content"> ——> drop即src,dest匹配时，丢弃该分组                        2. src = </span><span class="token punctuation">*</span></span>.<span class="token italic"><span class="token punctuation">*</span><span class="token content">.</span><span class="token punctuation">*</span></span>.<span class="token italic"><span class="token punctuation">*</span><span class="token content">, dest=3.4.</span><span class="token punctuation">*</span></span>.<span class="token italic"><span class="token punctuation">*</span><span class="token content"> ——> forward(2)即src,dest匹配时，转发到端口23. src=10.1.2.3, dest=</span><span class="token punctuation">*</span></span>.<span class="token italic"><span class="token punctuation">*</span><span class="token content">.</span><span class="token punctuation">*</span></span>.* ——> send to controller即src,dest匹配时，发给远程控制器，由它决定操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-流表表项结构"><a href="#2-流表表项结构" class="headerlink" title="2.流表表项结构"></a>2.流表表项结构</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122144608602.png" alt="image-20241122144608602"></p><ul><li>规则中，需要设置的规则<strong>给出具体的数值</strong>，不需要设置的规则<strong>用<code>*</code>代替即可</strong></li></ul><p><strong>示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122144806960.png" alt="image-20241122144806960"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122144814164.png" alt="image-20241122144814164"></p><h4 id="3-OpenFlow抽象"><a href="#3-OpenFlow抽象" class="headerlink" title="3.OpenFlow抽象"></a>3.OpenFlow抽象</h4><ul><li><strong>match+action</strong>: 统一化各种网络设备提供的功能</li></ul><p>路由器</p><ul><li>match: 最长前缀匹配</li><li>action: 通过一条链路转发</li></ul><p>防火墙</p><ul><li>match: IP地址和 TCP&#x2F;UDP端口号</li><li>action: 允许或者禁止</li></ul><p>交换机</p><ul><li>match: 目标MAC地址 </li><li>action: 转发或者泛洪</li></ul><p>NAT</p><ul><li>match: IP地址和端口号</li><li>action: 重写地址和端口号</li></ul><h4 id="4-OpenFlow示例"><a href="#4-OpenFlow示例" class="headerlink" title="4.OpenFlow示例"></a>4.OpenFlow示例</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122145232600.png" alt="image-20241122145232600"></p><h2 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h2><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241122153922022.png" alt="image-20241122153922022"></p><ul><li><p>首先，做一下简单的判断就可以知道，上述4条路由的低3位不统一，因此子网掩码为<code>/21</code>，因此，非纯子网号为<code>172.18.128.0</code></p></li><li><p>其次，为什么不能是<code>172.18.129.0</code>？</p><ul><li>子网掩码为<code>/21</code>，高24位的低3位为0，则对应的子网号的22~24位也要为0，换言之就是第3字节必须是8的倍数</li><li>129不是8的倍数，因此不能是<code>172.18.129.0</code></li><li>或者更直白的讲，<code>172.18.129.0/21</code>的主机号<strong>不是全0</strong>，那还能代表网络本身吗？</li></ul></li><li><p>答案中的地址指的是<strong>网络地址！！！！！</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记-运输层</title>
      <link href="/2024/10/09/ji-wang-xue-xi-bi-ji-yun-shu-ceng/"/>
      <url>/2024/10/09/ji-wang-xue-xi-bi-ji-yun-shu-ceng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h1><h2 id="1-概述与运输层服务"><a href="#1-概述与运输层服务" class="headerlink" title="1.概述与运输层服务"></a>1.概述与运输层服务</h2><h3 id="1-传输服务和协议"><a href="#1-传输服务和协议" class="headerlink" title="1.传输服务和协议"></a>1.传输服务和协议</h3><p><strong>运输层</strong>的目的是为不同主机上的<strong>进程</strong>提供<strong>逻辑通信</strong></p><p>运输层协议<strong>运行在端系统</strong></p><ul><li>发送方在运输层将应用层报文封装成<strong>报文段</strong>，再传输给网络层</li><li>接收方在运输层将<strong>报文段</strong>重组成报文，再传输给应用层</li></ul><p>存在多个运输层协议，<strong>Internet：TCP、UDP</strong></p><blockquote><p>需要注意，有的教材称呼TCP协议封装的是<strong>TCP报文段</strong>，UDP协议封装的是<strong>UDP数据报</strong>，这种称呼是可以的，但&lt;自顶向下&gt;将TCP和UDP封装的包<strong>统称为报文段</strong></p></blockquote><h3 id="2-传输层vs网络层"><a href="#2-传输层vs网络层" class="headerlink" title="2.传输层vs网络层"></a>2.传输层vs网络层</h3><ul><li>网络层服务：<strong>主机间</strong>的逻辑通信</li><li>运输层服务：<strong>进程间</strong>的逻辑通信</li></ul><h3 id="3-运输层协议数据封装"><a href="#3-运输层协议数据封装" class="headerlink" title="3.运输层协议数据封装"></a>3.运输层协议数据封装</h3><blockquote><p>为什么运输层协议封装的包叫报文<strong>段</strong>？实际上，运输层将应用层报文进行了<strong>分段</strong></p></blockquote><p><strong>为什么需要数据分段？</strong></p><ul><li><strong>TCP</strong>具有<strong>最大报文长度</strong>(MSS)，注意：<strong>MSS指的是TCP报文段中的应用层报文部分(即载荷部分)，不包括头部</strong></li><li><strong>UDP</strong>不会分段，如果长度超过<strong>MTU</strong>，会在网络层对<strong>IP数据报</strong>分片</li></ul><p><strong>最大传输单元(MTU)</strong>——<strong>最大链路层帧长度</strong>(以太网的是1500字节)</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241009103212169.png" alt="image-20241009103212169"></p><h3 id="4-因特网运输层协议"><a href="#4-因特网运输层协议" class="headerlink" title="4.因特网运输层协议"></a>4.因特网运输层协议</h3><p><strong>可靠、保序的传输：TCP</strong>：</p><ul><li>多路复用、分解(解复用)</li><li>拥塞控制</li><li>流量控制</li><li>建立连接</li></ul><p><strong>不可靠、不保序的传输：UDP</strong>：</p><ul><li>多路复用、分解(解复用)</li><li>无额外服务</li></ul><p><strong>都不提供的服务</strong>：</p><ul><li>时延保证</li><li>带宽保证</li></ul><hr><h2 id="2-复用与分解"><a href="#2-复用与分解" class="headerlink" title="2.复用与分解"></a>2.复用与分解</h2><p>多路复用与多路分解将由网络层提供的<strong>主机到主机</strong>的交付服务(ICMP，网络层协议)，延伸到<strong>进程到进程</strong>的交付服务</p><ul><li>通过<strong>套接字Socket</strong>实现</li></ul><blockquote><p>注意，使用socket的目的是为了让层间通信的信息<strong>最少化</strong></p><p>socket本身就是一个整数而已，只是socket捆绑了一个二元组&#x2F;四元组表(可以认为socket是一个索引)</p></blockquote><p><strong>多路复用：</strong></p><ul><li>在<strong>发送方主机</strong>多路复用</li><li>从<strong>多个套接字</strong>接收来自不同进程的报文，分别封装后<strong>统一</strong>传递给网络层(<em>多路——&gt;一路</em>)</li></ul><p><strong>多路分解：</strong></p><ul><li>在<strong>接收方主机</strong>多路分解</li><li>从网络层接收<strong>一个由多个报文段组成的数据包</strong>，根据IP和端口(TCP、UDP有区别，基于其socket)分别传递给<strong>对应的多个套接字</strong></li></ul><h3 id="1-UDP复用与分解"><a href="#1-UDP复用与分解" class="headerlink" title="1.UDP复用与分解"></a>1.UDP复用与分解</h3><blockquote><p>需要注意的一点是，使用UDP传输协议时，<strong>应用层向运输层传输</strong>的信息包括：</p><ul><li>报文Message</li><li>UDP socket(捆绑着二元组(源IP，源port))</li><li><code>dicad</code>(目标IP，目标port的结构体指针)</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241009104406903.png" alt="image-20241009104406903"></p><p><strong>UDP报文段的格式如上</strong></p><p>UDP封装时，将<strong>源端口号</strong>和<strong>目的端口号</strong>封装在UDP报文段的<strong>头部</strong></p><ul><li><strong>源IP地址</strong>和<strong>目的IP地址</strong>是在<strong>网络层封装</strong></li></ul><p><strong>一个完整的使用UDP协议的链路层帧的格式如下</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241009104733464.png" alt="image-20241009104733464"></p><blockquote><p>这里我们需要回顾一下UDP socket(在应用层-层间协议socket节详细讲解过)：UDP socket是一个二元组**(源IP， 源port)**</p></blockquote><p>因此，在接收端，UDP socket是根据<strong>二元组：源IP和源port</strong>来识别报文段的(接收端的”源” &#x3D; 发送端的”目的”)</p><ul><li>当主机收到UDP报文段：<ul><li>检查报文段的目的port</li><li>用该端口号将报文段定位给套接字</li></ul></li><li>如果两个<strong>不同</strong>源IP&#x2F;源port的数据报，但是有<strong>相同的目的IP和目的port</strong>，则<strong>会被定位到相同的UDP套接字</strong><ul><li>那么该如何区分？</li><li>上面的使用UDP协议的链路层帧说明，源IP和源端口号是存在于IP数据报首部和UDP报文段首部的，<strong>由操作系统提取出来给到应用层做区分</strong></li></ul></li></ul><h3 id="2-TCP复用与分解"><a href="#2-TCP复用与分解" class="headerlink" title="2.TCP复用与分解"></a>2.TCP复用与分解</h3><blockquote><p>需要注意的一点是，使用UDP传输协议时，<strong>应用层向运输层传输</strong>的信息包括：</p><ul><li>报文Message</li><li>TCP socket(捆绑着四元组(源IP，目标IP，源port，目标port))</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241009105638812.png" alt="image-20241009105638812"></p><p><strong>TCP报文段的格式如上</strong></p><p>TCP封装时，也是将<strong>源端口号</strong>和<strong>目的端口号</strong>封装在TCP报文段的<strong>头部</strong></p><ul><li><strong>源IP地址</strong>和<strong>目的IP地址</strong>是在<strong>网络层封装</strong></li></ul><p><strong>一个完整的使用TCP协议的链路层帧的格式如下</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241009105742149.png" alt="image-20241009105742149"></p><blockquote><p>回顾TCP socket可以看到，TCP socket对应一个<strong>四元组</strong>：<strong>(源IP，源port，目的IP，目的port)</strong></p></blockquote><p>在接收端主机，TCP socket是根据<strong>四元组</strong>来识别报文段的。</p><p>服务器主机可能支持许多并行的TCP套接字</p><ul><li>每个套接字由其自己的四元组标识</li></ul><p>Web服务器对每个连接的客户机具有不同的套接字</p><ul><li>非持久HTTP将为每个请求具有不同的套接字</li></ul><h4 id="多线程Web服务器"><a href="#多线程Web服务器" class="headerlink" title="多线程Web服务器"></a>多线程Web服务器</h4><blockquote><p>当今高性能Web服务器通常<strong>只使用一个进程</strong>，但为每个新的客户连接创建一个<strong>具有新连接套接字的新线程</strong></p></blockquote><p>连接套接字与进程之间<strong>并非一一对应</strong>的关系</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241009110200513.png" alt="image-20241009110200513"></p><hr><h2 id="3-UDP"><a href="#3-UDP" class="headerlink" title="3.UDP"></a>3.UDP</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>UDP，全称<strong>用户数据报协议</strong>，是无连接、不可靠服务协议的一种</p><ul><li>“尽力而为”的服务，报文 段可能<ul><li>丢失</li><li>送到应用进程的报文段乱序</li></ul></li><li>无连接：<ul><li>UDP发送端和接收端之间没有握手</li><li>每个UDP报文段都被独立地处理</li></ul></li></ul><p>UDP被用于：</p><ul><li>流媒体</li><li>DNS</li><li>SNMP</li></ul><p><strong>当然，在UDP上也是可以进行可靠传输的：</strong></p><ul><li>应用层<strong>增加可靠性</strong></li><li>使用特定的<strong>差错回复</strong></li></ul><blockquote><p>为何要有 UDP协议? </p><ul><li>无连接创建(它将增加时延) </li><li>简单：在发送方、接收方无连接状态</li><li>段首部小</li><li>无拥塞控制: UDP能够尽可能快地传</li></ul></blockquote><h3 id="2-UDP报文段格式"><a href="#2-UDP报文段格式" class="headerlink" title="2.UDP报文段格式"></a>2.UDP报文段格式</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241009104406903.png" alt="image-20241009104406903"></p><ul><li><strong>UDP长度：<strong>UDP报文段的<em>字节数</em>，包括</strong>头部</strong>，<strong>头部长度&#x3D;8字节</strong></li></ul><h3 id="3-UDP校验和-EDC"><a href="#3-UDP校验和-EDC" class="headerlink" title="3.UDP校验和(EDC)"></a>3.UDP校验和(EDC)</h3><blockquote><p><strong>重点！</strong></p></blockquote><p>**目的：**检测被传输报文中的差错(如比特翻转)</p><p><strong>发送方：</strong></p><ul><li>将报文段的整个内容(包括首部)视为16比特的整数<ul><li><strong>从前向后</strong>划分16位(0-15位是第一个整数，16-31位是第二个…)</li><li>检验和先每位用0替代，检验和长度是可以预知的，故UDP长度也可以计算出</li></ul></li><li>校验和：报文段的加法和(具体计算见下)</li></ul><p><strong>接收方：</strong></p><ul><li>接收方再去计算校验和，与报文段中的校验和字段作比较</li><li>如果不相等——检查到差错</li><li>如果相等——<strong>可能</strong>没差错<ul><li>如果比特翻转了2次呢？恰好结果没错，但本身数据已经改变</li></ul></li></ul><h4 id="1-计算"><a href="#1-计算" class="headerlink" title="1.计算"></a>1.计算</h4><p>16位整数相加——<strong>最高位进位回卷</strong>(末尾+1)——取<strong>反码</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241009112102847.png" alt="image-20241009112102847"></p><p><code>校验范围+校验和=1111111111</code>是什么？</p><p><strong>这是正规的目标端校验规则</strong></p><ul><li><p>在目标端<strong>重新计算</strong>校验和时，是把报文段中的<strong>校验和字段</strong>也算进去的(而不是源端将校验和字段先全置0计算)</p></li><li><p>因此可以发现，目标端计算的校验和，就是是<strong>源端的校验和+源端校验和的反码</strong>，那么必然是<code>111111111</code></p></li><li><p>因此，实际上不需要什么所谓的<code>目标端校验和与源端校验和比较</code>，只要<strong>目标端校验和为全1</strong>，那么<strong>就是通过校验</strong></p></li></ul><h2 id="4-可靠数据传输"><a href="#4-可靠数据传输" class="headerlink" title="4.可靠数据传输"></a>4.可靠数据传输</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><p>可靠数据传输服务的实现是<strong>可靠数据传输协议(RDT)</strong></p><ul><li><code>rdt</code>在应用层、运输层和链路层都很重要</li><li><code>rdt</code>是网络Top10难题之一</li><li>下层倍道的不可靠特点决定了可靠数据传输协议<code>rdt</code>的复杂性</li></ul><blockquote><p>下图是应用层调用<code>rdt</code>协议发送数据，<code>rdt</code>调用不可靠服务传递<strong>分组</strong>的过程</p><ul><li>注意，这里我们用<strong>分组</strong>代替<strong>报文段</strong>的说法，因为除了因特网协议栈之外的其他协议栈也会使用可靠传输，而<strong>报文段</strong>只是因特网协议栈中运输层数据的称呼。因此我们使用<strong>分组</strong>这一更普遍的称呼</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011172133567.png" alt="image-20241011172133567"></p><p>因为可靠数据传输协议<code>rdt</code>的内容较为复杂，笔者这里采用渐进式的方式去介绍<code>rdt</code>协议</p><ul><li>注意：<ul><li>以下仅考虑单向数据传输，但实际上诸如TCP协议都是全双工的(也就是双向数据传输)</li><li>使用有限状态机(FSM)来描述发送方和接收方</li></ul></li></ul><h3 id="2-rdt1-0"><a href="#2-rdt1-0" class="headerlink" title="2.rdt1.0"></a>2.rdt1.0</h3><p><strong>rdt1.0，即在可靠信道上的可靠数据传输</strong></p><p>条件：<strong>下层的信道是完全可靠的</strong></p><ul><li>没有比特翻转</li><li>没有分组丢失</li></ul><h4 id="FSM"><a href="#FSM" class="headerlink" title="FSM"></a>FSM</h4><p>发送方与接收方的FSM：</p><blockquote><p>横线上方是条件，横线下方是动作</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011174043093.png" alt="image-20241011174043093"></p><p>发送方：上层调用<code>rdt_send</code>，需要发送数据</p><ul><li>将数据打包成分组</li><li>使用<code>udt_send</code>发送分组给接收方</li></ul><p>接收方：接收到分组，需要提取数据</p><ul><li>将分组解包，提取出数据</li><li>将数据发往上层</li></ul><h3 id="3-rdt2-0"><a href="#3-rdt2-0" class="headerlink" title="3.rdt2.0"></a>3.rdt2.0</h3><p><strong>rdt2.0，即具有比特差错信道的可靠数据传输</strong></p><p><strong>下层信道可能会出错</strong>：将分组中的比特翻转</p><ul><li>用校验和来检测比特差错</li></ul><p>问题：怎样从差错中<strong>恢复</strong>：</p><ul><li><strong>确认(ACK)</strong>：接收方显式地告诉发送方分组已被正确接收</li><li><strong>否定确认(NAK)</strong>: 接收方显式地告诉发送方分组发生了差错<ul><li>发送方收到NAK后，发送方重传分组</li></ul></li></ul><p><strong>rdt2.0中的新机制：采用差错控制编码进行差错检测</strong></p><ul><li>发送方差错控制编码、缓存</li><li>接收方使用编码检错</li><li>接收方的反馈：控制报文（ACK，NAK）：接收方→发送方</li><li>发送方收到反馈相应的动作</li><li><strong>注意，发送方报文需要差错检验，接收方的ACK&#x2F;NAK也需要差错检验</strong></li></ul><h4 id="1-FSM"><a href="#1-FSM" class="headerlink" title="1.FSM"></a>1.FSM</h4><p>rdt2.0的FSM如下：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011174817883.png" alt="image-20241011174817883"></p><p>发送方：</p><ul><li>上层需要发送数据<ul><li>数据和校验和打包成分组packet</li><li>udt_send</li></ul></li><li>如果接收到了回复，且回复为NAK<ul><li>重新发送分组</li></ul></li><li>如果接收到回复，且回复为ACK<ul><li>不进行操作，回到”等待上层调用”状态</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011174833924.png" alt="image-20241011174833924"></p><p>接收方：</p><ul><li>如果接收到分组且有比特差错：<ul><li>发送NAK分组</li></ul></li><li>如果接收到分组且无比特差错<ul><li>将分组中的数据解包发送给上层</li><li>返回ACK分组</li></ul></li></ul><h4 id="2-停等协议"><a href="#2-停等协议" class="headerlink" title="2.停等协议"></a>2.停等协议</h4><p><code>rdt2.0</code>协议有一个特点：<strong>当发送方处于等待 ACK或NAK的状态时，它不能从上层获得更多的数据</strong>。</p><p>我们将符合这种特征的协议统一命名为：<strong>停等协议(s-w协议)</strong></p><ul><li>满足特征：发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组</li></ul><h3 id="4-rdt2-1"><a href="#4-rdt2-1" class="headerlink" title="4.rdt2.1"></a>4.rdt2.1</h3><blockquote><p>rdt2.0看似完美，考虑到了发送端分组出现差错的可能，但其实有着很大的漏洞——它没有考虑<strong>ACK&#x2F;NAK分组受损</strong>的可能！</p></blockquote><p><code>rdt2.1</code>要解决的问题是：<strong>如何处理受损的ACK和NAK?</strong></p><ul><li>法一：增加足够的检验和比特。这样确实可以解决受损问题，但如果ACK&#x2F;NAK丢失了呢？</li><li>法二：重传当前的数据分组，引入<strong>冗余分组</strong>。但接收方怎么知道发送方传来的<strong>冗余分组</strong>是<strong>新分组</strong>还是<strong>重传</strong>？</li></ul><p><strong>rdt2.1采用了法二——重传</strong></p><p>为了解决重传存在的识别新旧问题，<code>rdt2.1</code>引入了新的机制：<strong>序号</strong></p><ul><li><p>让发送方对其数据分组编号，即：将发送数据分组的序号放在该字段。于是，接收方只需要检查序号即可确定收 到的分组是否一次重传</p></li><li><p>对于停等协议，**序号只需要1比特即可。**0、1翻转就代表一次新旧分组的变换</p></li></ul><h4 id="FSM-1"><a href="#FSM-1" class="headerlink" title="FSM"></a>FSM</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011180621622.png" alt="image-20241011180621622"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011180637505.png" alt="image-20241011180637505"></p><blockquote><p>具体的流程看FSM就可以理清楚，这里不多赘述</p><p>简单一点来说就是，发送方发Packet0给接收方，接收方检验无误且本身处于”等待packet0”状态时，返回ACK给发送方，自身进入”等待packet1”状态；如果ACK损坏，发送方会重发Packet0；接收方在”等待packet1”状态下接收到Packet0时，会丢掉这个重复的Packet0(因为它自己现在处于等P1的状态，所以P0是已经确认接受过的旧包了)，并再返回一个ACK给发送方</p></blockquote><p><strong>注意：<code>rdt2.1</code>协议中，接收方并不知道发送方是否正确收到了其ACK&#x2F;NAK，而是通过后续发送的是否是另一个序号的分组来间接判断的</strong></p><h3 id="5-rdt2-2"><a href="#5-rdt2-2" class="headerlink" title="5.rdt2.2"></a>5.rdt2.2</h3><p><code>rdt2.2</code>相比于<code>rdt2.1</code>的不同之处在于，它<strong>删除了NAK，使用带序号的ACK代替了NAK</strong></p><ul><li>一个很简单的逻辑：Packet n在接收端检测出比特差错，那么就返回给发送端一个ACK n-1(Packet n-1是OK的)。<ul><li>发送端就会说：欸，我明明发给你的是packet n，为啥你告诉我packet n-1你成功收到了？哦！你的意思就是说，packet n你没有正确收到！</li></ul></li></ul><h4 id="FSM-2"><a href="#FSM-2" class="headerlink" title="FSM"></a>FSM</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011192959080.png" alt="image-20241011192959080"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011193043180.png" alt="image-20241011193043180"></p><h3 id="6-rdt3-0"><a href="#6-rdt3-0" class="headerlink" title="6.rdt3.0"></a>6.rdt3.0</h3><blockquote><p>rdt1.0假设信道完全可靠，rdt2.x假设信道只会让分组受损(比特差错)，但实际上，分组还可能在信道上丢失</p></blockquote><p><strong>rdt3.0，又称比特交替协议，即：具有比特差错的丢包信道的可靠数据传输</strong></p><p>新的假设：下层信道可 能会丢失分组（数据 或ACK）</p><ul><li>会死锁(接收端等分组，发送端等ACK，都卡着不动了)</li><li><code>rdt2.2</code>的机制不足以处理这个情况：<ul><li>检验和</li><li>序列号分组</li><li>ACK带序号</li><li>重传</li></ul></li></ul><p><strong>方法：<strong>发送方等待ACK一段</strong>合理的时间(timeout)</strong></p><ul><li>发送端超时重传：如果到时没有 收到ACK-&gt;重传</li><li>问题：如果分组（或ACK ）只 是被延迟了：<ul><li>重传将会导致数据重复，但利用序列号分组已经可以处理这个问题</li><li>接收方必须指明被正确接收的序列号(利用带序号的ACK)</li></ul></li><li>需要一个倒计数定时</li></ul><blockquote><p>注意，链路层的timeout时间确定，而运输层的timeout时间是适应式的，会根据具体情况做分配</p></blockquote><h4 id="1-FSM-1"><a href="#1-FSM-1" class="headerlink" title="1.FSM"></a>1.FSM</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011194010139.png" alt="image-20241011194010139"></p><p>以上是<code>rdt3.0</code>发送方的FSM</p><p>需要特别注意的是，在为每个分组设置一个<strong>倒计数定时器</strong>后，如果ACK出现比特差错或者分组没有被接收方确认(ACK n-1)时，<strong>不需要当机立断重传</strong>，<strong>统一交给超时后的重传去处理</strong>，减少不必要的重复代码</p><p><code>rdt3.0</code>接收方的FSM和<code>rdt2.2</code>接收方的FSM相同，必要的条件和动作已经在<code>rdt2.2</code>中完成了</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011193043180.png" alt="image-20241011193043180"></p><h4 id="2-运行情况"><a href="#2-运行情况" class="headerlink" title="2.运行情况"></a>2.运行情况</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011194808109.png" alt="image-20241011194808109"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011194843486.png" alt="image-20241011194843486"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011194856055.png" alt="image-20241011194856055"></p><p>其中，最重要的就是第四种情况：<strong>过早超时&#x2F;延迟的ACK</strong></p><ul><li>在收到ACK 1前，packet1超时，重新发送pkt1，发完之后收到前一次pkt1的回复ACK 1</li><li>这就会导致，第二次发送完pkt1还没等到第二次发送的回复时，发送方就认为第二次的pkt1成功发送了就开始发pkt0，结果在<strong>发完pkt0之后收到第二次pkt1的回复—ACK 1</strong>，于是发送方理所当然的<strong>认为是pkt0没有成功确认</strong>，再重新发一次pkt0，以此类推</li><li>因此，这样会导致后面的所有分组<strong>都会发两次</strong>，所有的ACK<strong>也都会发两次</strong></li></ul><p>另外，如果发送方网络和接收方网络能够<strong>对报文进行重排</strong>，那么比特交替协议(<code>rdt3.0</code>)将**不能正确工作：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011202258922.png" alt="image-20241011202258922"></p><blockquote><p>这种时候，分组序列号只有0、1就不太合适了</p></blockquote><h4 id="3-性能"><a href="#3-性能" class="headerlink" title="3.性能"></a>3.性能</h4><p>rdt3.0能够工作，但性能不太好</p><p>例子: 1 Gbps（10^9 bit&#x2F;s）链路, 30ms往返传播时延(RTT)。发送 1KB分组所需时间：</p><p>$$T_{transmit} &#x3D; \frac{L(分组的比特长度)}{R(链路传输速率bps)} &#x3D; \frac{8k bit}{10^9 bps} &#x3D; 8 \mu s$$</p><p>$$U_{sender} &#x3D; \frac{\frac {L}{R}}{RTT + \frac{L}{R}} &#x3D; \frac{0.008}{0.008+30} &#x3D; 0.00027$$</p><ul><li><p>$U_{sender}$: 利用率，发送方用于发送时间的比率</p></li><li><p>每30 ms发送1KB 分组 -&gt; 经1 Gbps 链路有33KB&#x2F;sec 吞吐量</p></li><li><p>网络协议限制了物理资源的使用!</p></li></ul><p>其实就是，RTT整个30ms时间里，只有0.008ms是传输分组的(忙碌的)，剩下的时间都是<strong>空闲</strong>的，而且由于<strong>停等协议</strong>的缘故，一个RTT只有一个分组往返，<strong>非常非常浪费带宽</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011200433452.png" alt="image-20241011200433452"></p><h3 id="7-流水线协议"><a href="#7-流水线协议" class="headerlink" title="7.流水线协议"></a>7.流水线协议</h3><p><strong>流水线:</strong> 发送方允许发送<strong>多个</strong>、<strong>“传输中的”</strong>、<strong>还没有应答</strong>的分组</p><ul><li>因此，序号的<strong>范围必须增加</strong></li><li>发送方和接收方<strong>设有缓冲</strong></li></ul><p><strong>流水线协议的目的就在于：增加利用率</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011202707946.png" alt="image-20241011202707946"></p><p><strong>流水线协议有两种形式：</strong></p><ul><li><strong>回退N步</strong>(Go-Back-N)，简称<strong>GBN</strong></li><li><strong>选择性重传</strong>(Selective-Repeat)，简称<strong>SR</strong><ul><li><strong>GBN</strong>和<strong>SR</strong>都属于<strong>滑动窗口协议</strong></li></ul></li></ul><h3 id="8-滑动窗口协议"><a href="#8-滑动窗口协议" class="headerlink" title="8.滑动窗口协议"></a>8.滑动窗口协议</h3><ul><li><p>发送方和接收方都具有一定容量的<strong>缓冲区(即窗口)</strong>，允许发送端连续发送多个分组而不需要等待应答</p></li><li><p>发送窗口就是发送端允许连续发送的分组的序号表，发送端可以不等待应答而连续发送的最大分组数称为发送窗口的尺寸<strong>SW</strong></p></li><li><p>接收窗口是接收方允许接收的分组的序号表，凡落在接收窗口内的分组，接收方都必须处理，落在接收窗口外的分组被丢弃。接收方每次允许接收的分组数称为接收窗口的尺寸<strong>RW</strong></p><ul><li><strong>SW&#x3D;1, RW&#x3D;1——<code>rdt3.0</code></strong></li><li><strong>SW&gt;1, RW&#x3D;1——<code>GBN</code></strong></li><li><strong>SW&gt;1, RW&gt;1——<code>SR</code></strong></li></ul></li></ul><h4 id="1-发送窗口"><a href="#1-发送窗口" class="headerlink" title="1.发送窗口"></a>1.发送窗口</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011203331930.png" alt="image-20241011203331930"></p><ul><li>发送窗口(发送缓冲区)就是绿色底色的这一块区域，<strong>最大</strong>尺寸<strong>SW&#x3D;5</strong></li><li>红色的是<strong>已发送且已确认的分组</strong>，蓝色是<strong>已发送但未确认的分组</strong>，白色是<strong>未发送的分组</strong></li><li>发送窗口是由<strong>已发送但未确认的分组的序号构成的空间</strong>，其前后分别叫做<strong>前沿</strong>和<strong>后沿</strong>，<strong>两者的差值&#x3D;发送窗口尺寸</strong></li><li><strong>重点</strong>：<strong>只有位于发送窗口内的分组才允许被发送！！！！</strong></li></ul><p><strong>过程</strong>：</p><ul><li>一开始，没有发送任何分组<ul><li><strong>后沿&#x3D;&#x3D;前沿</strong></li><li>差值&#x3D;发送窗口尺寸&#x3D;0</li></ul></li><li><strong>前沿移动</strong><ul><li>每发送一个分组，<strong>前沿前移一个单位(上图就是右移)</strong></li><li>前沿<strong>不能超过</strong>发送缓冲区</li><li>当前后沿差值&#x3D;最大尺寸SW时，上层再想发送分组，发送窗口<strong>可以拒绝</strong>，必须等到发送窗口有分组确认(当然，一定是这几个中最老的那个，毕竟是顺序发送的，确认也是按顺序回来的)，才能有空(<strong>这属于后沿移动的内容了</strong>)</li></ul></li><li><strong>后沿移动</strong><ul><li>每收到一个老分组(后沿)的确认，<strong>后沿向前移动一位</strong>，发送缓冲区<strong>整体向前移动一位(在缓冲区已满的情况下)</strong></li><li>后沿<strong>不能超过前沿</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011204710769.png" alt="image-20241011204710769"></p><h4 id="2-接收窗口"><a href="#2-接收窗口" class="headerlink" title="2.接收窗口"></a>2.接收窗口</h4><p>接收窗口&#x3D;接收缓冲区</p><ul><li>接收窗口用于控制哪些分组可以接收<ul><li>只有收到的分组序号落入接收窗口内才允许接收</li><li>若序号在接收窗口之外，则丢弃</li></ul></li><li>接收窗口尺寸Wr&#x3D;1，则只能顺序接收</li><li>接收窗口尺寸Wr&gt;1 ，则可以乱序接收<ul><li>但提交给上层的分组，要按序<ul><li>这就是为什么说，TCP可靠传输不可或缺的原因——将失序抵达的报文重排列</li><li><code>rdt</code>的其中一个目的就是为了<strong>避免失序</strong></li></ul></li></ul></li></ul><h5 id="1-RW-1"><a href="#1-RW-1" class="headerlink" title="1.RW&#x3D;1"></a>1.RW&#x3D;1</h5><p>例子：Wr＝1，在0的位置；只有0号分组可以接收；向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃</p><ul><li>比如，现在0号分组、1号分组序列都接收了对应的分组，现在窗口在2号序列上</li><li>现在却接收到了3号分组，那么就<strong>舍弃3号分组</strong>，返回<strong>ACK 1</strong>(也就是返回<strong>已接收的、有序分组的、最大下标</strong>)</li></ul><p><strong>发送确认：</strong> </p><p><strong>接收窗口尺寸&#x3D;1</strong>——发送<strong>连续收到的最大的分组确认</strong>（<strong>累计确认</strong>）</p><blockquote><p>重点！！！接收窗口最大尺寸&#x3D;1时，发送端收到的确认信息是<strong>累计确认</strong></p><p>举个例子就是，收到的是<strong>ACK 4</strong>说明<strong>分组4以及分组4之前的所有分组都已按序确认收到</strong></p><ul><li>因此，如果收到了<strong>ACK 0</strong>，<strong>ACK 2</strong>，<strong>ACK 3</strong>，但没收到<strong>ACK1</strong>，没关系，后面的ACK已经帮忙确认了分组1已经收到，就不必重发了</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011204922968.png" alt="image-20241011204922968"></p><h5 id="2-RW-1"><a href="#2-RW-1" class="headerlink" title="2.RW&gt;1"></a>2.RW&gt;1</h5><p>接收窗口的滑动和发送确认</p><ul><li>滑动：<ul><li>低序号的分组到来，接收窗口移动，<strong>分组直接交付</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011210148783.png" alt="image-20241011210148783"></p><ul><li>高序号分组<strong>乱序</strong>到，<strong>缓存但不交付</strong>（因为要实现<code>rdt</code>，不允许失序），<strong>不滑动</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011210203517.png" alt="image-20241011210203517"></p><ul><li>发送确认：<ul><li>接收窗口尺寸&gt;1：收到分组，发送本分组的确认(<strong>非累计确认</strong>)</li></ul></li></ul><blockquote><p>重点！！！接收窗口最大尺寸&gt;1时，发送端收到的确认信息是<strong>非累计确认</strong></p><p>举例就是，收到<strong>ACK 4</strong>的确认时，<strong>仅仅</strong>代表<strong>分组4</strong>收到，不代表其他任何分组的确认</p></blockquote><h3 id="9-GBN"><a href="#9-GBN" class="headerlink" title="9.GBN"></a>9.GBN</h3><blockquote><p>GBN，Go-Back-N，回退N步</p></blockquote><p>发送方: </p><ul><li>“窗口”大小为N, 允许发送N个连续的没有应答分组<ul><li>基序号<code>base</code>：最小未确认的分组序号</li><li>下一个序号<code>nextseqnum</code>：最小未使用的分组序号</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011211403231.png" alt="image-20241011211403231"></p><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>发送窗口尺寸为N，接收窗口尺寸为1。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011211511709.png" alt="image-20241011211511709"></p><ul><li>简单来说：位于发送窗口内的分组才允许被发送，位于接收窗口内的分组才能被接收，<strong>关键是窗口如何滑动。</strong></li><li>特征：<strong>累计ACK</strong>，<strong>全部重传</strong><ul><li><strong>ACK(n)</strong>: 确认所有的（包括序号n）的分组 - “累计确认”</li><li>若超时，重传<strong>所有已发送但未被确认</strong>的分组</li></ul></li></ul><h4 id="2-FSM"><a href="#2-FSM" class="headerlink" title="2.FSM"></a>2.FSM</h4><p>发送方：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011211651857.png" alt="image-20241011211651857"></p><blockquote><p>需要注意的是：</p><ul><li>倒计数定时器是<strong>发送窗口中最老的已发送但未确认的分组的</strong>，<strong>仅有1个</strong></li><li>但如果这个定时器超时，则是<strong>整个已发送未确认分组</strong>重传</li></ul><p>因为接收窗口的尺寸&#x3D;1，所以收到的ACK一定是最老的分组，因此<strong>发送窗口前移</strong>，故而<strong>倒计数定时器重置</strong>，给到窗口中新的<strong>最老未确认分组</strong></p></blockquote><p>接收方：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011212116901.png" alt="image-20241011212116901"></p><ul><li>累积确认： 对正确接收的分组总是发送具有最高按序序号的ACK<ul><li>可能产生冗余的ACKs</li><li>仅仅<strong>需要记住期望的序号值</strong>(<code>expectedseqnum</code>)，也就是接收窗口对应的序号表的某个序号值</li></ul></li><li>对失序的分组: <ul><li>丢弃 (不缓存) -&gt; 没有接收缓冲区! </li><li>重发<strong>已按序接收到的分组的最高序号ACK</strong></li></ul></li></ul><h4 id="3-示意"><a href="#3-示意" class="headerlink" title="3.示意"></a>3.示意</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011212336689.png" alt="image-20241011212336689"></p><h4 id="4-a-funny-question"><a href="#4-a-funny-question" class="headerlink" title="4.a funny question"></a>4.a funny question</h4><blockquote><p>GBN协议，发送方已经发送了编号为0~7的分组 。当计时器超时时，若发送方只收到0、2、3号帧 的确认，则发送方需要重发的帧数是？</p></blockquote><ul><li>能正常收到<code>ACK 2</code>、<code>ACK 3</code>的确认，说明接收方也收到了<code>pkt 1</code>，否则接收窗口不会前移到序号2、3，仅仅只是<code>ACK 1</code>丢失了而已</li><li>因此，当前接收窗口没有卡在序号1上</li><li>而因为发送方已经发送了分组0-7，所以问题就出在：<strong>分组4应该是丢失了，没有被接收方收到</strong>，导致<strong>接收窗口卡在了序号4上</strong></li><li>又因为GBN要求，重传是<strong>重传所有已发送未确认的分组</strong>，而0-7分组都发送了，0-3分组已确认</li><li>所以需要重发的是分组4、5、6、7，<strong>共计4帧！</strong></li></ul><h3 id="10-SR"><a href="#10-SR" class="headerlink" title="10.SR"></a>10.SR</h3><blockquote><p>SR，Selective-Repeat，发送方选择性重传</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011213405093.png" alt="image-20241011213405093"></p><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>发送窗口尺寸为N，接收窗口尺寸为N</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011213436624.png" alt="image-20241011213436624"></p><ul><li><strong>特征：独立ACK，重传单个分组</strong><ul><li>独立ACK：对每个分组使用单独的确认</li><li>需要N个定时器，若某个分组超时，则<strong>单独重传</strong>该分组</li><li>接收窗口为N，对<strong>乱序到达的分组</strong>进行<strong>缓存</strong>，等到按序接收好再上传<ul><li>比如，窗口里有2，3，4，5，收到3，4不能传，3，4，5也不能传，必须是带上最老的分组，比如2，3能传，2，3，4能传</li><li>具体见第8小节</li></ul></li></ul></li></ul><p><strong>发送方：</strong></p><ul><li><p><strong>上层传来数据 :</strong> </p><ul><li>如果窗口中下一个序号可用, 发送报文段</li></ul></li><li><p><strong>timeout(n):</strong> </p><ul><li>重传分组n, 重启其计时器</li></ul></li><li><p><strong>ACK(n) 在 [sendbase,sendbase+N-1]:</strong> </p><ul><li><p>标记分组 n 已经收到</p></li><li><p>如果n 是最小未收到应答的分组(就是最老的)，向前滑动窗口base指针到下一个未确认序号</p></li></ul></li></ul><p><strong>接收方：</strong></p><ul><li><strong>分组n在 [rcvbase, rcvbase+N-1]</strong> <ul><li>发送 ACK(n)</li><li>失序(乱序): <strong>缓存</strong> </li><li>按序: <strong>交付 (也交付所有缓存的按序分组)</strong>,向前滑动窗口到 下一个未收到报文段的序号</li></ul></li><li><strong>分组n在[rcvbase-N,rcvbase-1]</strong> <ul><li>ACK(n)</li></ul></li><li>其他: <ul><li>忽略</li></ul></li></ul><h4 id="2-示意"><a href="#2-示意" class="headerlink" title="2.示意"></a>2.示意</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011214312560.png" alt="image-20241011214312560"></p><h4 id="3-困境"><a href="#3-困境" class="headerlink" title="3.困境"></a>3.困境</h4><blockquote><p>选择重传会有一个问题：如果窗口过大，难以区分新分组和重传分组</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241011214502778.png" alt="image-20241011214502778"></p><p><strong>对于SR协议，以及所有的滑动窗口协议，发送窗口+接收窗口长度之和小于等于序号空间</strong></p><ul><li>只有这样，才能避免上面的问题</li></ul><h3 id="11-A-Question"><a href="#11-A-Question" class="headerlink" title="11.A Question"></a>11.A Question</h3><blockquote><p>对于滑动窗口协议，如果分组序号采用3比特编号，发送窗口大小是5，则接收窗口最大是多少？</p></blockquote><ul><li><strong>对于滑动窗口协议，发送窗口+接收窗口长度和必须小于等于序号空间</strong></li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">分组序号3bit编码——序号空间=2^3=8发送窗口=5接收窗口&lt;=8-5=3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="5-TCP"><a href="#5-TCP" class="headerlink" title="5.TCP"></a>5.TCP</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>点对点：<ul><li>一个发送方，一个接收方</li></ul></li><li>可靠的、按顺序的字节流：<ul><li>没有报文边界</li></ul></li><li>管道化（流水线）：<ul><li>TCP拥塞控制和流量控制设置 窗口大小</li></ul></li><li>发送和接收缓存</li><li>全双工数据：<ul><li>在同一连接中数据流双向 流动</li><li>MSS：最大报文段大小</li></ul></li><li>面向连接：<ul><li>在数据交换之前，通过握手(交换控制报文)初始化发送方、接收方的状态变量</li></ul></li><li>有流量控制：<ul><li>发送方不会淹没接收方</li></ul></li></ul><h3 id="2-TCP报文段结构"><a href="#2-TCP报文段结构" class="headerlink" title="2.TCP报文段结构"></a>2.TCP报文段结构</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241018142354064.png" alt="image-20241018142354064"></p><ul><li>首部长度：4bit首部长度字段，指示了32bit的字为单位的TCP首部长度<ul><li>例如，首部长度字段&#x3D;0101<ul><li>首部长度&#x3D;5*32&#x3D;160bit&#x3D;20Byte</li></ul></li><li><strong>TCP首部长度一般就是20字节(忽略可选项的时候)</strong></li><li><strong>UDP首部长度为8字节</strong></li></ul></li><li>接收窗口：16bit接收窗口字段<code>rwnd</code>，即接收方的接收窗口大小<ul><li>接收窗口<code>rwnd</code>是必须发给对方的，因为是进行流量控制、限制对方的</li><li>拥塞窗口<code>cwnd</code>是不会发给对方的，因为是用来进行拥塞控制、监控网络流量、限制发送方自己的</li></ul></li></ul><h3 id="3-序号-确认号"><a href="#3-序号-确认号" class="headerlink" title="3.序号&amp;确认号"></a>3.序号&amp;确认号</h3><p><strong>序号(Sequence Number)</strong>：</p><ul><li>序号并不是RDT中定义的分组”序号”，而是<strong>字节序号</strong></li><li>运输层以<strong>MSS</strong>大小将应用层报文划分成多个<strong>MSS</strong>大小的数据包作为运输层报文段的载荷(<strong>SDU</strong>)，也就是，每个运输层报文段的载荷(SDU)都是应用层报文中<strong>MSS</strong>大小的内容，如下图所示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/5851c644856529ac00cd5d61c5038a6.jpg" alt="5851c644856529ac00cd5d61c5038a6"></p><ul><li>因此，<strong>序号</strong>&#x3D;<strong>运输层报文段的载荷首字节在字节流中的编号</strong><ul><li>如下图的红色所示，序号<strong>不一定从0开始，由发送方指定</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/47b92cbd9909f70a0b745ffe522c700.jpg" alt="47b92cbd9909f70a0b745ffe522c700"></p><p><strong>确认号(ACK Number)：</strong></p><ul><li>期望从另一方收到的下一字节的序号</li><li>确认号&#x3D;ACK n，表示已收到n-1序号及以前的报文段</li><li>例如，<strong>确认号&#x3D; ACK 555</strong>，那么表示接收方收到了<strong>序号554及以前的所有报文段</strong>，希望收到从<strong>序号555开始的报文段</strong></li><li><strong>累积确认</strong></li></ul><p><strong>接收方如何处理乱序的报文段？——没有规定，由</strong></p><blockquote><p>下图为序号与确认号的示例</p><p>发送方A的序号&#x3D;42，ACK&#x3D;79，data&#x3D;’c’(一个字节)</p><p>则表示希望接收方从序号79开始发送</p><p>发送方B的序号&#x3D;79，ACK&#x3D;43，data&#x3D;’c’</p><p>既满足了发送方A的需求，即从序号79开始发送，又希望发送方A从序号43开始发送(42已经收到了，就是’c’)</p><p><strong>可以看到，序号是由发送方约定的，不是默认从0开始的</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241018144308960.png" alt="image-20241018144308960"></p><h3 id="4-往返延时与超时"><a href="#4-往返延时与超时" class="headerlink" title="4.往返延时与超时"></a>4.往返延时与超时</h3><p>怎样设置TCP 超时？</p><ul><li>比RTT要长<ul><li>但RTT是变化的</li></ul></li><li>太短：太早超时<ul><li>不必要的重传</li></ul></li><li>太长：对报文段丢失反应太慢，消极</li><li><strong>因此需要根据当前RTT与历史RTT动态设置超时</strong></li></ul><p>怎样估计RTT？</p><ul><li><code>SampleRTT</code>：测量从报文段发出到收到确认的时间<ul><li>如果有重传，忽略此次测量</li></ul></li><li><code>SampleRTT</code>会变化，因此估计的 RTT应该比较平滑<ul><li>对几个最近的测量值求平均，而 不是仅用当前的<code>SampleRTT</code></li></ul></li></ul><h4 id="1-EstimateRTT"><a href="#1-EstimateRTT" class="headerlink" title="1.EstimateRTT"></a>1.EstimateRTT</h4><blockquote><p><code>EstimateRTT</code>，即平均<code>SampleRTT</code></p></blockquote><p>$$EstimateRTT &#x3D; (1- \alpha) \cdot EstimateRTTT + \alpha \cdot SampleRTT$$</p><ul><li>指数加权移动平均</li><li>过去样本的影响呈指数衰减</li><li>推荐值$\alpha&#x3D;0.125$</li></ul><h4 id="2-DevRTT"><a href="#2-DevRTT" class="headerlink" title="2.DevRTT"></a>2.DevRTT</h4><blockquote><p><code>DevRTT</code>，即衡量<code>SampleRTT</code>与平均量<code>EstimateRTT</code>的类均方差</p></blockquote><p>设置超时：</p><ul><li><code>EstimtedRTT</code> + 安全边界时间<ul><li><code>EstimatedRTT</code> 大 (方差大)→较大的安全边界时间</li></ul></li><li><code>SampleRTT</code>会偏离<code>EstimatedRTT</code>多</li></ul><p>$$DevRTT &#x3D;  (1- \beta) \cdot DevRTT + \beta \cdot (SampleRTT - EstimateRTT)$$</p><ul><li>推荐值$\beta&#x3D;0.25$</li></ul><h4 id="3-超时时间设置"><a href="#3-超时时间设置" class="headerlink" title="3.超时时间设置"></a>3.超时时间设置</h4><p>$$TimeOutInterval &#x3D; EstimateRTT + 4 \cdot DevRTT$$</p><h3 id="5-可靠数据传输"><a href="#5-可靠数据传输" class="headerlink" title="5.可靠数据传输"></a>5.可靠数据传输</h3><ul><li>TCP在IP不可靠服务的基础上建立了<code>rdt</code><ul><li>管道化的报文段 <ul><li>GBN or SR的特性在TCP传输中都有体现</li></ul></li><li>累积确认（像GBN）</li><li>单个重传定时器（像GBN）</li><li>是否可以接受乱序的，没有规范</li></ul></li><li>通过以下事件触发重传<ul><li>超时（<strong>只重发那个最早的未确认段</strong>：SR）</li><li>重复的确认<ul><li>例子：收到了ACK50,之后又收到3个ACK50</li></ul></li></ul></li></ul><h4 id="1-发送方FSM"><a href="#1-发送方FSM" class="headerlink" title="1.发送方FSM"></a>1.发送方FSM</h4><p>TCP发送方的FSM如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241018150758353.png" alt="image-20241018150758353"></p><p><strong>发送方事件</strong></p><p><strong>从应用层接收数据：</strong></p><ul><li>用<code>nextseq</code>创建报文段<ul><li>序号<code>nextseq</code>为报文段首字节的字节流编号</li></ul></li><li>如果还没有运行，启动定时器<ul><li>定时器与最早未确认的报文段关联</li><li>过期间隔： <code>TimeOutInterval</code></li></ul></li></ul><p><strong>超时：</strong></p><ul><li><p>重传后沿<strong>最老的报文段(序号最小)</strong>，也就是<strong>只传送具有最小序号的未确认分组</strong></p><ul><li>与SR类似</li></ul></li><li><p>重新启动定时器</p></li></ul><p><strong>收到确认：</strong></p><ul><li>如果是对尚未确认的报文段确认<ul><li>更新已被确认的报文序号<ul><li><code>SendBase = y</code></li></ul></li><li>如果当前还有未被确认的报文段，重新启动定时</li></ul></li></ul><h4 id="2-发送方代码"><a href="#2-发送方代码" class="headerlink" title="2.发送方代码"></a>2.发送方代码</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241018153320477.png" alt="image-20241018153320477"></p><h4 id="3-TCP重传"><a href="#3-TCP重传" class="headerlink" title="3.TCP重传"></a>3.TCP重传</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241019102723458.png" alt="image-20241019102723458"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241019102817399.png" alt="image-20241019102817399"></p><h4 id="4-接收方ACK"><a href="#4-接收方ACK" class="headerlink" title="4.接收方ACK"></a>4.接收方ACK</h4><table><thead><tr><th>接收方的事件</th><th>TCP接收方动作</th></tr></thead><tbody><tr><td>所期望序号的报文段按序到达。 所有在期望序号及以前的数据都已经被确认</td><td>延迟的ACK。对另一个按序报文段的到达最多等待500<code>ms</code>。如果下一个按序报文段在这个时间间隔内没有到达， 则发送一个ACK</td></tr><tr><td>有期望序号的报文段按序到达。 前一个按序报文段等待发送ACK</td><td>立即发送单个累积ACK，以确认两个按序报文段</td></tr><tr><td>比期望序号大的失序报文段到达，检测出数据流中的间隔。</td><td>立即发送冗余ACK，指明下一个期待字节的序号（也就是间隔的低端字节序号）</td></tr><tr><td>部分或者完全填充已接收到数据间隔的报文段到达</td><td>倘若该报文段起始于间隔的低端(也就是紧随着已确认的最高序号报文段)，则立即发送ACK</td></tr></tbody></table><h4 id="5-快速重传"><a href="#5-快速重传" class="headerlink" title="5.快速重传"></a>5.快速重传</h4><blockquote><p>由于超时周期往往太长(<code>TimeOutInterval</code>)，在重传丢失报文段之前有较长时延，<strong>因此必须有措施来降低时延</strong>，最好的办法就是<strong>检测到丢失后立刻重传</strong></p></blockquote><ul><li>通过<strong>冗余ACK</strong>来检测报文段丢失<ul><li>发送方通常连续发送大量报文段</li><li>如果报文段丢失，通常会引起多个重复的ACK</li><li>下图就是一个很好的示例，序号50的报文段丢失了，接收方直接跳过50收到的60、70、80序号的报文段，那么就会发送ACK 50来提示发送方，我按序接收到的最后一个报文段是40，希望收到的下个报文段序号为50(GBN特性+TCP ACK性质)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241019104535747.png" alt="image-20241019104535747"></p><ul><li>如果<strong>发送方收到同一数据的3个冗余ACK(Dup ACK, duplicate重复)</strong>，重传最小序号的段(SR)<ul><li>快速重传：在<strong>定时器过时之前重发</strong>报文段</li><li>它假设跟在被确认的数据后面的数据丢失了<ul><li>第一个ACK是正常的</li><li>收到第二个该段的ACK，表 示接收方收到一个该段后的乱序段</li><li>收到第3，4个该段的ack，表 示接收方收到该段之后的2个，3个乱序段，可能性非常大——段丢失了</li></ul></li></ul></li></ul><p><strong>示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241019105227294.png" alt="image-20241019105227294"></p><p><strong>算法：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241019105354910.png" alt="image-20241019105354910"></p><h3 id="6-流量控制"><a href="#6-流量控制" class="headerlink" title="6.流量控制"></a>6.流量控制</h3><blockquote><p>TCP连接的接收方有一个<strong>接收缓冲区</strong>，流量控制的目的就在于由接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区<strong>溢出</strong>(溢出的分组默认<strong>丢弃</strong>)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241019111107258.png" alt="image-20241019111107258"></p><ul><li>上图就是<strong>TCP接收方的接收缓冲区<code>RcvBuffer</code></strong>，其中<code>RcvWindow</code>就是缓冲区中的<strong>空闲空间</strong></li></ul><p><strong>流量控制原理：</strong></p><ul><li>接收方在其向发送方的<strong>TCP段头部的<code>rwnd</code>字段</strong>“通告”其<strong>空闲buffer大小(即<code>RcvWindow</code>)</strong><ul><li><code>RcvBuffer</code>大小通过socket选项设置 (典型默认大小为4096 字 节)</li><li>很多操作系统自动调整<code>RcvWindow</code><ul><li>$RcvWindow &#x3D; RcvBuffer - [LastByteRcvd - LastByteRead]$</li><li><strong>最后已接收字节-最后已读取字节(app从buffer中拿走读取) &#x3D; 缓冲区中已有的TCP段字节数</strong></li></ul></li></ul></li><li>发送方限制未确认(<code>“in-flight”</code>)字节的个数≤接收方发送过来的值 <ul><li>$LastByteSend - LastByteAcked &lt;&#x3D; RcvWindow$</li><li><strong>最后已发送字节-最后已确认字节 &#x3D; 已发送但未确认的字节数 &lt;&#x3D; 接收方缓冲区空闲空间</strong></li></ul></li><li>保证接收方不会被淹没</li></ul><h3 id="7-连接管理"><a href="#7-连接管理" class="headerlink" title="7.连接管理"></a>7.连接管理</h3><blockquote><p>TCP的传输连接包括三个状态：</p><ul><li><strong>连接建立</strong></li><li><strong>数据传输</strong></li><li><strong>连接释放</strong></li></ul></blockquote><h4 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1.建立连接"></a>1.建立连接</h4><p>TCP建立连接有<strong>3次握手</strong></p><ul><li>第一次握手：连接请求报文(SYN)<ul><li>客户机向服务器发送</li><li>SYN&#x3D;1</li><li>指定初始序号($X$)，无数据</li></ul></li><li>第二次握手：握手确认报文(SYN, ACK)<ul><li>服务器向客户端发送</li><li>SYN&#x3D;1</li><li>服务器为该连接分配缓冲区和变量</li><li>指定服务器初始序号($Y$)</li></ul></li><li>第三次握手：确认报文(ACK)<ul><li>客户机向服务器发送</li><li><strong>SYN&#x3D;0</strong></li><li><strong>第三次握手的报文既包含连接确认，又包含HTTP请求</strong></li></ul></li><li>需要注意的是，<strong>SYN标记位每次连接只能使用一次</strong>，即客户机只有连接请求报文段中SYN&#x3D;1，服务器也只有握手确认报文段中SYN&#x3D;1，确认报文中SYN&#x3D;0</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241019112637759.png" alt="image-20241019112637759"></p><h4 id="2-释放连接"><a href="#2-释放连接" class="headerlink" title="2.释放连接"></a>2.释放连接</h4><p>TCP释放连接有<strong>4个步骤</strong></p><ul><li>步骤一：<strong>客户机向服务器发送TCP FIN控制报文段</strong><ul><li>客户机向服务器发送</li><li>FIN标记位&#x3D;1</li></ul></li><li>步骤二：<strong>服务器收到FIN，用ACK回答；关闭连接，发送FIN</strong><ul><li>服务器向客户机发送</li><li>服务器收到FIN，用ACK回答</li><li>关闭连接</li></ul></li><li>步骤三：<strong>客户机收到FIN，用ACK回答</strong><ul><li>客户机在收到步骤二的服务器回答ACK后，进入<strong>超时等待</strong>：<ul><li>将要对接收到的服务器的FIN进行确认ACK回答</li></ul></li></ul></li><li>步骤四：<strong>服务器接收ACK，连接关闭</strong></li><li>需要注意：<ul><li><code>FIN</code>标记位和<code>SYN</code>标记位同理，<strong>一次连接中双方只能用一次</strong></li><li>如果步骤四中，服务器没有收到ACK，Server会重发步骤二中的FIN</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241019113551106.png" alt="image-20241019113551106"></p><h4 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h4><p><strong>TCP客户机生命周期</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/5c9bb251a79a42b89001e1349a40d68.png" alt="5c9bb251a79a42b89001e1349a40d68"></p><p><strong>TCP服务器生命周期</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/1584a67c8a1865ba71851412788e105.png" alt="1584a67c8a1865ba71851412788e105"></p><h3 id="8-Questions"><a href="#8-Questions" class="headerlink" title="8.Questions"></a>8.Questions</h3><blockquote><p>使用HTTP协议访问，发送的HTTP文件大小为1MSS，包含一个大小为3MSS的图片，与对应服务器的RTT&#x3D;10ms，此时已完成域名解析，求从TCP连接到完整收到内容所需时间：</p></blockquote><ul><li><p>已完成域名解析——已知Server IP，可直接建立连接</p></li><li><p>建立连接、握手确认、确认报文+HTTP文件请求——3次握手，共计2次往返(2*RTT)</p></li><li><p>获得HTTP文件后，发现还要一个图片对象——发送图片对象请求</p></li><li><p>HTTP请求首先会请求图片资源，服务器在知道资源大小后，会<strong>分段发送给客户端</strong></p><ul><li><strong>图片请求只有1次，后续收到图片的部分，都是发的ACK</strong></li></ul></li><li><p>又因为TCP报文段的最大长度是1MSS，所以服务器一次只能发送图片的1&#x2F;3</p></li><li><p>因此，这里的图片对象的获取<strong>需要3个RTT</strong></p><ul><li><strong>题目没有明确提及拥塞控制，就不要考虑</strong></li></ul></li></ul><p>$$Time &#x3D; 2<em>RTT(建立连接+获取HTTP对象) + 3</em>RTT(获取图片对象) &#x3D; 50ms$$</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/1ec3622d627cf2a209f9ef5469e6b14.jpg" alt="1ec3622d627cf2a209f9ef5469e6b14"></p><blockquote><p>下图是抓取到的实际TCP报文段，解释下各个字段的含义</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241019121438719.png" alt="image-20241019121438719"></p><ul><li>Seq：序号</li><li>Win：窗口，更准确的说，是<code>RcvWindow</code>，即接收方的接收窗口大小(空闲空间)</li><li>Len：报文段的载荷(SDU)大小，也即携带的应用层报文大小。</li><li>MSS：TCP最大报文段大小，取决于MTU与机器本身</li><li>WS：窗口扩大因子，用于扩展TCP窗口大小<ul><li>例如，第一条SYN报文中的Win&#x3D;64240字节，WS&#x3D;256，那么实际上的接收窗口大小&#x3D;64240*256字节</li></ul></li><li>SACK_PERM：选择性确认许可，表示该连接允许使用SACK。SACK是一种TCP的优化功能，它允许接收方在数据包丢失的情况下，告诉发送方哪些数据段已经成功接收，而不必重新传输所有未确认的段</li></ul><p>上面的多个报文段：</p><ul><li>SYN：连接请求报文段</li><li>SYN，ACK：握手确认报文段</li><li>ACK：确认报文段</li><li>FIN，ACK：连接关闭请求报文段<ul><li>理论上客户机只需要发送FIN即可，<strong>ACK实际上是收到上一个报文段的确认</strong></li></ul></li></ul><blockquote><p>假设主机甲采用停等协议向主机乙发送数据帧，数据帧长与确认帧长均为100B，数据传输速率是10kbps，单向传播延时是200ms，则甲的最大信道利用率是？</p></blockquote><p>$$RTT &#x3D; 2 \cdot 单向传播时延 &#x3D; 400ms &#x3D; 0.4s$$</p><p>$$数据帧&#x2F;确认帧传输时延 &#x3D; 1000B \div 10k bps &#x3D; 1000 \cdot 8 bit \div 1000 \cdot 10 bps &#x3D; 0.8s$$</p><p>$$甲利用率 &#x3D; 数据帧利用率 &#x3D; \frac {0.8s}{0.8+0.8+0.4s} &#x3D; \frac {0.8s}{2.0s} &#x3D; 0.4$$</p><h2 id="6-拥塞控制原理"><a href="#6-拥塞控制原理" class="headerlink" title="6.拥塞控制原理"></a>6.拥塞控制原理</h2><h3 id="1-拥塞定义"><a href="#1-拥塞定义" class="headerlink" title="1.拥塞定义"></a>1.拥塞定义</h3><p><strong>非正式的定义:</strong> “大量的分组需要网络传输，<strong>超过了网络的处理能力</strong>” ，引起网络局部或整体性能的下降</p><ul><li>与流量控制不同</li></ul><p><strong>拥塞的表现:</strong></p><ul><li>**丢包：**分组丢失(路由器缓冲区溢出)</li><li>**长时延：**分组经历比较长的延迟(在路由器的队列中排队)</li></ul><p><strong>拥塞是网络中前10位的问题之一！</strong></p><h3 id="2-原因-代价"><a href="#2-原因-代价" class="headerlink" title="2.原因&#x2F;代价"></a>2.原因&#x2F;代价</h3><ul><li>长时延(场景1)</li><li>不必要的重传(场景2)</li><li>上游分组传输能力的浪费(场景3)</li></ul><h3 id="3-拥塞控制方法"><a href="#3-拥塞控制方法" class="headerlink" title="3.拥塞控制方法"></a>3.拥塞控制方法</h3><p><strong>端到端拥塞控制</strong>：</p><p>没有来自网络的显式反馈</p><p>端系统根据延迟和丢失事件推断是否有拥塞</p><p>TCP采用的方法</p><p><strong>网络辅助的拥塞控制</strong>：</p><p>路由器提供给端系统以反馈信息</p><ul><li>单个bit置位，显示有拥塞(SNA, DECbit,  TCP&#x2F;IP ECN, ATM)</li><li>显式提供发送端可以采用的速率</li></ul><blockquote><p>扩展IP和TCP能够选择性实现网络辅助拥塞方法——使用未用的标记位(如上所述)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241025145332516.png" alt="image-20241025145332516"></p><h2 id="7-TCP拥塞控制"><a href="#7-TCP拥塞控制" class="headerlink" title="7.TCP拥塞控制"></a>7.TCP拥塞控制</h2><h3 id="1-机制"><a href="#1-机制" class="headerlink" title="1.机制"></a>1.机制</h3><ul><li>端到端的拥塞控制机制<ul><li>路由器不向主机有关拥塞的 反馈信息 <ul><li>路由器的负担较轻 </li><li>符合网络核心简单的 TCP&#x2F;IP架构原则</li></ul></li><li>端系统根据自身得到的信息 ，判断是否发生拥塞，从而 采取动作</li></ul></li></ul><p><strong>如何控制发送端发送的速率</strong></p><ul><li><p>维持一个拥塞窗口的值：CongWin(<strong><code>cwnd</code></strong>)</p><ul><li><p>发送端限制已发送但是未确认的数据量（的上限）: </p></li><li><p>$LastByteSent-LastByteAcked &lt;&#x3D; min(cwnd, rwnd)$ </p><ul><li>cwnd:拥塞窗口；rwnd:接收窗口</li></ul></li></ul></li><li><p>从而粗略地控制发送方的往网络中注入的速率</p><ul><li>$速率 &#x3D; \frac{cwnd}{RTT} bytes&#x2F;sec$</li></ul></li><li><p><strong>拥塞窗口是动态的</strong>，可感知网络拥塞</p></li></ul><p><strong>发送方如何感知网络拥塞</strong></p><ul><li>丢失事件&#x3D;超时 or 3个重复ACK</li><li>发送丢失事件，TCP发送方降低速率(cwnd缩小)</li></ul><h3 id="2-策略"><a href="#2-策略" class="headerlink" title="2.策略"></a>2.策略</h3><ul><li>慢启动</li><li>AIMD：线性增、乘性减少</li><li>超时事件后的保守策略</li></ul><h4 id="1-TCP慢启动"><a href="#1-TCP慢启动" class="headerlink" title="1.TCP慢启动"></a>1.TCP慢启动</h4><ul><li><p>连接刚建立, cwnd&#x3D; 1  MSS </p><ul><li>如: MSS &#x3D; 1460bytes &amp;  RTT &#x3D; 200 ms</li><li>初始速率&#x3D; 58.4kbps(MSS&#x2F;RTT)</li></ul></li><li><p>可用带宽可能&gt;&gt;  MSS&#x2F;RTT </p><ul><li>应该尽快加速，到达希望的 速率</li></ul></li><li><p>当连接开始时，指数性增 加发送速率，直到发生丢 失的事件</p><ul><li>启动初值很低    </li><li>但是速度很快</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241025150312359.png" alt="image-20241025150312359"></p><ul><li><p>遇到丢失事件</p><ul><li>cwnd&#x3D;1，阈值(ssthresh)&#x3D;原cwnd&#x2F;2(但不小于2MSS)，进入慢启动阶段</li></ul></li><li><p>什么时候从指数增长转变为线性增长(拥塞避免)？</p><ul><li><strong>cwnd达到阈值的时候</strong>。阈值(ssthresh)&#x3D;上一次拥塞时的cwnd&#x2F;2(但不小于2MSS)</li></ul></li><li><p>如何实现cwnd线性增长？</p><ul><li>每个RTT只将cwnd增加一个MSS，而不是每收到一个ACKed就增加1个MSS</li></ul></li></ul><h4 id="2-快速回复"><a href="#2-快速回复" class="headerlink" title="2.快速回复"></a>2.快速回复</h4><p>思路：</p><ul><li>3个重复的ACK表示网络 还有一定的段传输能力</li><li>超时之前的3个重复的 ACK表示“警报”</li></ul><p>规则：</p><ul><li>当收到3个重复的ACKs: <ul><li>CongWin(cwnd)减半(有时候会再增加3MSS)<ul><li>最好是减半不增加，答题时两种都认可</li></ul></li><li>窗口（缓冲区大小）之后线性增长</li></ul></li><li>当超时事件发生时:<ul><li>CongWin(cwnd)&#x3D;1MSS，进入SS阶段</li><li>之后窗口指数增长</li><li>增长到一个阈值（上次发生拥塞的窗口的一半）时 ，再线性增加</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241025151301134.png" alt="image-20241025151301134"></p><ul><li><p><strong>TCP Reno</strong>：<strong>区分冗余ACK和超时</strong></p><ul><li>冗余ACK：ssthresh&#x3D;cwnd&#x2F;2，cwnd&#x3D;ssthresh(or ssthresh+3MSS，后者不常用)<ul><li>ssthresh&#x3D;cwnd&#x2F;2，<strong>向下取整</strong></li></ul></li><li>超时：ssthresh&#x3D;cwnd&#x2F;2，cwnd&#x3D;1</li></ul></li><li><p><strong>TCP Tahoe</strong>：<strong>不区分冗余ACK和超时</strong></p><ul><li>不管是冗余ACK还是超时：ssthresh &#x3D; cwnd&#x2F;2，cwnd&#x3D;1</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241025151556397.png" alt="image-20241025151556397"></p><ul><li>上图中，右侧的cwnd &#x3D; ssthresh+3MSS，加3是不必要的</li></ul><h4 id="3-AIMD"><a href="#3-AIMD" class="headerlink" title="3.AIMD"></a>3.AIMD</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241025152048223.png" alt="image-20241025152048223"></p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><ul><li>CongWin&lt;Threshold, 发送端处于慢启动阶段(SS) , 窗口指数性增长.</li><li>当CongWin&gt;&#x3D;Threshold, 发送端处于拥塞避免(CA)阶段 congestion-avoidance , 窗口线性增长. </li><li>当收到三个重复的ACKs (triple duplicate ACK), Threshold&#x3D;CongWin&#x2F;2,CongWin&#x3D;Threshold+3(不一定要+3). </li><li>当超时事件发生时timeout, Threshold&#x3D;CongWin&#x2F;2,CongWin&#x3D;1 MSS，进入SS阶段</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241025152208623.png" alt="image-20241025152208623"></p><h3 id="3-TCP吞吐量"><a href="#3-TCP吞吐量" class="headerlink" title="3.TCP吞吐量"></a>3.TCP吞吐量</h3><h4 id="1-平均吞吐量"><a href="#1-平均吞吐量" class="headerlink" title="1.平均吞吐量"></a>1.平均吞吐量</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241025153931496.png" alt="image-20241025153931496"></p><h4 id="2-TCP未来"><a href="#2-TCP未来" class="headerlink" title="2.TCP未来"></a>2.TCP未来</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241025154001596.png" alt="image-20241025154001596"></p><h3 id="4-TCP公平"><a href="#4-TCP公平" class="headerlink" title="4.TCP公平"></a>4.TCP公平</h3><p><strong>公平性目标</strong>:如果K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为R&#x2F;K</p><ul><li><p>为什么TCP可以保证公平性？</p><ul><li>2个竞争的TCP会话: 加性增加，斜率为1, 吞吐量增加；乘性减，吞吐量比例减少</li><li>本身cwnd更大，乘性减的幅度更高(2-&gt;6,8-&gt;12;6&#x2F;2&#x3D;3,12&#x2F;2&#x3D;6——原本8&#x3D;2*4，现在6&#x3D;2*3)</li></ul></li><li><p>但并非一定公平</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241025154509937.png" alt="image-20241025154509937"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记-应用层</title>
      <link href="/2024/09/27/ji-wang-xue-xi-bi-ji-ying-yong-ceng/"/>
      <url>/2024/09/27/ji-wang-xue-xi-bi-ji-ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><blockquote><p>网络应用是计算机网络的重要功能之一</p><p>创建一个新的网络应用需要注意：</p><ul><li><strong>编程</strong><ul><li>在不同的端系统上运行</li><li>通过网络基础设施提供的服务，应用进程之间彼此通信</li><li>如Web应用程序，Web服务器程序和浏览器程序互相通信</li></ul></li><li><strong>网络核心中没有应用层软件</strong><ul><li>应用程序软件只在端系统运行，不需在网络核心设备上运行</li></ul></li></ul></blockquote><h2 id="1-应用层协议原理"><a href="#1-应用层协议原理" class="headerlink" title="1.应用层协议原理"></a>1.应用层协议原理</h2><h3 id="1-网络应用程序体系结构"><a href="#1-网络应用程序体系结构" class="headerlink" title="1.网络应用程序体系结构"></a>1.网络应用程序体系结构</h3><p>网络应用的体系结构共有3种：</p><ul><li>客户机&#x2F;服务器模式(<strong>C&#x2F;S</strong>)</li><li>对等模式(<strong>P2P</strong>)</li><li>混合体模式(<strong>C&#x2F;S+P2P</strong>)</li></ul><h4 id="1-C-S"><a href="#1-C-S" class="headerlink" title="1.C&#x2F;S"></a>1.C&#x2F;S</h4><p>客户机&#x2F;服务器体系结构如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240927191713701.png" alt="image-20240927191713701"></p><p><strong>特点</strong>：</p><ul><li>服务器：<ul><li>总是打开</li><li>为<em>多个客户机</em>请求提供服务</li><li>永久的、固定的IP地址</li><li>可扩展为服务器集群</li></ul></li><li>客户机<ul><li>间歇打开(也可能是总打开的)</li><li>向服务器发出请求</li><li>具有动态的IP地址</li><li>客户机彼此之间<strong>不直接通信</strong></li></ul></li></ul><p><strong>C&#x2F;S模式的缺陷</strong>：</p><ul><li>可扩展性差，性能随用户增加呈<strong>断崖式下降</strong>，不满足一般希望的线性下降</li></ul><h4 id="2-P2P"><a href="#2-P2P" class="headerlink" title="2.P2P"></a>2.P2P</h4><blockquote><p>P2P，全称是<strong>peer to peer</strong>，peer的汉语称呼是“节点”</p></blockquote><p>对等模式的体系结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240927192049438.png" alt="image-20240927192049438"></p><p><strong>特点</strong>：</p><ul><li>(几乎)没有一直运行的服务器</li><li>任意端系统(<strong>对等方</strong>)之间可以<strong>直接通信</strong></li><li>每个节点<strong>既是客户端，也是服务器</strong><ul><li>自拓展性：新<strong>peer</strong>节点带来新的服务能力，也带来新的请求</li></ul></li><li>对等方<strong>间歇连接</strong>，<strong>IP地址不固定</strong></li></ul><p><strong>优点</strong>：</p><ul><li>可扩展度高</li></ul><p><strong>缺陷</strong>：</p><ul><li>P2P管理困难</li></ul><h4 id="3-混合模式"><a href="#3-混合模式" class="headerlink" title="3.混合模式"></a>3.混合模式</h4><p>这里只讨论混合模式中的一种：<strong>C&#x2F;S+P2P</strong></p><p>这种混合模式一般是这样：服务器用于用户的注册和定位，文件等数据的交换是通过P2P模式对等传输</p><p>示例：</p><ul><li>Napster：MP3文件共享应用程序</li><li>即时通信</li></ul><h3 id="2-进程通信"><a href="#2-进程通信" class="headerlink" title="2.进程通信"></a>2.进程通信</h3><blockquote><p><strong>进程</strong>：在主机上<strong>运行</strong>的程序</p><ul><li>在同一主机内，使用<strong>进程间通信机制</strong>通信，如管道、消息队列等</li><li>不同主机，通过交换<strong>报文</strong>来通信<ul><li>使用OS提供的通信服务</li><li>按照应用协议交换报文</li></ul></li><li>根据功能可以将进程分为两类<ul><li><strong>客户端进程</strong>：发起通信的进程</li><li><strong>服务器进程</strong>：等待其他进程连接的进程</li><li>需要注意的是，C&#x2F;S模式和P2P模式的应用<strong>都有</strong>客户端进程和服务器进程之分</li></ul></li></ul></blockquote><p>我们这里主要研究的，就是<strong>分布式进程通信</strong>，也就是不同主机间的通信。</p><p><strong>分布式进程通信</strong>需要解决的问题有：</p><ul><li>进程标示和寻址问题</li><li>传输层-应用层提供了什么服务</li><li>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用</li></ul><h4 id="1-进程标示和寻址"><a href="#1-进程标示和寻址" class="headerlink" title="1.进程标示和寻址"></a>1.进程标示和寻址</h4><p>进程为了接收报文，必须有一个标识(当然，发送方也需要)</p><p><strong>进程标识构成如下：</strong></p><ul><li>主机：唯一的<strong>32位IP地址</strong></li><li>进程采用的传输协议：<strong>TCP&#x2F;UDP</strong></li><li>端口号：TCP&#x2F;UDP使用的端口号不同<ul><li>常用的周知端口：<ul><li>Web应用：<code>port 80</code></li><li>FTP：<code>port 21</code>(控制连接)</li><li>Mail：<code>port 25</code></li></ul></li></ul></li></ul><p>一个进程，用<code>IP+Port</code>标示出**”端节点”**(end point)</p><p><strong>本质上，一对主机进程之间的通信就是由两个”端节点”构成的</strong></p><h4 id="2-传输层-应用层间提供的服务"><a href="#2-传输层-应用层间提供的服务" class="headerlink" title="2.传输层-应用层间提供的服务"></a>2.传输层-应用层间提供的服务</h4><blockquote><p>首先我们需要回顾一些概念：</p><p><strong>SAP：<strong>服务访问点，描述网络协议栈中</strong>不同层之间的接口</strong>，是一个<strong>逻辑概念</strong></p><p><strong>SDU</strong>：服务数据单元，也就是从上一层接收到的数据</p><ul><li>上一层的<strong>PDU</strong>，就是本层的<strong>SDU</strong></li></ul><p><strong>PDU</strong>：协议数据单元，将SDU与本层添加的头部信息封装后的数据</p><ul><li><strong>SDU</strong>和<strong>PDU</strong>都是<strong>OSI模型</strong>的概念，但放在因特网协议栈中也可以</li></ul><p><strong>端口与协议</strong>：每个端口号可以与不同的协议组合使用，例如TCP或UDP。<strong>同一个端口号可以被TCP和UDP分别使用</strong>，但它们是<strong>独立的</strong>。</p><ul><li>如，TCP端口80用于HTTP服务，但是UDP端口80就可以用于其他服务</li></ul><p><strong>传输层实体</strong>：<strong>传输层实体</strong>就是实现传输层协议（如TCP或UDP）功能的程序或模块，用于管理数据传输、连接控制和错误检测等任务。</p></blockquote><p>我们不妨思考一下，应用层的进程需要将什么数据传递给传输层，来实现不同主机间的进程通信？或者说，<strong>应用层和传输层之间的SAP需要携带什么信息？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240927200048669.png" alt="image-20240927200048669"></p><p>答案是：</p><ul><li><p>要传输的<strong>报文(message)</strong>：对传输层来说，就是<strong>SDU</strong></p></li><li><p>谁传递的信息：源应用进程的标示：<strong>IP + TCP&#x2F;UDP port</strong></p></li><li><p>传递给谁：目的应用进程的标示：<strong>IP + TCP&#x2F;UDP port</strong></p></li></ul><p><strong>传输层实体</strong>(TCP实体或UDP实体)就会根据这些信息进行<strong>TCP报文段</strong>或<strong>UDP数据报</strong>的封装(这取决于你采用的是哪个运输层协议)</p><ul><li>报文数据就会作为<strong>SDU</strong></li><li>源端口号、目的端口号就会作为<strong>PDU</strong>的头部信息</li><li>源IP、目的IP也会存储在<strong>PDU</strong>内供网络层使用，用于封装网络层数据报</li></ul><blockquote><p>但是真的应该这么做吗？每次都传递进程标示信息不是一种冗余和浪费吗？</p><p><strong>如何减少传递的信息量？</strong></p></blockquote><h4 id="3-层间信息的代表-socket"><a href="#3-层间信息的代表-socket" class="headerlink" title="3.层间信息的代表-socket"></a>3.层间信息的代表-socket</h4><blockquote><p>应用层和运输层之间的<strong>SAP</strong>：<strong>Socket</strong>，它提供了一种<strong>API</strong>，允许<strong>应用程序</strong>与<strong>运输层</strong>交互</p><p><strong>socket</strong>就是一个用来标示通信双方或者单方的<strong>代号</strong>。利用<strong>socket</strong>，操作系统内核就可以通过它来识别和转发通信数据，而<strong>不需要数据携带进程标示了</strong></p></blockquote><p><strong>socket</strong>就像OS打开文件返回的<strong>句柄</strong>一样</p><ul><li>对句柄的操作，就是对文件的操作，对<strong>socket</strong>也是同理</li><li><strong>socket</strong>也是和句柄一样，本身是一个<strong>整数</strong></li><li><strong>socket</strong>同时也是一个<strong>本地标示</strong>，只有本地主机可以读取</li><li>而socket又映射着一个<strong>二元组&#x2F;四元组的数据结构</strong>，其中是源进程标示&#x2F;目的进程标示</li><li>每当有数据抵达时，网络栈会得到源IP(和目的IP)，操作系统就会根据这个IP来查找socket数据结构，寻找对应IP的socket。找到了对应的socket，也就是找到了对应进程</li></ul><h5 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h5><p><strong>TCP</strong>服务，两个进程之间的通信需要<strong>建立连接</strong></p><p>对于使用面向连接服务(TCP)的应用而言，套接字是4元组的一个具有<strong>本地意义</strong>的标示：</p><ul><li>四元组：<strong>(源ip，源port，目的ip，目的port)</strong></li><li>唯一的指定了一个<strong>会话</strong>(2个进程之间的会话关系)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240927203715436.png" alt="image-20240927203715436"></p><p>从上面的图示我们可以看到，<strong>同一端口，不同目的IP，套接字socket的值就不一样——socket代表的是会话关系，而不是主机关系</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240927203844939.png" alt="image-20240927203844939"></p><h5 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a>UDP socket</h5><p><strong>UDP</strong>服务，两个进程之间的通信<strong>无需建立连接</strong></p><ul><li>每个报文都是<strong>独立传输</strong></li><li>前后报文可能给到<strong>不同的</strong>分布式进程</li></ul><p>因此，<strong>UDP socket</strong>只代表二元组：<strong>(源ip，源port)</strong>，也就是<strong>源端节点</strong></p><ul><li>但也因此，传输报文时，<strong>必须提供目的IP和目的port</strong>(<strong>目的端节点</strong>)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240927204316782.png" alt="image-20240927204316782"></p><blockquote><p>因此，我们可以形象的认为，套接字(socket)和门户是类似的。</p><p>发送进程将报文<strong>推出</strong>门户，依赖传输层设施将报文交付给接受进程</p><p>接收进程从另外一端的门户<strong>收到</strong>报文</p></blockquote><h3 id="3-使用传输层服务-应用层协议"><a href="#3-使用传输层服务-应用层协议" class="headerlink" title="3.使用传输层服务-应用层协议"></a>3.使用传输层服务-应用层协议</h3><p><strong>应用层协议</strong>定义了：运行在不同端系统上的应用<strong>进程</strong>如何相互交换报文</p><ul><li>交换的<strong>报文类型</strong>：请求和应答报文</li><li>各种报文类型的<strong>语法</strong>：报文中的各个字段及其描述</li><li>字段的<strong>语义</strong>：字段取值的含义</li><li>进程何时、如何发送报文以及对报文进行响应的<strong>规则</strong></li></ul><p><strong>注意，应用层协议知识应用的一个组成部分</strong></p><p>协议又分为<strong>公开协议</strong>和<strong>专用协议</strong></p><h3 id="4-应用对传输层服务的需求指标"><a href="#4-应用对传输层服务的需求指标" class="headerlink" title="4.应用对传输层服务的需求指标"></a>4.应用对传输层服务的需求指标</h3><ul><li>可靠的数据传输(<strong>数据丢失率</strong>)<ul><li>数据不能丢失的应用：如文件传输</li><li>能容忍一定丢失的应用：如多媒体应用</li></ul></li><li>带宽(<strong>数据传输率&#x2F;吞吐</strong>)<ul><li>带宽敏感的应用，要求<strong>最小限额的带宽</strong>：如因特网电话</li><li>弹性应用，对带宽要求不大，可充分利用</li></ul></li><li>延迟(<strong>数据传输的时间限制</strong>)<ul><li>交互式实时应用：如web电话，交互式游戏</li><li>非实时应用：不做限制</li></ul></li><li>安全性<ul><li>机密性</li><li>完整性</li><li>可认证性</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240927205413834.png" alt="image-20240927205413834"></p><h3 id="5-因特网运输层提供的服务"><a href="#5-因特网运输层提供的服务" class="headerlink" title="5.因特网运输层提供的服务"></a>5.因特网运输层提供的服务</h3><h4 id="1-TCP服务"><a href="#1-TCP服务" class="headerlink" title="1.TCP服务"></a>1.TCP服务</h4><ul><li><strong>面向连接的服务</strong><ul><li>划分为三阶段</li><li><strong>建立连接(握手过程)</strong><ul><li>客户端程序与服务器程序互相交换控制信息，在两个进程的套接字之间建立TCP连接</li><li>具体有<strong>3次握手</strong>：A向B发送连接请求，B向A发送同意并确认请求，A发送确认请求，AB确认连接。这其中，<strong>第3次握手的同时可以发送实际数据</strong></li></ul></li><li><strong>传输报文</strong><ul><li>连接是<strong>全双工</strong>的，即连接双方的进程可以在此连接上<strong>同时进行报文收发</strong></li></ul></li><li><strong>拆除连接</strong><ul><li>应用程序报文发送结束</li></ul></li></ul></li><li><strong>可靠的传输服务</strong><ul><li>无差错、按适当顺序交付数据</li><li>无数据丢失和重复</li></ul></li><li><strong>流量控制</strong><ul><li>发送方发太快，接收方收太慢，被淹没</li><li>出现上述情况时控制发送方速度</li></ul></li><li><strong>拥塞控制</strong><ul><li>发送方、接收方正常，但<strong>网络堵塞了</strong></li><li>出现上述情况，抑制发送方速度</li></ul></li><li><strong>不能提供的服务</strong><ul><li>时间保证</li><li>最小吞吐保证</li><li>安全性</li></ul></li></ul><h4 id="2-UDP服务"><a href="#2-UDP服务" class="headerlink" title="2.UDP服务"></a>2.UDP服务</h4><ul><li><strong>不可靠数据传输</strong><ul><li>不保证报文被接收&#x2F;报文乱序到达</li></ul></li><li><strong>不提供的服务</strong><ul><li>可靠传输</li><li>建立连接(握手)</li><li>流量控制、拥塞控制</li><li>时间保证</li><li>带宽保证</li></ul></li></ul><h4 id="3-UDP存在的必要性"><a href="#3-UDP存在的必要性" class="headerlink" title="3.UDP存在的必要性"></a>3.UDP存在的必要性</h4><ul><li>能够<strong>区分不同的进程</strong></li><li><strong>无需建立连接</strong></li><li><strong>不做可靠性的工作</strong>，适合实时性高而正确性低的应用</li><li>没有拥塞控制和流量控制，<strong>应用能够按照设定的速度发送数据</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240927210637041.png" alt="image-20240927210637041"></p><h3 id="6-安全TCP"><a href="#6-安全TCP" class="headerlink" title="6.安全TCP"></a>6.安全TCP</h3><p>我们知道，<strong>TCP&amp;UDP</strong>都是没有加密的，<strong>明文传输</strong></p><p>因此，在应用层有一个协议<strong>SSL</strong></p><ul><li>在TCP上实现，提供加密的TCP连接</li><li>私密性</li><li>数据完整性</li><li>端到端鉴别</li></ul><p>我们常说的<strong>HTTPS</strong>中的<strong>S</strong>，就是<strong>SSL</strong></p><p>在第8章，还会认识到<strong>SSL socket API</strong>，应用通过API将明文交给socket，SSL将其加密后在互联网上传输</p><h3 id="7-用户代理"><a href="#7-用户代理" class="headerlink" title="7.用户代理"></a>7.用户代理</h3><p>用户代理，<strong>是用户和网络应用程序之间的接口</strong></p><p>例如：</p><ul><li>Web应用的用户代理：浏览器软件</li><li>电子邮件应用的用户代理：”邮件阅读器”</li></ul><hr><h2 id="2-Web-and-HTTP"><a href="#2-Web-and-HTTP" class="headerlink" title="2.Web and HTTP"></a>2.Web and HTTP</h2><blockquote><p>Web是一个应用，HTTP是支持Web应用的一种协议</p></blockquote><p>一些术语：</p><ul><li>Web页：由一些对象组成<ul><li>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</li><li>对象之间不能互相包含，<strong>A对象只能包含B对象的链接</strong></li></ul></li><li>Web页含有一个<strong>基本的HTML文件</strong>，该HTML又包含若干对象的引用(链接)</li><li>我们通过**URL(统一资源定位符)**对每个对象进行引用</li><li><strong>URL</strong>格式：<ul><li><code>Prot</code>：协议名</li><li><code>user:psw</code>：用户：口令(允许匿名访问时，<code>user:psw</code>不存在)</li><li><code>www.someSchool.edu</code>：主机名</li><li><code>port</code>：端口(HTTP协议默认80端口，FTP默认21端口，<strong>不用注明</strong>)</li><li><code>/someDept/pic.gif</code>：路径名</li></ul></li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">Prot://user:psw@www.someSchool.edu:port/somDept/pic.gif<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-HTTP概况"><a href="#1-HTTP概况" class="headerlink" title="1.HTTP概况"></a>1.HTTP概况</h3><h4 id="1-HTTP：超文本传输协议"><a href="#1-HTTP：超文本传输协议" class="headerlink" title="1.HTTP：超文本传输协议"></a>1.<strong>HTTP：超文本传输协议</strong></h4><ul><li><p>超文本：<strong>支持文本与文本、文本与其他媒体之间的动态、非线性指向关系</strong></p></li><li><p>Web的<strong>应用层协议</strong></p></li><li><p>客户端&#x2F;服务器模式</p><ul><li>客户端：请求、接收和显示Web对象的浏览器</li><li>服务器：对请求进行响应，发送Web对象的服务器</li></ul></li></ul><p><em>不同厂商、不同客户端(浏览器)、不同服务器(Apache,Nginx…)能够互相通信的关键就是：<strong>他们都遵守HTTP协议</strong></em></p><h4 id="2-使用TCP"><a href="#2-使用TCP" class="headerlink" title="2.使用TCP"></a>2.使用TCP</h4><p><strong>HTTP</strong>是建立在<strong>TCP</strong>服务之上的应用层协议</p><p>具体流程：</p><ul><li>客户发起一个与服务器的TCP连接(建立套接字)，<strong>port &#x3D; 80</strong></li><li>服务器接受客户的TCP连接请求</li><li>浏览器和Web服务器交换<strong>HTTP报文</strong></li><li>TCP连接关闭<ul><li>换句话说，Web页面画完后，拆除TCP连接(不一定哦)</li></ul></li></ul><blockquote><p>在HTTP的通信过程中，服务器通常会涉及两个不同类型的套接字（socket）：<strong>守候socket</strong>（也叫监听socket）和<strong>连接socket</strong>。它们在TCP连接的建立和管理中各司其职。</p><ul><li><strong>守候socket</strong>是服务器端用来监听客户端的连接请求的套接字。<ul><li>一旦监听到来自客户端的连接请求，<strong>守候socket</strong>将会接收连接请求，并创建一个新的<strong>连接socket</strong>负责具体通信，<strong>守候socket</strong>继续保持被动监听状态</li><li><strong>守候socket</strong>不负责实际数据传输</li></ul></li><li><strong>连接socket</strong>负责与特定的客户端进行通信</li></ul></blockquote><h4 id="3-无状态"><a href="#3-无状态" class="headerlink" title="3.无状态"></a>3.无状态</h4><p><strong>HTTP是无状态的</strong>，服务器并不维护关于客户的任何信息</p><blockquote><p>为什么？</p></blockquote><p>维护状态的协议很复杂：</p><ul><li>必须维护历史信息</li><li>如果服务器&#x2F;客户端死机，两者<strong>状态不一致</strong>，需要复杂的更新统一手段</li><li><strong>无状态服务器</strong>能够支持<strong>更多的客户端</strong></li></ul><hr><h3 id="2-HTTP连接"><a href="#2-HTTP连接" class="headerlink" title="2.HTTP连接"></a>2.HTTP连接</h3><p>HTTP的连接方式分为两种：<strong>非持久HTTP</strong>和<strong>持久HTTP</strong></p><h4 id="1-非持久HTTP连接"><a href="#1-非持久HTTP连接" class="headerlink" title="1.非持久HTTP连接"></a>1.非持久HTTP连接</h4><ul><li>一次TCP连接最多只能发送<strong>一个Web对象</strong></li><li>下载多个对象需要<strong>多次TCP连接</strong></li><li><strong>HTTP&#x2F;1.0</strong>使用非持久连接</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/%E9%9D%9E%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.jpg" alt="非持久连接"></p><p>在上图中，有一个名词**”响应时间”**值得关注。</p><h4 id="2-响应时间模型"><a href="#2-响应时间模型" class="headerlink" title="2.响应时间模型"></a>2.<strong>响应时间模型</strong></h4><p><strong>往返时间RTT(round-trip-time)</strong></p><ul><li>定义：一个<strong>小的分组</strong>从客户端到服务器，再回到客户端的时间</li><li>注意：因为是**”小的分组”<strong>，所以</strong>传输时间忽略不计**，但从C端到S端(以及反过来)的<strong>传播时间不能忽略</strong></li></ul><p><strong>响应时间</strong></p><ul><li>一个<strong>RTT</strong>用于<strong>发起TCP连接</strong></li><li>一个<strong>RTT</strong>用于<strong>发起HTTP请求并等待HTTP响应</strong></li><li>文件传输时间(Web对象远大于”小分组”，故<strong>传输时间不能忽略</strong>)</li></ul><p><strong>因此，非持久连接时：</strong></p><p>$$一个对象的响应时间 &#x3D; 2*RTT + 文件传输时间$$</p><h4 id="3-持久HTTP连接"><a href="#3-持久HTTP连接" class="headerlink" title="3.持久HTTP连接"></a>3.持久HTTP连接</h4><blockquote><p>可以看到，非持久HTTP连接的缺点很明显：</p><ul><li>每个对象都要2个RTT</li><li>操作系统必须为每个TCP连接分配资源</li><li>但浏览器通常打开并行TCP连接，以获取引用对象</li></ul></blockquote><p>在<strong>HTTP&#x2F;1.0</strong>使用了非持久HTTP连接后，出于对其缺点的考量，<strong>HTTP&#x2F;1.1</strong>采用了<strong>持久HTTP连接</strong></p><ul><li>服务器端在发送完第一个<strong>HTTP响应</strong>(主体就是Web对象)之后，<strong>仍然保持TCP连接，不拆除</strong></li><li>在相同客户端与服务器之间的后续请求和响应报文通过<strong>相同的连接进行传送</strong></li><li>客户端在遇到一个引用对象时，就<strong>可以尽快发送</strong>该对象的请求</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.jpg" alt="持久连接"></p><p><strong>持久HTTP连接也分为两种</strong>，流水方式的持久HTTP和非流水方式的持久HTTP</p><h5 id="1-非流水方式的持久HTTP"><a href="#1-非流水方式的持久HTTP" class="headerlink" title="1.非流水方式的持久HTTP"></a>1.非流水方式的持久HTTP</h5><ul><li>客户端只能在<strong>收到前一个响应后才能发送新的请求</strong></li><li>每个引用对象花费<strong>1个RTT</strong></li></ul><h5 id="2-流水方式的持久HTTP"><a href="#2-流水方式的持久HTTP" class="headerlink" title="2.流水方式的持久HTTP"></a>2.流水方式的持久HTTP</h5><ul><li><strong>HTTP&#x2F;1.1的默认模式</strong></li><li>客户端<strong>遇到一个引用对象就立即产生一个请求</strong>，不需要管是否有相应</li><li>因此，所有引用对象只花费<strong>1个RTT</strong>都有可能</li></ul><hr><h3 id="3-HTTP报文"><a href="#3-HTTP报文" class="headerlink" title="3.HTTP报文"></a>3.HTTP报文</h3><p>HTTP报文有两种类型：<strong>请求</strong>和<strong>响应</strong></p><h4 id="1-HTTP请求报文"><a href="#1-HTTP请求报文" class="headerlink" title="1.HTTP请求报文"></a>1.HTTP请求报文</h4><p>HTTP请求报文是<code>ASCII码</code>编码，易读性强</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240928172012252.png" alt="image-20240928172012252"></p><p>图片中的段落就是<strong>HTTP请求报文</strong>的<strong>头部</strong>，在<strong>额外的换行回车符</strong>之后，是可能存在的<strong>body部</strong>，存放的是请求的<strong>Web对象</strong></p><ul><li><code>Connection</code>行展示的是C&#x2F;S是否连接，按照<strong>HTTP&#x2F;1.1</strong>的默认设置，TCP连接是<strong>不中断</strong>的，但是这里<strong>人为设置中断</strong></li><li>实质上，<code>Connection=keep-alive</code>表示连接是持久性的，<code>Connection=close</code>表示连接是非持久性的</li></ul><h5 id="1-通用格式"><a href="#1-通用格式" class="headerlink" title="1.通用格式"></a>1.通用格式</h5><p><strong>HTTP请求报文的通用格式如下图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240928172402308.png" alt="image-20240928172402308"></p><p>其中，<code>sp</code>是空格，<code>cr lf</code>是换行回车。</p><h5 id="2-提交表单输入："><a href="#2-提交表单输入：" class="headerlink" title="2.提交表单输入："></a>2.<strong>提交表单输入</strong>：</h5><p>HTTP请求报文也是可以向服务器端<strong>发送数据</strong>的，具体有两种方式：</p><ul><li><strong><code>Post</code>方式</strong><ul><li>方法：<code>POST</code>，实现表单输入</li><li>包含在实体主题(entity body)中的输入被提交到服务器</li></ul></li><li><strong><code>URL</code>方式</strong><ul><li>方法：<code>GET</code></li><li>在URL上加参数来向服务器提交相应信息</li></ul></li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>URL</code>中，<code>&quot;?&quot;</code>后面的就是参数项，参数之间用<code>&quot;&amp;&quot;</code>连接</p><ul><li>上述的URL中，参数是<code>wd</code>和<code>cl</code>，参数值分别是<code>xx+yy+zzz</code>和<code>3</code></li></ul><h5 id="3-方法类型"><a href="#3-方法类型" class="headerlink" title="3.方法类型"></a>3.方法类型</h5><p><strong>HTTP&#x2F;1.0</strong>：</p><ul><li><strong>GET</strong></li><li><strong>POST</strong></li><li><strong>HEAD</strong><ul><li><code>HEAD</code>方法，表示<strong>只需要返回响应报文的头部</strong></li></ul></li></ul><p><strong>HTTP&#x2F;1.1</strong>：</p><ul><li><strong>GET、POST、HEAD</strong></li><li><strong>PUT</strong><ul><li>将实体主体(<strong>entity body</strong>)中的<strong>文件</strong> <strong>上载到URL字段规定的路径</strong></li></ul></li><li><strong>DELETE</strong><ul><li>删除<strong>URL</strong>字段规定的文件</li></ul></li></ul><h4 id="2-HTTP响应报文"><a href="#2-HTTP响应报文" class="headerlink" title="2.HTTP响应报文"></a>2.HTTP响应报文</h4><p>HTTP响应报文也是<code>ASCII码</code>编码，易读性强</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240928173501813.png" alt="image-20240928173501813"></p><ul><li><code>Last-Modified</code>：请求的Web对象的最近修改时间(后面有用)</li><li><code>Content-Length</code>：提示在<strong>额外的回车</strong>后，连续6821个字节是请求对象<ul><li>因为客户端传输层是将响应报文的整体传到应用层，<strong>没有标记边界</strong>(比如，服务器传的请求对象是2个15kb块，客户端拿到的会是一个30kb块)，<strong>边界就是由首部行来维护的</strong></li></ul></li></ul><h4 id="3-HTTP响应状态码"><a href="#3-HTTP响应状态码" class="headerlink" title="3.HTTP响应状态码"></a>3.HTTP响应状态码</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240928173917603.png" alt="image-20240928173917603"></p><hr><h3 id="4-cookies"><a href="#4-cookies" class="headerlink" title="4.cookies"></a>4.cookies</h3><blockquote><p>既然HTTP是无状态协议，那么如果有用户识别的需要，该怎么办？</p></blockquote><p>大多数主要的门户网站使用<strong>cookies</strong>来解决这个问题。</p><p><strong>cookies</strong>的生成和传送过程：</p><ul><li><p>(首先需要明确的是，<strong>cookies的传送是在HTTP协议下的</strong>，因此只会出现在HTTP报文中)</p></li><li><p>客户端<strong>第一次访问</strong>，<strong>HTTP请求中没有cookies</strong></p></li><li><p>服务器端检查到该客户端是第一次访问，<strong>生成cookies保存在后端数据库</strong>，并<strong>在HTTP响应中添加一个cookies的首部行</strong></p></li><li><p>客户端收到HTTP响应，<strong>将头部的cookies首部行数据保存在浏览器的cookies文件中</strong></p></li><li><p>之后的每次<strong>HTTP请求</strong>，<strong>都会在请求中添加一个cookies的首部行</strong></p><ul><li>只要客户端和服务器端的cookies记录都存在，每次客户端要访问对应的网站，都会发cookie过去，无论间隔了多久</li></ul></li><li><p>而后续的<strong>HTTP响应</strong>，就<strong>不需要再添加</strong>cookies首部行了</p></li></ul><p>因此，<strong>cookies</strong>的<strong>4个组成部分</strong>分别是：</p><ul><li>HTTP响应报文中有一个cookies首部行</li><li>HTTP请求报文中有一个cookies首部行</li><li>用户端系统的浏览器保留有cookie文件</li><li>Web服务器有一个cookies后端数据库</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240928191346926.png" alt="image-20240928191346926"></p><p><strong>Cookies的作用：</strong></p><ul><li>用户验证</li><li>购物车</li><li>推荐算法</li><li>用户状态(Web、email)</li></ul><p><strong>维持状态的方式当然不止cookies：</strong></p><ul><li>协议端节点：在多个事务上，发送端和接收端维持状态</li><li>cookies：HTTP报文携带状态信息</li></ul><p><em><strong>当然，cookies也有弊端，隐私受到了侵犯</strong></em></p><hr><h3 id="5-Web缓存"><a href="#5-Web缓存" class="headerlink" title="5.Web缓存"></a>5.Web缓存</h3><blockquote><p>想使用Web应用，最直接的方式就是客户端直接和**源Web服务器(origin server)**建立连接。但是，全球数以亿计的计算机、每秒千亿计的HTTP请求，源Web服务器根本做不到快速响应。那么，该怎么解决这个棘手的问题呢？</p></blockquote><p><strong>Web缓存(Web cache)</strong>，或者叫<strong>代理服务器(proxy server)</strong>，就是解决这一问题的手段。</p><p><strong>Web缓存</strong></p><ul><li><p>目的：不访问<strong>源Web服务器</strong>，就满足客户的请求</p></li><li><p>方式：</p><ul><li>用户设置浏览器：<strong>通过缓存访问Web</strong></li><li>浏览器将所有的HTTP请求发给缓存<ul><li>**Hit(命中)：**请求的Web对象在缓存中，则直接返回给客户端</li><li><strong>Miss(未命中)</strong>：代理服务器再请求原始服务器，将得到的对象<strong>保存到缓存中</strong>的同时，<strong>返回给客户端</strong></li></ul></li></ul></li><li><p>位置：安装于<strong>本地LAN</strong>中，由<strong>ISP</strong>安装</p><ul><li>因此，访问<strong>Web缓存</strong>是不需要走<strong>Internet</strong>的，它也在局域网中</li></ul></li><li><p>好处：</p><ul><li>降低客户端的请求响应时间</li><li>减轻源Web服务器载荷</li><li>减轻互联网载荷</li></ul></li><li><p>前提：<strong>众多用户的访问具有趋同性</strong></p><ul><li>要是每个人要访问的都不同，那命中缓存的概率太低，也就没有安装Web缓存的必要了</li></ul></li></ul><blockquote><p>下面是Web缓存方面的例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240928193851636.png" alt="image-20240928193851636"></p><ul><li>平均对象大小100kb，平均请求率15个&#x2F;s，那么HTTP响应到浏览器的速率是1.5Mbps</li><li>局域网时延：<ul><li>请求时延：几乎为0</li><li>响应时延：1.5Mbps &#x2F; 1Gbps，约为10ms</li></ul></li><li>因特网时延：2s</li><li>接入链路时延(主要是排队时延，传输时延忽略)：<ul><li>接入链路流量强度$I &#x3D; 1.5Mbps &#x2F; 1.54Mbps &#x3D; 99 %$</li><li>接入链路时延$t_{queue} &#x3D; (0.99&#x2F;0.01) \cdot 100kb&#x2F;1.5Mbps ≈ 6.6s$</li><li>如果流量强度足够大，时延将会是以分钟计</li></ul></li><li>总时延 &#x3D; $10ms + 6.6s + 2s ≈ 9s$，甚至当链路带宽再小一些，总时延就有<strong>几分钟</strong>了</li></ul><blockquote><p>$$t_{queue} &#x3D; (I&#x2F;1-I) \cdot L &#x2F; R$$</p><p>$t_{queue}$为排队时延，$I$为流量强度，$L$是分组长度，$R$是链路速率</p></blockquote><p><strong>总计9秒，甚至几分钟的时延，在现代社会显然是不可接受的。怎么办？</strong></p><h4 id="1-提高链路带宽"><a href="#1-提高链路带宽" class="headerlink" title="1.提高链路带宽"></a>1.提高链路带宽</h4><p>既然带宽太小，导致流量强度趋近1，形成阻塞，那么就提高链路带宽</p><p><strong>提高之后，延时就主要由因特网时延决定，约为2s</strong></p><p>当然，这样的坏处就是，<strong>给ISP的租金大幅提高，成本太高了</strong></p><h4 id="2-安装本地缓存"><a href="#2-安装本地缓存" class="headerlink" title="2.安装本地缓存"></a>2.安装本地缓存</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240928200117383.png" alt="image-20240928200117383"></p><blockquote><p>还是同样的题目，只是现在多了本地Web缓存，且缓存命中率0.4</p></blockquote><p>40%的HTTP请求可以通过Web缓存获得</p><ul><li>本地时延$t_{1} &#x3D; 10ms$<ul><li>这个10ms是估算值，毕竟局域网带宽有1Gbps，大概在这个范围内</li></ul></li></ul><p>60%的HTTP请求需要接入链路</p><ul><li>本地时延10ms</li><li><strong>需要从链路回到客户端的数据速率变成原来的60%：0.6*1.5Mbps&#x3D;0.9Mbps</strong><ul><li>链路流量强度$I &#x3D; 0.9Mbps &#x2F; 1.54Mbps &#x3D; 58 %$</li><li>链路时延$t_{queue} &#x3D; (I&#x2F;1-I)·L&#x2F;R &#x3D; (0.58&#x2F;1-0&#x2F;58)·100kb&#x2F;1.54Mbps ≈ 80ms$</li></ul></li><li>因特网时延2s</li><li>总时延$t_{2} &#x3D; 10ms + 80ms + 2s &#x3D; 2.09s ≈ 2s$</li></ul><p>则最终的时延$t &#x3D; 0.4·t_{1} + 0.6·t_{2} &#x3D; 0.4·10ms + 0.6·2s &#x3D; 1.2s$</p><p><strong>使用Web缓存后的总体延迟不仅显著低于没有任何措施的时候，也低于提升链路带宽方法！！！</strong></p><h3 id="6-条件GET方法"><a href="#6-条件GET方法" class="headerlink" title="6.条件GET方法"></a>6.条件GET方法</h3><blockquote><p>Web缓存难道毫无问题吗？显然不可能。</p><p><strong>“源Web服务器更新了，但Web缓存没有更新”</strong>，这个问题怎么办？</p></blockquote><p>HTTP协议定义了一个方法：<strong>Conditional GET(条件GET)</strong></p><ul><li>目的：如果缓存器中的对象拷贝<strong>是最新的</strong>，就<strong>不需要源Web服务器发送对象</strong></li><li>处理：<ul><li>如果缓存是最新的，源Web服务器返回304，没有实体对象</li><li>如果缓存陈旧，服务器返回200并携带实体对象(entity body)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240928202102634.png" alt="image-20240928202102634"></p><ul><li>这就是HTTP响应报文中的<code>Last-Modified</code>起作用的地方</li></ul><hr><h2 id="3-FTP"><a href="#3-FTP" class="headerlink" title="3.FTP"></a>3.FTP</h2><p><strong>FTP</strong>，中文名称为<strong>文件传输协议</strong>，是较为古早的一种应用层文件传输协议，目前已逐渐被更受欢迎的<strong>HTTP协议</strong>取代</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240929201733890.png" alt="image-20240929201733890"></p><p><strong>性质：</strong></p><ul><li>向远程主机上传输文件或从远程主机接收文件</li><li>客户端&#x2F;服务器模式<ul><li>客户端：发起传输的一方</li><li>服务器：远程主机</li></ul></li><li><strong>FTP</strong>协议有两个连接，一个是<strong>持久</strong>的<strong>控制连接</strong>，一个是<strong>非持久</strong>的<strong>数据连接</strong><ul><li><strong>控制连接</strong>的<strong>端口号</strong>：<strong>21</strong>(一般我们说FTP的端口，就是指这个)</li><li><strong>数据连接</strong>的<strong>端口号</strong>：<strong>20</strong></li></ul></li><li><strong>FTP</strong>协议是建立在<strong>TCP连接</strong>之上的</li></ul><h3 id="1-控制连接与数据连接"><a href="#1-控制连接与数据连接" class="headerlink" title="1.控制连接与数据连接"></a>1.控制连接与数据连接</h3><blockquote><p>FTP协议的特殊之处在于，控制连接和数据连接是分开的</p></blockquote><p><strong>控制连接</strong>：</p><ul><li><strong>由客户端发起</strong>，位于端口21，是<strong>持久连接</strong></li><li>客户端通过控制连接获得<strong>身份确认</strong></li><li>客户端通过控制连接发送命令<strong>浏览远程目录</strong></li></ul><p><strong>数据连接</strong>：</p><ul><li>收到客户端发来的文件传输命令时，<strong>服务器端发起一个到客户端20端口的数据连接</strong></li><li>数据连接是<strong>非持久</strong>的，一次只能传递一个对象，之后就要拆除连接</li></ul><p><strong>注意</strong>：</p><ul><li>FTP的控制信息是**带外(out of band)**传送<ul><li>HTTP的控制信息是**带内(in-band)**传送</li></ul></li><li>FTP协议是<strong>有状态协议</strong>，会对每个活动用户会话的状态进行追踪与保留，也因此限制同时会话的总数<ul><li>HTTP是<strong>无状态协议</strong></li></ul></li></ul><h3 id="2-FTP命令及响应"><a href="#2-FTP命令及响应" class="headerlink" title="2.FTP命令及响应"></a>2.FTP命令及响应</h3><p>这部分不是重点，略过</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240929203750550.png" alt="image-20240929203750550"></p><h2 id="4-Email"><a href="#4-Email" class="headerlink" title="4.Email"></a>4.Email</h2><h3 id="1-电子邮件系统总体结构"><a href="#1-电子邮件系统总体结构" class="headerlink" title="1.电子邮件系统总体结构"></a>1.电子邮件系统总体结构</h3><p>Email系统有<strong>3个主要组成部分</strong>：</p><ul><li>用户代理</li><li>邮件服务器</li><li>简单邮件传输协议：<strong>SMTP</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240930125209953.png" alt="image-20240930125209953"></p><blockquote><p>电子邮件在邮件服务器中的地址：<strong>用户邮箱名@主机名</strong></p></blockquote><h4 id="1-用户代理"><a href="#1-用户代理" class="headerlink" title="1.用户代理"></a>1.用户代理</h4><p><strong>用户代理</strong>，又名”<strong>邮件阅读器</strong>“，允许用户阅读、回复、发送、保存和撰写报文</p><ul><li>用户希望发送邮件时，<strong>邮件代理向其邮件服务器发送邮件</strong>，并存放在<strong>该邮件服务器的发送队列</strong>中</li><li>用户希望读取邮件时，<strong>邮件代理从其邮件服务器中对应邮箱位置获取邮件报文</strong></li></ul><p>用户代理的种类有很多，最常见的是GUI，如Outlook和Foxmail等</p><h4 id="2-邮件服务器"><a href="#2-邮件服务器" class="headerlink" title="2.邮件服务器"></a>2.邮件服务器</h4><p>邮件服务器维护着两个数据结构：<strong>邮箱</strong>和<strong>报文队列</strong></p><ul><li>邮箱：发送给用户的报文</li><li>报文队列：用户要发出的邮件报文</li></ul><p>邮件发送的主要<strong>过程：</strong></p><ul><li>邮件保存到<strong>发送方</strong>邮件服务器的<strong>报文队列</strong></li><li>通过<strong>SMTP协议转发</strong>到接收方邮件服务器，保存到相应<strong>邮箱</strong></li><li>若投递失败，发送方将邮件保存在一个报文队列中，每隔30分钟再发一次，若数天后仍未成功，则删除该邮件并通知发送用户</li><li>用户访问自己邮箱时，邮件服务器对其身份进行验证(用户名和口令<code>psw</code>)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240930130305171.png" alt="image-20240930130305171"></p><h3 id="2-邮件传输协议SMTP"><a href="#2-邮件传输协议SMTP" class="headerlink" title="2.邮件传输协议SMTP"></a>2.邮件传输协议SMTP</h3><p>**作用：**从发送方的邮件服务器向接收方的邮件服务器发送邮件</p><p><strong>性质：</strong></p><ul><li>应用层协议</li><li>使用<strong>TCP</strong>可靠数据传输，<strong>端口号25</strong></li><li>使用<strong>持久连接</strong></li><li><strong>直接传输</strong>，<strong>不使用中间邮件服务器</strong>，直接在源邮件服务器和目的邮件服务器之间建立TCP连接<ul><li>传输的3个阶段：握手、传输报文、关闭</li></ul></li><li>报文(<strong>首部和主体</strong>)必须是<strong>7位<code>ASCII</code>码(base64)</strong></li></ul><p><strong>包括两部分：</strong></p><ul><li>客户机端：在发送方邮件服务器上运行</li><li>服务器端：在接收方邮件服务器上运行</li><li>每个邮件服务器既是客户端，也是服务器端，因此，<strong>SMTP的客户机端和服务器端在每个邮件服务器上都存在</strong></li></ul><h3 id="3-SMTP与HTTP比较"><a href="#3-SMTP与HTTP比较" class="headerlink" title="3.SMTP与HTTP比较"></a>3.SMTP与HTTP比较</h3><p><strong>共同点：</strong></p><ul><li>都用于从一台主机向另一台主机传送文件</li><li>都使用<strong>持久连接</strong></li></ul><p><strong>差异：</strong></p><ul><li><p><strong>HTTP</strong>是将报文<strong>从服务器发向客户端</strong>，<strong>SMTP</strong>是将报文<strong>从服务器发向服务器</strong></p></li><li><p><strong>HTTP</strong>是<strong>拉(pull)协议</strong>，也就是客户获取文件，<strong>TCP连接由想获取文件的机器发起</strong>；<strong>SMTP</strong>是<strong>推(push)协议</strong>，也就是客户发送文件，<strong>TCP连接由想发送文件的机器发起</strong></p></li><li><p><strong>SMTP</strong>要求报文使用**7位<code>ASCII</code>码(base64)**格式，<strong>HTTP</strong>没有这个要求</p></li><li><p>对于含有文本、图形或其他多媒体类型的文档：</p><ul><li><strong>HTTP</strong>将<strong>每个对象分别封装在各自的HTTP响应报文中</strong></li><li><strong>SMTP</strong>将<strong>所有报文对象放在一个报文中</strong></li></ul></li></ul><h3 id="4-邮件报文格式"><a href="#4-邮件报文格式" class="headerlink" title="4.邮件报文格式"></a>4.邮件报文格式</h3><p>以下是发送报文的格式，接收报文只需要在首部行中加上一个<code>Receive:</code>即可</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240930132038067.png" alt="image-20240930132038067"></p><blockquote><p>早期只需要传输文字，因此SMTP报文主体的格式就设定为7位<code>ASCII</code>码，因此不能发送可执行文件、图片等多媒体类型</p><p>但是如今，多媒体盛行，邮件传输也需要跟上时代</p></blockquote><p><strong>多媒体扩展：MIME</strong></p><ul><li><strong>MIME</strong>拓展的目的就在于实现<strong>非<code>ASCII</code>码数据传输</strong>，将非<code>ASCII</code>码数据编码后传输，接收方再解码还原</li><li>在<strong>发送报文首部</strong>用<strong>额外的行</strong>申明<strong>MIME</strong>内容类型</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240930132516333.png" alt="image-20240930132516333"></p><h3 id="5-邮件访问协议"><a href="#5-邮件访问协议" class="headerlink" title="5.邮件访问协议"></a>5.邮件访问协议</h3><blockquote><p>SMTP协议将邮件报文发送到了目的用户的邮件服务器上，那么，目的用户该怎么从邮件服务器上取到邮件呢？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240930132811926.png" alt="image-20240930132811926"></p><p><strong>邮件访问协议</strong>：用户主动请求(<strong>pull</strong>)，从服务器上访问邮件(与SMTP的<strong>push</strong>不同)</p><ul><li><strong>POP</strong>协议：邮局访问协议<ul><li>用户身份确认(用户代理与服务器进行)，然后下载邮件</li></ul></li><li><strong>IMAP</strong>协议：<strong>Internet</strong>邮件访问协议<ul><li>相比<strong>POP</strong>协议，更多特性，更复杂</li><li>在服务器上处理存储的报文</li></ul></li><li><strong>HTTP</strong>：基于Web的电子邮件访问</li></ul><h4 id="1-POP3协议"><a href="#1-POP3协议" class="headerlink" title="1.POP3协议"></a>1.POP3协议</h4><p><strong>POP3</strong>协议分为3个阶段：<strong>用户确认阶段</strong>、<strong>事务处理阶段</strong>和<strong>更新阶段</strong></p><p><strong>注意：</strong></p><ul><li><strong>POP3</strong>是<strong>无状态协议</strong></li><li><strong>POP3</strong>在用户浏览后，会给对应报文打上<code>delete</code>标签，在更新阶段<strong>删除邮件服务器上的邮件</strong></li></ul><h4 id="2-IMAP协议"><a href="#2-IMAP协议" class="headerlink" title="2.IMAP协议"></a>2.IMAP协议</h4><ul><li><p><strong>IMAP</strong>服务器会将每个报文与一个文件夹联系起来</p></li><li><p>允许用户用目录来组织报文(<strong>远程管理文件夹</strong>)</p></li><li><p>允许用户读取报文组件</p></li><li><p><strong>IMAP</strong>是<strong>有状态协议</strong>，在会话过程中保留用户状态</p><ul><li>目录名、报文ID和用户名之间映射</li></ul></li><li><p><strong>IMAP</strong>协议<strong>不会</strong>在用户阅览后<strong>自动删除邮件</strong>，只有发送删除命令才会</p></li></ul><h4 id="3-基于Web的电子邮件"><a href="#3-基于Web的电子邮件" class="headerlink" title="3.基于Web的电子邮件"></a>3.基于Web的电子邮件</h4><p>用户使用浏览器来收发电子邮件的技术，就是<strong>基于Web的电子邮件技术</strong></p><ul><li>用户与其远程邮箱之间的通信通过<strong>HTTP</strong>进行</li></ul><hr><h2 id="5-DNS"><a href="#5-DNS" class="headerlink" title="5.DNS"></a>5.DNS</h2><p><strong>DNS</strong>，全名<strong>Domain Name System</strong>，即域名系统，是<strong>应用层协议</strong></p><p>为什么会有DNS？</p><ul><li><p>主机、路由器的标识是<strong>IP</strong></p></li><li><p>但是如今的IPv4、IPv6不好记忆，不便于人类使用</p></li><li><p>人类倾向于使用一些有意义的字符串来标识互联网上的设备</p></li><li><p>因此，存在着**”字符串”与IP地址之间的转换的必要性**</p></li><li><p><strong>DNS</strong>就是负责将域名转换成二进制的网络IP地址的协议</p></li></ul><blockquote><p>但也因此，DNS系统需要解决几个问题：</p><p>问题1：如何命名设备？</p><ul><li>首先，名称要有意义，否则仍然不便于记忆</li><li>其次，为了避免重复，还需要层次化命名</li></ul><p>问题2：如何完成名字到IP地址的转换</p><p>问题3：如何维护：增删改查一个域？</p></blockquote><h3 id="1-DNS总体思路与目标"><a href="#1-DNS总体思路与目标" class="headerlink" title="1.DNS总体思路与目标"></a>1.DNS总体思路与目标</h3><p><strong>DNS主要思路</strong>：</p><ul><li><p><strong>分层</strong>的，基于**域(domain)**的命名机制</p></li><li><p>若干<strong>分布式</strong>数据库完成名字到IP地址的转换</p></li><li><p>运行在<strong>UDP</strong>协议上，<strong>端口号53</strong>的<strong>应用服务</strong></p></li><li><p><strong>DNS</strong>是<strong>Internet</strong>的<strong>核心功能</strong>，但却是以<strong>应用层协议</strong>来实现的</p><ul><li>在网络边缘实现了网络核心的功能——复杂性的体现</li></ul></li></ul><p><strong>DNS主要目的</strong>：</p><ul><li>实现**”主机名-IP地址”**的转换</li><li>其他目的<ul><li><strong>主机别名</strong>到<strong>规范名字</strong>的转换<ul><li>例如，<code>yale.edu</code>其实是<strong>主机别名</strong>，规范名字是标注有Web服务器所在的刀片服务器的各种信息的名称</li></ul></li><li><strong>邮件服务器别名</strong>到<strong>邮件服务器正规名字</strong>的转换<ul><li>例如，<code>hnu.edu.cn</code>是湖南大学邮件服务器的别名，需要转换到邮件服务器正规名字</li></ul></li><li><strong>负载均衡</strong></li></ul></li></ul><h3 id="2-DNS名字空间"><a href="#2-DNS名字空间" class="headerlink" title="2.DNS名字空间"></a>2.DNS名字空间</h3><blockquote><p>回答问题1：如何命名设备？</p></blockquote><p><strong>DNS域名结构</strong>：</p><ul><li><p><strong>DNS</strong>采用<strong>层次树状结构</strong>的命名方法</p></li><li><p><strong>Internet 根</strong>被划分为数百个<strong>顶级域</strong>：</p><ul><li><strong>通用的(generic)</strong><ul><li><code>.com, .edu, .gov, .int, .net, .org, ....</code></li></ul></li><li><strong>国家的(countries)</strong><ul><li><code>.cn, .us, .nl, .jp</code></li></ul></li></ul></li><li><p><strong>每个域</strong>下面可划分为<strong>若干子域</strong></p></li><li><p>层次树状结构的<strong>树叶，就是主机</strong></p></li></ul><h4 id="1-根名字服务器"><a href="#1-根名字服务器" class="headerlink" title="1.根名字服务器"></a>1.根名字服务器</h4><p>全球共计13个根名字服务器，位于北美、欧洲、日本</p><p>根名字服务器可做镜像</p><h4 id="2-域名"><a href="#2-域名" class="headerlink" title="2.域名"></a>2.域名</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240930164126272.png" alt="image-20240930164126272"></p><p><strong>域名(Domain Name)：</strong></p><ul><li>从本域往上，直到树根，中间用”.”间隔不同的级别<ul><li>主机永远是树叶，而域是树根</li><li>例如：<code>ustc.edu.cn</code>，<code>cs.yale.edu</code>等</li></ul></li><li><strong>域的域名</strong>：标识一个域(从树枝往上走)<ul><li>例如上图中的：<code>cs.yale.edu</code>就是耶鲁计算机系的域</li></ul></li><li><strong>主机的域名</strong>：标识一个域中的一个主机(从树叶往上走)<ul><li>例如上图中的：<code>linda.cs.yale.edu</code>就是耶鲁计算机系域中的一台主机</li></ul></li></ul><p><strong>域名的管理：</strong></p><ul><li>一个域管理其下的<strong>子域</strong><ul><li>例如，<code>.jp</code>被划分为<code>ac.jp</code>，<code>co.jp</code>等；而<code>.cn</code>被划分为<code>edu.cn</code>，<code>com.cn</code>等</li></ul></li><li>创建一个新的域，必须征得它所属域的同意</li></ul><p><strong>域与物理网络无关：</strong></p><ul><li>域遵从组织界限，而不是物理网络<ul><li>说人话就是，<strong>一个域的主机可以不在一个网络中</strong>，<strong>一个网络的主机不一定在一个域</strong></li></ul></li><li>域的划分是<strong>逻辑</strong>的，而不是<strong>物理</strong>的</li></ul><h3 id="3-名字服务器"><a href="#3-名字服务器" class="headerlink" title="3.名字服务器"></a>3.名字服务器</h3><blockquote><p>回答问题2：如何完成名字到IP地址的转换</p><p><strong>名字服务器(Name Server)</strong>，就是提供<strong>名字与IP对应</strong>的数据库供客户请求时进行查找转换的工具</p></blockquote><h4 id="1-only-one-name-server"><a href="#1-only-one-name-server" class="headerlink" title="1.only one name server?"></a>1.only one name server?</h4><p><strong>只有一个名字服务器</strong>必然会导致一系列的问题：</p><ul><li>**可靠性问题：**单点故障</li><li>**扩展性问题：**通信容量</li><li>**维护性问题：**远距离的集中式数据库</li></ul><h4 id="2-区域Zone"><a href="#2-区域Zone" class="headerlink" title="2.区域Zone"></a>2.区域Zone</h4><blockquote><p><strong>区域</strong>就是用来替代”<strong>只有一个名字服务器</strong>“的方案，<strong>将整个DNS名字空间划分成若干区域</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007203612407.png" alt="image-20241007203612407"></p><ul><li>区域的划分由<strong>区域管理者决定</strong></li><li>将DNS名字空间划分为<strong>互不相交</strong>的区域，每个区域都是树的一部分</li></ul><p><em>那么，划分出区域后，名字服务器又该怎么部署？</em></p><ul><li><strong>每个区域</strong>都有1个<strong>权威名字服务器</strong>，用来维护区域内<strong>域名与IP映射的权威信息</strong><ul><li>当然，权威名字服务器是<strong>做冗余设计的</strong>，也就是权威名字服务器不止一个</li></ul></li><li><strong>子域</strong>如果因为自身流量需求大等原因，<strong>需要自己的权威名字服务器</strong>，那么是<strong>允许</strong>的<ul><li>如果是这样，那么区域的权威名字服务器只需要一个<strong>指向子域权威名字服务器的”指针”记录</strong>即可(见后)，<strong>子域内的所有映射关系</strong>就<strong>不保存</strong>在<strong>区域权威名字服务器</strong>中了</li></ul></li><li>名字服务器<strong>允许被放置在区域之外</strong>，以保障可靠性</li></ul><h4 id="3-TLD服务器"><a href="#3-TLD服务器" class="headerlink" title="3.TLD服务器"></a>3.TLD服务器</h4><p>**顶级域(TLD)服务器：**负责通用顶级域名(如<code>com, org, net, edu</code>)和所有国家级的顶级域名(如<code>cn, uk, fr, ca, jp</code>)</p><h4 id="4-资源记录"><a href="#4-资源记录" class="headerlink" title="4.资源记录"></a>4.资源记录</h4><blockquote><p><strong>区域权威名字服务器</strong>维护的内容的名字是：资源记录(resource records)，简称RR</p></blockquote><p><strong>资源记录</strong>：</p><ul><li>**作用：**维护 <strong>域名-IP地址映射</strong>&#x2F;&#x2F;<strong>别名-规范名映射</strong>&#x2F;&#x2F;<strong>邮件服务器别名-邮件服务器正式名</strong>&#x2F;&#x2F;<strong>子域信息</strong> 这几种映射关系</li><li>**位置：**Name Server的分布式数据库中</li></ul><p><strong>RR格式：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">(domain_name, ttl, type, class, value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>domain_name</strong>：域名</p></li><li><p><strong>ttl</strong>：全称<code>time to live</code>，即<strong>生存时间</strong>，决定RR应当从缓存中删除的倒计时</p><ul><li>分为两种：<strong>权威</strong>和<strong>缓冲记录</strong></li><li><strong>权威</strong>的TTL相当大，类似于<strong>持久化</strong></li><li><strong>缓冲记录</strong>的TTL一般不大，<strong>通常是2天</strong>，2天后就会删除这条RR<ul><li>缓冲记录一般是将其他名字服务器的RR临时保存在本地的，因此为了一致性考虑，不能持久化</li></ul></li></ul></li><li><p><strong>class</strong>：类别，对于<code>Internet</code>因特网协议栈，值通常是<strong>IN</strong></p><ul><li>当下，有些RR格式中省略了<code>class</code>，这表明它们默认<code>class==IN</code></li></ul></li><li><p><strong>value</strong>：可以是数字&#x2F;域名&#x2F;ASCII串(取决于是哪种资源记录)</p></li><li><p><strong>type</strong>：类型，指资源记录的类型，具体见下图</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007214807615.png" alt="image-20241007214807615"></p><h4 id="5-工作过程"><a href="#5-工作过程" class="headerlink" title="5.工作过程"></a>5.工作过程</h4><ul><li><p>应用调用<strong>解析器(resolver)</strong></p></li><li><p>解析器作为客户，向名字服务器发出查询报文(<strong>封装在UDP段中</strong>)</p></li><li><p>名字服务器返回响应报文</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007215047895.png" alt="image-20241007215047895"></p><h4 id="6-本地名字服务器"><a href="#6-本地名字服务器" class="headerlink" title="6.本地名字服务器"></a>6.本地名字服务器</h4><p>本地名字服务器，即<code>Local Name Server</code></p><ul><li>并不严格属于层次结构</li><li>每个ISP都有一个本地DNS服务器，也就是本地名字服务器<ul><li>也称之为”默认名字服务器“</li></ul></li><li>当一个主机发起一个DNS查询时，查询被发送到其本地DNS服务器<ul><li>本地名字服务器其实起着代理的作用，将查询转发到层次结构中</li><li>如果查询在本地名字服务器中找到，就不需要再向互联网中发送查询了</li></ul></li></ul><h4 id="7-名字解析过程"><a href="#7-名字解析过程" class="headerlink" title="7.名字解析过程"></a>7.名字解析过程</h4><ul><li><strong>如果目标名字的资源记录保存在Local Name Server中</strong><ul><li>本地名字服务器将IP&#x2F;name发回客户端</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007215919368.png" alt="image-20241007215919368"></p><ul><li><p><strong>如果不在：</strong></p><ul><li>有两种查询方式，一种是<strong>递归查询</strong>，一种是<strong>迭代查询</strong>，<strong>迭代查询</strong>是目前真正的查询方式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007220037597.png" alt="image-20241007220037597"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007220113143.png" alt="image-20241007220113143"></p><p><strong>如何提高性能？——缓存(cache)</strong></p><ul><li>一旦名字服务器学到了一个映射，就将该映射<strong>缓存</strong>起来</li><li><strong>根服务器</strong>通常都在本地名字服务器中缓存着<ul><li>这使得根名字服务器不用经常被访问</li></ul></li><li>目的：<strong>提高效率</strong></li><li>可能存在的问题：<strong>一致性</strong>，远程更新了本地还是旧的</li><li>解决方案：<strong>TTL</strong>(默认2天)</li></ul><h3 id="4-DNS协议"><a href="#4-DNS协议" class="headerlink" title="4.DNS协议"></a>4.DNS协议</h3><p>DNS协议中，<strong>查询报文</strong>和<strong>响应报文</strong>的<strong>报文格式相同</strong></p><p>其中最关键的是<strong>标识符identification</strong>：</p><ul><li>16bit，用于标识该查询，会被复制到对查询的响应报文中，以便让客户用它来匹配发送的请求和接收到的回答</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007221704237.png" alt="image-20241007221704237"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007221716654.png" alt="image-20241007221716654"></p><h3 id="5-新增域"><a href="#5-新增域" class="headerlink" title="5.新增域"></a>5.新增域</h3><blockquote><p>回答问题3：如何维护：增删改查一个域？</p></blockquote><p><strong>如何新增一个域？</strong></p><ul><li>在上级域的权威名字服务器中增加两条RR，指向这个新增子域的域名和域名服务器的地址</li><li>在新增子域的名字服务器上运行DNS解析服务，负责本域的名字解析</li></ul><p>示例：在<code>com</code>域中建立一个<code>Network Utopia</code>(乌托邦)</p><ul><li><p>在<code>com</code>域的<code>TLD顶级域名字服务器</code>中插入两条RR记录：</p><ul><li>(networkutopia.com, dns1.networkutopia.com, NS)<ul><li>乌托邦域名——&gt;乌托邦权威名字服务器域名</li></ul></li><li>(dns1.networkutopia.com, 212.212.212.1, A)<ul><li>乌托邦域名规范名——&gt;乌托邦域名权威名字服务器IP</li></ul></li></ul></li><li><p>在<code>networkutopia.com</code>的权威名字服务器中确保有：</p><ul><li>用于<strong>Web服务器</strong>的<code>www.networkutopia.com</code>的<strong>类型为A</strong>的RR</li><li>用于<strong>邮件服务器</strong>的<code>mail.networkutopia.com</code>的<strong>类型为MX</strong>的RR</li></ul></li></ul><p><em>删、改的方法类似</em></p><h3 id="6-攻击DNS"><a href="#6-攻击DNS" class="headerlink" title="6.攻击DNS"></a>6.攻击DNS</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007224857120.png" alt="image-20241007224857120"></p><hr><h2 id="6-套接字编程"><a href="#6-套接字编程" class="headerlink" title="6.套接字编程"></a>6.套接字编程</h2><p>套接字编程，即<strong>Socket编程</strong>。根据因特网协议栈中提供的两种传输层协议(TCP&#x2F;UDP)，有两种Socket类型，因此就有两种Socket编程</p><p>需要注意的是：</p><ul><li><strong>开发者</strong>可控制<strong>Socket应用层端</strong></li><li><strong>操作系统(OS)<strong>控制</strong>Socket运输层端</strong>，用户不可控制这部分</li></ul><h3 id="1-TCP套接字编程"><a href="#1-TCP套接字编程" class="headerlink" title="1.TCP套接字编程"></a>1.TCP套接字编程</h3><p><strong>TCP套接字</strong>需要注意的点是：</p><ul><li>服务器端通常会存在一个**”欢迎Socket”**，用来监听网络中的连接请求</li><li>如果出现了发往所在服务器的连接请求，<strong>“欢迎Socket”<strong>接收这个请求，并</strong>创建</strong>一个**”连接Socket”<strong>来专门处理这个连接请求以及后续的通信，</strong>“欢迎Socket”继续监听**网络中的连接请求</li><li>当然，现在为了提高性能，大部分的Web服务器只有一个**”欢迎Socket”进程**，出现连接请求后<strong>创建</strong>一个**”连接Socket”线程**来服务这一连接</li></ul><p><strong>专业术语</strong>：</p><ul><li><strong>流</strong>：流入或流出某进程的一串字符序列</li><li><strong>输入流</strong>：来自某个输入源(如键盘)、或某个套接字(因特网的数据流入套接字)</li><li><strong>输出流</strong>：到某个输出源(如显示器)、或某个套接字(数据通过套接字流向因特网)</li></ul><h4 id="1-TCP连接具体过程"><a href="#1-TCP连接具体过程" class="headerlink" title="1.TCP连接具体过程"></a>1.TCP连接具体过程</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007233005919.png" alt="image-20241007233005919"></p><h4 id="2-TCP-Socket编程"><a href="#2-TCP-Socket编程" class="headerlink" title="2.TCP Socket编程"></a>2.TCP Socket编程</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007233053539.png" alt="image-20241007233053539"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007233104719.png" alt="image-20241007233104719"></p><p><strong>具体代码省略</strong></p><h3 id="2-UDP套接字编程"><a href="#2-UDP套接字编程" class="headerlink" title="2.UDP套接字编程"></a>2.UDP套接字编程</h3><h4 id="1-UDP连接具体过程"><a href="#1-UDP连接具体过程" class="headerlink" title="1.UDP连接具体过程"></a>1.UDP连接具体过程</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007233221562.png" alt="image-20241007233221562"></p><h4 id="2-UDP-Socket编程"><a href="#2-UDP-Socket编程" class="headerlink" title="2.UDP Socket编程"></a>2.UDP Socket编程</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241007233243741.png" alt="image-20241007233243741"></p><p><strong>具体代码省略</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记</title>
      <link href="/2024/09/22/ji-wang-xue-xi-bi-ji/"/>
      <url>/2024/09/22/ji-wang-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><h2 id="1-什么是因特网"><a href="#1-什么是因特网" class="headerlink" title="1.什么是因特网"></a>1.什么是因特网</h2><blockquote><p>回答这个问题有两种方式：</p><p>从<strong>具体构成</strong>的角度来讲，因特网是<strong>构成因特网的基本硬件和软件</strong></p><p>从<strong>提供服务</strong>的角度来讲，因特网是<strong>为分布式应用程序提供的服务</strong></p></blockquote><h3 id="1-具体构成"><a href="#1-具体构成" class="headerlink" title="1.具体构成"></a>1.具体构成</h3><p>公共因特网：</p><ul><li>一个世界范围的计算机网络</li><li>互联全球的数百亿的计算设备</li><li>“网络的网络”</li></ul><p><strong>因特网具体由以下几个部分组成：</strong></p><h4 id="1-计算设备"><a href="#1-计算设备" class="headerlink" title="1.计算设备"></a>1.计算设备</h4><ul><li><p>传统设备：桌面PC、工作站、服务器等</p></li><li><p>非传统设备：手机、TV、移动计算机、汽车等</p></li></ul><p>上述所有的这些设备称为<strong>主机(host)</strong>，又称为<strong>端系统(end system)</strong></p><ul><li>主要功能：进行数据处理，运行网络应用程序</li></ul><h4 id="2-连网设备"><a href="#2-连网设备" class="headerlink" title="2.连网设备"></a>2.连网设备</h4><p>包括：</p><ul><li><strong>通信链路</strong></li><li><strong>分组交换机</strong></li></ul><p>主要功能：保证高效、可靠地数据传输</p><p><strong>通信链路：</strong></p><p>把端系统连接到一起的<strong>物理线路</strong></p><ul><li>类型和速率不同</li><li><strong>链路传输速率：<strong>每秒传输多少</strong>位(bit)<strong>数据，单位</strong>bps(bit&#x2F;s)</strong></li></ul><p><strong>分组交换机：</strong></p><p>连接端系统的<strong>中间交换设备</strong>。端系统之间很少直接连接，通常都是通过分组交换机<strong>间接连接</strong></p><ul><li>功能：<strong>接收、转发分组</strong><ul><li>采用<em>分组交换技术</em>，从一条通信链路接收分组并保存，再从另一条通信链路转发出去</li></ul></li><li>类型：<ul><li><strong>路由器(router)</strong></li><li><strong>链路层交换机(link-layer switch)</strong></li></ul></li></ul><blockquote><p>什么是<strong>分组交换技术(packet switching)</strong>？</p><p>发送端将想要发送的数据分成若干较小的<strong>块</strong>，<strong>添加首部形成分组(又称包，packet)</strong>，<strong>分别</strong>发送到目的端，再<strong>组装</strong>恢复成原数据。</p><p>相关术语：</p><ul><li><strong>路径(route或path)</strong>：一个分组从发送端系统传输到接收端系统，所经过的一系列通信链路和分组交换机</li><li>端系统之间通信的路径<strong>不专用</strong></li><li>多个通信端系统<strong>同时共享一条路径或一部分</strong></li></ul></blockquote><h4 id="3-ISP"><a href="#3-ISP" class="headerlink" title="3.ISP"></a>3.ISP</h4><p><strong>ISP</strong>，即<strong>因特网服务提供商</strong>，是一个由多个交换机和多段通信链路组成的网络。端系统通过ISP接入因特网。</p><ul><li>不同的ISP提供不同类型的网络接入</li><li>对内容提供者提供接入</li><li>低层次的ISP通过国家、国际的高层ISP互联，实现世界范围通信</li><li>每个ISP独立管理，运行ISP协议</li></ul><h4 id="4-协议-protocol"><a href="#4-协议-protocol" class="headerlink" title="4.协议(protocol)"></a>4.协议(protocol)</h4><p>控制网络中<strong>信息接收和发送</strong>的一组<strong>软件</strong>。每个端系统、路由器和其他因特网部件都要运行</p><ul><li>因特网协议：<strong>TCP&#x2F;IP协议</strong><ul><li><strong>TCP</strong>：传输控制协议</li><li><strong>IP</strong>：网际协议</li></ul></li><li>因特网标准：<strong>由IETF制定的标准文档RFC</strong></li></ul><h4 id="5-内联网"><a href="#5-内联网" class="headerlink" title="5.内联网"></a>5.内联网</h4><p><strong>专用的内部网络</strong></p><ul><li>所用的主机、路由器、链路和协议等与因特网相同</li><li>专网内的主机<strong>不能随意与专网外部的主机交换信息</strong>(由防火墙控制)</li></ul><h3 id="2-服务描述"><a href="#2-服务描述" class="headerlink" title="2.服务描述"></a>2.服务描述</h3><p>前文提及过，从服务描述的角度来说，因特网是<strong>为分布式应用程序提供的服务</strong>。</p><ul><li><p><strong>分布式应用程序</strong>：在<strong>端系统</strong>上运行，彼此可以通信。实现因特网的各种应用，如电子邮件、Web应用、远程注册等等</p></li><li><p><strong>提供两种服务</strong>：</p><ul><li><strong>面向连接的可靠服务</strong>：确保从发送方发出的数据最终按顺序完整地交付给接收方</li><li><strong>无连接的不可靠的服务</strong>：不能对最终交付作任何保证，但传输效率高</li><li>任何一种分布式应用程序只能使用其中一种服务</li></ul></li><li><p><strong>不提供&quot;传输时间固定&quot;的服务</strong></p><ul><li>从发送方传递数据到接收方所需时间不确定</li></ul></li></ul><h3 id="3-什么是协议"><a href="#3-什么是协议" class="headerlink" title="3.什么是协议"></a>3.什么是协议</h3><p>如前文所述，<strong>协议是控制网络中信息接收和发送的一组软件</strong></p><p>协议由某些设备的硬件或软件执行</p><p>因特网中所有活动，都受协议制约。</p><blockquote><p>协议：控制网络中信息的发送和接收。</p><p><strong>定义了在两个或多个通信实体之间交换的报文格式和顺序，以及报文发送和&#x2F;或接收一条报文或其他事件所采取的动作。</strong></p><p><strong>不同的协议完成不同的通信任务。</strong></p></blockquote><hr><h2 id="2-网络边缘"><a href="#2-网络边缘" class="headerlink" title="2.网络边缘"></a>2.网络边缘</h2><blockquote><p>网络划分为两大部分：</p><ul><li>网络边缘(又称&quot;资源子网&quot;)<ul><li>外围部件、主机</li><li>网络应用</li></ul></li><li>网络核心(又称&quot;通信子网&quot;)<ul><li>路由器</li><li>通信链路</li><li>网络的网络</li></ul></li></ul></blockquote><p>这一节，我们主要研究的是<strong>网络边缘</strong></p><h3 id="1-端系统、客户机和服务器"><a href="#1-端系统、客户机和服务器" class="headerlink" title="1.端系统、客户机和服务器"></a>1.端系统、客户机和服务器</h3><ul><li><p>端系统</p><ul><li>端系统(end system)，又叫主机(host)，<strong>这两者同义</strong></li><li>在网络的边缘</li><li>主要功能是数据运算和<strong>运行应用程序</strong></li></ul></li><li><p>端系统分类</p><ul><li><strong>客户机(client)</strong></li><li><strong>服务器(server)</strong></li></ul></li><li><p>应用程序模式</p><ul><li>客户机&#x2F;服务器(C&#x2F;S模式)</li><li>对等共享(P2P模式)</li><li>混合</li><li>…</li></ul></li></ul><h3 id="2-无连接和面向连接的服务"><a href="#2-无连接和面向连接的服务" class="headerlink" title="2.无连接和面向连接的服务"></a>2.无连接和面向连接的服务</h3><p>端系统之间通过使用因特网提供的服务来传输报文，进行通信</p><ul><li><strong>因特网服务类型</strong><ul><li>面向连接服务</li><li>无连接服务</li></ul></li></ul><h4 id="1-面向连接服务"><a href="#1-面向连接服务" class="headerlink" title="1.面向连接服务"></a>1.面向连接服务</h4><blockquote><p>两个端系统之间交换数据时，要先通过**”握手过程”**建立连接，然后才发送实际数据</p><ul><li>握手过程：<strong>互相发送”控制”分组</strong>，使双方做好接收后面数据分组的准备，即<strong>在两个端系统之间创建连接</strong><ul><li>正常的面向连接服务，前两个报文(A发B，B发A)是握手报文，不含实际数据</li></ul></li><li>实际上，<strong>“握手过程”<strong>是</strong>3次握手</strong><ul><li>我们假设A主机希望和B主机建立面向连接的服务(如TCP)</li><li><strong>第一次握手</strong>：A（客户端）向B（服务器）发送一个SYN（同步）报文段。这个报文段是用来请求建立连接的，里面包含一个初始的序列号。此时，A进入”SYN_SENT”状态。</li><li><strong>第二次握手</strong>：B（服务器）收到A的SYN报文后，返回一个SYN+ACK（同步+确认）报文，表示同意连接并确认A的SYN报文（ACK是对A序列号的确认）。B还会发送自己的序列号给A。这时，B进入”SYN_RCVD”状态。</li><li><strong>第三次握手</strong>：A收到B的SYN+ACK后，再发送一个ACK（确认）报文给B，确认B的序列号。此时，A进入”ESTABLISHED”状态，表示连接已经建立成功，B收到ACK报文后也进入”ESTABLISHED”状态。</li><li>只不过，在<strong>第三次握手</strong>时，我们也可以同时发送需要的请求或数据到目标主机，这种情况在TCP协议中称为<strong>TCP<br>Fast Open</strong></li></ul></li></ul></blockquote><p><strong>特性：</strong></p><ul><li>可靠的数据传输</li><li>流控制(flow control)</li><li>拥塞控制</li></ul><p><em>注意，有些面向连接服务只具备上述特性的部分</em></p><h5 id="1-可靠的数据传输"><a href="#1-可靠的数据传输" class="headerlink" title="1.可靠的数据传输"></a>1.可靠的数据传输</h5><p>应用程序通过该连接可以<strong>无差错、按序地传递</strong>所有数据。</p><ul><li><p><strong>确认：<strong>当接收端收到发送端发送的</strong>分组的全部</strong>时，<strong>要回发一个”确认”</strong>，使发送端知道相应的分组已被接收</p></li><li><p>**重传：**如果发送端系统没有收到任何”确认”，认为发送的分组没有被接收方收到，<strong>重传该分组</strong></p></li></ul><h5 id="2-流控制"><a href="#2-流控制" class="headerlink" title="2.流控制"></a>2.流控制</h5><p>确保任何一方都<strong>不会过快地发送过量的分组</strong>而造成分组丢失</p><ul><li><strong>控制发送速率：</strong><ul><li>当接收方来不及接收时，发送端降低发送速率</li></ul></li></ul><h5 id="3-拥塞控制"><a href="#3-拥塞控制" class="headerlink" title="3.拥塞控制"></a>3.拥塞控制</h5><p>防止因特网进入<strong>迟滞状态</strong></p><ul><li><strong>主要问题</strong>：<ul><li><strong>路由器拥塞。<strong>其缓存出现</strong>溢出和分组丢失</strong></li><li>如果情况持续，则<strong>几乎不会有分组能传递到目的地</strong></li></ul></li><li>解决方法：<ul><li><strong>控制发送速率</strong></li></ul></li></ul><h5 id="4-服务示例"><a href="#4-服务示例" class="headerlink" title="4.服务示例"></a>4.服务示例</h5><p><strong>传输控制协议TCP</strong></p><ul><li>使用TCP的应用程序：SMTP(电子邮件)、FTP(文件传输)、HTTP(Web)、Telnet(远程注册)等</li></ul><h4 id="2-无连接服务"><a href="#2-无连接服务" class="headerlink" title="2.无连接服务"></a>2.无连接服务</h4><blockquote><p>两个端系统之间交换数据时，<strong>不需要”握手过程”</strong>，可直接发送分组，数据传递更快</p></blockquote><p><strong>特性</strong></p><ul><li>不可靠</li><li>无流控制&#x2F;拥塞控制</li></ul><p><strong>服务示例</strong></p><p><strong>用户数据报协议UDP</strong></p><ul><li>使用UDP的应用程序：因特网电话、视频会议、DNS服务等</li></ul><hr><h2 id="3-网络核心"><a href="#3-网络核心" class="headerlink" title="3.网络核心"></a>3.网络核心</h2><blockquote><p>网络核心，又称&quot;通信子网&quot;。</p><p>网络核心的本质是：<em>连接端系统的</em> <strong>分组交换机和链路形成的网状网络</strong></p><p>那么问题来了，数据是如何通过网络传送的呢？</p><p>答案是：<strong>电路交换</strong>和<strong>分组交换</strong>！</p></blockquote><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1.电路交换"></a>1.电路交换</h3><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h4><p>通信双方建立一个<strong>专用的连接(电路)</strong>，一直维持，直到通信结束</p><p>以<strong>电路交换网络</strong>为例：</p><ul><li><strong>每条链路可有n条电路</strong>，能支持n条同步连接</li><li><strong>通信过程中</strong>，主机A、B之间创建一条专用的端到端连接，分别占用<strong>每条链路中的一条电路</strong>，该连接获得链路带宽的$1&#x2F;n$，进行通信</li></ul><h4 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h4><ul><li>链路带宽，交换能力</li><li>专用资源，不共享</li><li>保证性能</li><li>要求建立呼叫连接</li></ul><h4 id="3-多路复用"><a href="#3-多路复用" class="headerlink" title="3.多路复用"></a>3.多路复用</h4><blockquote><p>多路复用是指，在一条传输链路上同时<strong>建立多条连接</strong>，分别传输数据</p></blockquote><p>电路交换的多路复用有两种方式：</p><ul><li><strong>频分复用FDM</strong>：每条连接专用一个频段<ul><li><strong>带宽</strong>：频段的宽度$B&#x3D;f_{high}−f_{low}$。如，4kHZ</li></ul></li><li><strong>时分复用TDM</strong>：时间划分为固定区间的<strong>帧</strong>，每帧再划分为固定数量的<strong>时隙</strong>，每个时隙专用于一个连接</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240922211329829.png" alt="image-20240922211329829"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240922211348015.png" alt="image-20240922211348015"></p><h4 id="4-缺陷"><a href="#4-缺陷" class="headerlink" title="4.缺陷"></a>4.缺陷</h4><ul><li>效率低，静默期浪费链路<ul><li><strong>无数据传输</strong>就是静默期</li></ul></li><li>创建端到端电路以及预留端到端带宽的过程复杂</li></ul><h4 id="5-示例"><a href="#5-示例" class="headerlink" title="5.示例"></a>5.示例</h4><blockquote><p><strong>从主机A到主机B。已知：</strong></p><ul><li><strong>文件大小640kb ，链路传输速率是1.536 Mb&#x2F;s</strong></li><li><strong>每条链路使用具有24个时隙的TDM</strong></li><li><strong>创建端到端电路需500 ms</strong></li></ul></blockquote><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">1.发送一个文件的时间=创建电路时间+文件传输时间2.每条电路的传输速率 = 1.536/24 = 0.064 Mb/s = 64kb/s (1024≅1000)3.文件传输时间 = 文件大小/电路传输速率 = 640kb/ 64kb/s = 10s4.发送时间 = 创建+传输 = 10 + 0.5 = 10.5s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2.分组交换"></a>2.分组交换</h3><h4 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1.工作原理"></a>1.工作原理</h4><blockquote><p>端系统之间传递数据的方式，就是<strong>彼此交换报文</strong>。报文可以执行控制功能，也可以包含数据。分组交换网络传递的就是报文，但不是直接传送</p></blockquote><p><strong>工作过程</strong>：</p><ul><li><p>源主机端，将报文划分成较小的<strong>数据块(又称分组，packet)</strong></p></li><li><p>每个分组通过一系列链路和分组交换机传送，到达目的主机端</p><ul><li><strong>注意，每个分组不一定走一样的路径！</strong></li><li><strong>分组交换机一大作用就是根据分组选择转发到哪条输出链路上</strong></li></ul></li><li><p>目的端恢复原报文</p></li><li><p><strong>分组以链路的最大传输速率传输</strong></p></li><li><p>传输过程中采用<strong>存储转发传输</strong>机制</p></li></ul><h4 id="2-存储转发传输"><a href="#2-存储转发传输" class="headerlink" title="2.存储转发传输"></a>2.存储转发传输</h4><p><strong>分组交换机</strong>先将输入端的<strong>整个分组</strong>接受下来(<strong>存储</strong>)</p><p>再从输出链路转发传输出去(<strong>转发</strong>)</p><ul><li><strong>转发第一个bit前，必须接收到整个分组</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240922212722532.png" alt="image-20240922212722532"></p><h4 id="3-相关参数"><a href="#3-相关参数" class="headerlink" title="3.相关参数"></a>3.相关参数</h4><ul><li><strong>传输时延</strong><ul><li>将分组中的所有<code>bit</code>推送到输出链路的用时</li><li>若一个分组长<code>L bit</code>，链路速率是<code>R bps</code>，传输时延&#x3D;<code>L/R s</code></li></ul></li><li><strong>输出缓存(输出队列)</strong><ul><li>等待在出口的分组缓存</li><li>每条相连的链路都对应一个输出缓存</li></ul></li><li><strong>排队时延</strong><ul><li>分组在输出缓存中<strong>等待转发</strong>的时间</li></ul></li><li><strong>分组丢失</strong><ul><li>当<strong>缓存空间已满</strong>时，多的分组被丢弃</li><li><strong>丢包!</strong></li></ul></li></ul><h4 id="4-端到端时延"><a href="#4-端到端时延" class="headerlink" title="4.端到端时延"></a>4.端到端时延</h4><p>端到端时延 &#x3D; 总传输时延 + 总排队时延 + 总传播时延(在链路上传播的用时)</p><p>具体定义见1.6节！！！</p><p><strong>示例</strong>：</p><blockquote><p>设两台主机之间有Q段链路，每条速率是R bit&#x2F;s，分组长L<br>bit，忽略排队时延和端到端传播时延。问一个分组的端到端时延&#x3D;?</p></blockquote><ul><li><p><strong>每条链路传输时延 ：</strong> <strong>L&#x2F;R</strong> <strong>s</strong></p></li><li><p><strong>经过中间路由器存储转发</strong> <strong>Q-</strong> <strong>1</strong> <strong>次</strong> <strong>到目的地。</strong></p></li><li><p><strong>总时延：</strong> <strong>$Q*L&#x2F;R  s$</strong></p></li></ul><blockquote><p>如果分组数目&#x3D;P，经过N条链路序列的端到端时延&#x3D;?</p></blockquote><ul><li><p>第一个分组到达目的端时延： <strong>$Q*L&#x2F;R  s$</strong></p></li><li><p>剩下的分组每隔<strong>L&#x2F;R</strong>秒到达目的端，供<strong>P-1</strong>次：$(P-1) \cdot L&#x2F;R$</p></li><li><p>总时延：$(Q + P-1) \cdot L&#x2F;R$</p></li></ul><blockquote><p>需要注意的是，上面的计算是基于一个特例：<strong>所有的P个分组都走同一条路径</strong>。现实中不太可能，因此就不会是每隔L&#x2F;R秒抵达一个分组</p></blockquote><h4 id="5-分组交换网络类型"><a href="#5-分组交换网络类型" class="headerlink" title="5.分组交换网络类型"></a>5.分组交换网络类型</h4><ul><li><strong>虚电路网络</strong><ul><li>需要专门连接，预留端到端连接时间</li><li>交换机根据<strong>分配的虚电路号</strong>转发分组<ul><li>分组的路径是<strong>固定死的</strong></li></ul></li></ul></li><li><strong>数据报网络</strong><ul><li>不需要连接</li><li>交换机根据<strong>目的地址</strong>转发分组<ul><li>根据实际的链路及输出缓存情况选择路径</li></ul></li></ul></li></ul><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>根据<strong>工作方式</strong>区分电信网络：</p><ul><li>电路交换网络<ul><li>FDM</li><li>TDM</li></ul></li><li>分组交换网络<ul><li>虚电路网络</li><li>数据报网络</li></ul></li></ul><p>根据<strong>作用范围</strong>分：</p><ul><li>局域网LAN<ul><li>&lt;10 km</li></ul></li><li>城域网或市域网MAN<ul><li>10km&lt; &lt;100km</li></ul></li><li>广域网WAN<ul><li>10km&lt; &lt; 10000km</li></ul></li></ul><p>根据<strong>使用范围</strong>分：</p><ul><li>公用网</li><li>专用网</li></ul><hr><h2 id="4-接入网与网络媒体"><a href="#4-接入网与网络媒体" class="headerlink" title="4.接入网与网络媒体"></a>4.接入网与网络媒体</h2><blockquote><p>接入网：将端系统<strong>物理连接</strong>到其<strong>边缘路由器</strong>的网络</p><p>边缘路由器：从端系统到任何其他远程端系统路径上的<strong>第一台路由器</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240922214901322.png" alt="image-20240922214901322"></p><h3 id="1-网络接入"><a href="#1-网络接入" class="headerlink" title="1.网络接入"></a>1.网络接入</h3><blockquote><p>端系统怎样连接到边缘路由器？</p></blockquote><h4 id="1-家庭接入"><a href="#1-家庭接入" class="headerlink" title="1.家庭接入"></a>1.家庭接入</h4><p>DSL、电缆、FTTH、拨号、卫星</p><h4 id="2-企业接入"><a href="#2-企业接入" class="headerlink" title="2.企业接入"></a>2.企业接入</h4><p>局域网(LAN)——&gt;利用以太网技术</p><p>无线局域网(无线以太网，wireless LAN，WIFI)</p><blockquote><p><strong>以太网技术：</strong></p><ul><li><p><strong>共享以太网：</strong> <strong>端系统共享以太网的传输速率；</strong></p></li><li><p><strong>交换以太网：</strong> <strong>多个用户可同时使用全部带宽通信。</strong></p></li><li><p><strong>以太网的MAC协议提供的是无连接服务</strong></p></li></ul></blockquote><h4 id="3-无线接入"><a href="#3-无线接入" class="headerlink" title="3.无线接入"></a>3.无线接入</h4><p>无线局域网(无线以太网，wireless LAN，WIFI)</p><p>广域无线接入网</p><h3 id="2-物理媒体"><a href="#2-物理媒体" class="headerlink" title="2.物理媒体"></a>2.物理媒体</h3><blockquote><p>将网络中不同端系统互相连接起来的<strong>物理线路</strong>，是进行数据传输的物理通路</p></blockquote><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>导引型媒体<ul><li>电波沿着固体每题传播</li><li>双绞线、同轴电缆、光缆</li></ul></li><li>非导引型媒体<ul><li>电波在空气&#x2F;外层空间传播</li><li>无线电</li></ul></li></ul><hr><h2 id="5-ISP互联"><a href="#5-ISP互联" class="headerlink" title="5.ISP互联"></a>5.ISP互联</h2><blockquote><p>端系统经过一个接入网与因特网相连</p><p>因特网边缘的接入网络通过<strong>分层的ISP</strong>与因特网其他部分相连</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240922215819480.png" alt="image-20240922215819480"></p><h2 id="6-时延"><a href="#6-时延" class="headerlink" title="6.时延"></a>6.时延</h2><h3 id="1-分组传输过程"><a href="#1-分组传输过程" class="headerlink" title="1.分组传输过程"></a>1.分组传输过程</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">host----->交换机1----->交换机2--->····--->交换机N--->point<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-时延类型"><a href="#2-时延类型" class="headerlink" title="2.时延类型"></a>2.时延类型</h3><ul><li><p><strong>节点处理时延</strong>：决定分组去处、校验分组完整性</p><ul><li>一般在微秒级或更低的数量级</li><li>表示为：$d_{proc}$</li></ul></li><li><p><strong>排队时延</strong>：在交换机中等待推送，是以分组为单位的，<strong>缓存中如果该分组前面没有分组等待，那么整个分组都没有排队时延</strong></p><ul><li>一般在毫秒或微秒级</li><li>表示为：$d_{queue}$</li></ul></li><li><p><strong>传输时延</strong>：<strong>在交换机的输出端口等待推入链路的时延</strong></p><ul><li>传输时延 &#x3D; $L&#x2F;R$，分组长度&#x3D;L<br>bit，链路传输速率&#x3D;R bps</li><li>一般在毫秒或微秒级</li><li>表示为：$d_{trans}$</li></ul></li><li><p><strong>传播时延</strong>：在链路两节点间的时延</p><ul><li>传播时延&#x3D;$d&#x2F;s$，两节点间距离&#x3D;d，链路传播速率&#x3D;s m&#x2F;s</li><li>通常s在$2\cdot 10^8$到$3\cdot10^8$之间，取决于物理媒体性质</li><li>一般在毫秒级</li><li>表示为$d_{prop}$</li></ul></li></ul><h3 id="3-节点总时延"><a href="#3-节点总时延" class="headerlink" title="3.节点总时延"></a>3.节点总时延</h3><blockquote><p>节点总时延表示为：$d_{nodal}$</p></blockquote><p><strong>$$d_{nodal} &#x3D; d_{proc} + d_{queue} + d_{trans} + d_{prop}$$</strong></p><h3 id="4-排队时延"><a href="#4-排队时延" class="headerlink" title="4.排队时延"></a>4.排队时延</h3><ul><li><strong>不同分组</strong>，路径(route)不同，<strong>排队时延不同</strong></li><li><strong>使用统计量测度</strong></li><li>排队时延大小的度量：<strong>流量强度</strong><ul><li>流量强度 &#x3D; <strong>比特到达队列的速率</strong>与<strong>比特从队列中推出的速率比</strong></li></ul></li></ul><blockquote><p>设R&#x3D; 链路速率 (bps)，L&#x3D; 分组长度 (比特)，a&#x3D;平均分组到达速率(每秒到达了几个分组，pkt&#x2F;s，也就是packet&#x2F;s)</p><p>则流量强度<br><strong>$I &#x3D; La&#x2F;R$</strong>(比特到达队列速率&#x3D;$La$bps，即每秒到达的比特的数量)</p><p>$La&#x2F;R&gt;1$时，分组到达速率大于推出速率，最终<strong>平均时延无穷大</strong></p><p>故，<strong>设计系统时，流量强度不能大于1</strong></p></blockquote><h3 id="5-分组丢失"><a href="#5-分组丢失" class="headerlink" title="5.分组丢失"></a>5.分组丢失</h3><p>当到达的分组发现队列已满，没有空间存储，<strong>被丢弃</strong></p><ul><li>丢弃的分组可能由前面的节点或源端系统重传(面向连接服务)，或根本不重传(无连接服务)</li></ul><h3 id="6-端到端时延"><a href="#6-端到端时延" class="headerlink" title="6.端到端时延"></a>6.端到端时延</h3><blockquote><p>从源到目的地的时延</p></blockquote><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">host----->交换机1----->交换机2--->····--->交换机N-1--->point<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果忽略排队时延，那么：</p><p>路由器和源主机的处理时延是$d_{proc}$</p><p>路由器和源主机的输出速率是$R bit&#x2F;s$</p><p>每条链路的传播时延是$d_{prop}$</p><p>每个节点时延：$d_{proc} + d_{trans} + d_{prop}$</p><p>端到端时延：$d_{end-end} &#x3D; N(d_{proc} + d_{trans} + d_{prop})$</p><p>$d_{trans} &#x3D; L&#x2F;R$</p><blockquote><p>需要注意一点就是，如果题目中<strong>没有</strong>提到<strong>源主机处理时延</strong>，就不要考虑，<strong>仅考虑路由器&#x2F;交换机的处理时延</strong>，也就是$(N-1)d_{proc}$</p></blockquote><hr><h2 id="7-协议层次与服务模型"><a href="#7-协议层次与服务模型" class="headerlink" title="7.协议层次与服务模型"></a>7.协议层次与服务模型</h2><h3 id="1-分层体系结构"><a href="#1-分层体系结构" class="headerlink" title="1.分层体系结构"></a>1.分层体系结构</h3><blockquote><p>为了研究和设计方便，一般采用分层的方法按照功能划分为若干个层次</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240923112717557.png" alt="image-20240923112717557"></p><p><strong>分层特点</strong></p><ul><li>每层功能独立</li><li>每两个相邻层之间有一个<strong>逻辑接口</strong>，可交换信息<ul><li>一般我们称这个<strong>逻辑接口</strong>为：<strong>服务访问点SAP</strong></li></ul></li><li>上一层建立在下一层基础上，上一层可调用下一层的服务，下一层为上一层提供服务</li></ul><p><strong>分层优点</strong></p><ul><li>使复杂系统简化</li><li>易于维护、系统的更新<ul><li>某层功能的变化，不会影响系统其余部分</li></ul></li></ul><h3 id="2-协议分层"><a href="#2-协议分层" class="headerlink" title="2.协议分层"></a>2.协议分层</h3><blockquote><p>协议：控制网络中信息的发送和接收</p><p>定义了通信实体之间交换报文的格式和次序，以及在报文传输和&#x2F;或接收或其他事件所采取的动作</p><p><strong>协议分层</strong>：<br>采用**分层(layer)**的方式组织协议及实现协议的网络硬件和软件</p></blockquote><h4 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h4><ul><li>每层都有相应的一系列协议，如HTTP，TCP</li><li>每层协议通过软件、硬件或两者结合实现</li><li>每层协议可分布在网络的不同组件中：如端系统、分组交换机<ul><li>如应用层协议在端系统中用软件实现</li></ul></li><li><strong>协议栈</strong>：<strong>各层所有协议的集合</strong></li></ul><h4 id="2-服务模型"><a href="#2-服务模型" class="headerlink" title="2.服务模型"></a>2.服务模型</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240923113647942.png" alt="image-20240923113647942"></p><p><strong>上层调用下层的服务，下层为上层提供服务</strong></p><ul><li>示例：<ul><li>第n层提供报文的可靠传输——依赖于第n-1层的不可靠报文传输+本层的检测和重传丢失报文的功能</li></ul></li><li>缺点：<ul><li>某些功能可能在不同层重复出现</li><li>某层的功能可能需要仅存在于其他层的信息</li></ul></li></ul><h3 id="3-分层后数据传递"><a href="#3-分层后数据传递" class="headerlink" title="3.分层后数据传递"></a>3.分层后数据传递</h3><blockquote><p>主机间数据传送实际上并不是在对等层间直接进行,而是通过相邻层间的传递合作完成</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240923114005690.png" alt="image-20240923114005690"></p><h3 id="4-因特网协议栈"><a href="#4-因特网协议栈" class="headerlink" title="4.因特网协议栈"></a>4.因特网协议栈</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240923120800994.png" alt="image-20240923120800994"></p><p>因特网协议栈分为5层(<strong>从低到高计数</strong>)：</p><ul><li><strong>应用层(第5层)：</strong><ul><li>功能：提供各种网络应用</li><li>传输单位：报文</li><li>协议：FTP，SMTP，HTTP等</li></ul></li><li><strong>运输层(第4层)：</strong><ul><li>功能：在应用程序的客户机和服务器之间提供传输应用层报文服务</li><li>传输单位：报文段<ul><li>更具体点说，<strong>TCP协议</strong>的数据传输单位是<strong>报文段</strong>，<strong>UDP协议</strong>的数据传输单位是<strong>数据报</strong></li></ul></li><li>协议：TCP，UDP等</li></ul></li><li><strong>网络层(第3层)：</strong><ul><li>功能：主机和主机之间传输网络层分组</li><li>传输单位：数据报</li><li>协议：IP协议，选路协议等</li></ul></li><li><strong>链路层(第2层)：</strong><ul><li>功能：在邻近单元之间传输数据</li><li>传输单位：帧</li><li>协议：PPP，以太网等</li></ul></li><li><strong>物理层(第1层)：</strong><ul><li>功能：在节点之间传输比特流</li><li>传输单位：比特</li><li>协议：传输媒体等</li></ul></li></ul><h3 id="5-OSI模型"><a href="#5-OSI模型" class="headerlink" title="5.OSI模型"></a>5.OSI模型</h3><blockquote><p>协议栈不止一个，OSI模型就是不同于因特网协议栈的另一个协议栈</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20241103214550116.png" alt="image-20241103214550116"></p><ul><li>**表示层：**通信用户之间数据格式的转换、数据压缩以及加解密等</li><li>**会话层：**对数据传输进行管理，包括数据交换的定界、同步，建立检查点等</li></ul><blockquote><p>还记得网络边缘和网络核心吗？协议栈与之也是有映射关系的。</p><p>因特网协议栈中，<strong>应用层、运输层</strong>是<strong>网络边缘</strong>(资源子网)，<strong>网络层、链路层、物理层</strong>是<strong>网络核心</strong>(通信子网)</p><p>OSI协议栈中，<strong>应用层、表示层、会话层、运输层</strong>是<strong>网络边缘</strong>，<strong>网络层、数据链路层、物理层</strong>是<strong>网络核心</strong></p></blockquote><h3 id="6-节点设备分层"><a href="#6-节点设备分层" class="headerlink" title="6.节点设备分层"></a>6.节点设备分层</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240923122414448.png" alt="image-20240923122414448"></p><blockquote><p>与端系统类似，路由器和链路层交换机以分层方式组织网络硬件和软件，<strong>通常只实现低几层</strong></p></blockquote><p><strong>路由器</strong>：实现1-3层(物理层、链路层、网络层)，能够实现IP协议</p><p><strong>链路层交换机</strong>：实现1-2层(物理层、链路层)，能识别第二层地址，如以太网地址</p><p><strong>主机</strong>：实现所有5个层次</p><h3 id="7-报文传递"><a href="#7-报文传递" class="headerlink" title="7.报文传递"></a>7.报文传递</h3><p>源主机：<strong>由高层向低层逐层传递(封装)</strong></p><ul><li>每层传递的数据分为：<strong>首部字段</strong>和<strong>有效载荷字段</strong><ul><li>首部字段：每层自己的首部信息$H_{i}$</li><li>有效载荷字段：<strong>相邻上层</strong>传下来的数据</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240923123021396.png" alt="image-20240923123021396"></p><p>目的主机：<strong>由低层向高层逐层传递(解封)</strong></p><ul><li>物理层接收，并沿协议栈逐层向上传递，每层<strong>去除对应的首部</strong>，恢复原报文</li><li>如果报文很长，传输时，可先分成多个报文段，每隔报文段在网络层再分为多个数据报</li></ul><p>整个流程：<br><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240923123224857.png" alt="image-20240923123224857"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库笔记-4</title>
      <link href="/2024/06/15/shu-ju-ku-bi-ji-4/"/>
      <url>/2024/06/15/shu-ju-ku-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="八、数据库应用程序的开发"><a href="#八、数据库应用程序的开发" class="headerlink" title="八、数据库应用程序的开发"></a>八、数据库应用程序的开发</h1><h2 id="1-应用程序通用性"><a href="#1-应用程序通用性" class="headerlink" title="1.应用程序通用性"></a>1.应用程序通用性</h2><p>通用性包括两个方面：</p><ul><li><p>和<strong>数据库服务器</strong>构成<strong>邦联式系统</strong>，既<strong>相互独立</strong>，有<strong>可组合对接</strong></p></li><li><p>应用程序<strong>一次编程，一次编译</strong>，即<strong>一个版本</strong>，便能运行在各种<strong>操作系统</strong>和<strong>机型</strong>上</p><ul><li>ODBC&#x2F;JDBC：<strong>数据库应用程序编程接口国际标准</strong>，全称分别是：<code>OpenDatabaseConnectivity</code>和<code>Javadatabaseconnectivity</code>，用于标准化数据库的编程接口，方便程序开发调用</li></ul></li></ul><h2 id="2-对用户操作的快速响应"><a href="#2-对用户操作的快速响应" class="headerlink" title="2.对用户操作的快速响应"></a>2.对用户操作的快速响应</h2><p><strong>快速响应的策略</strong>(可能要考)：</p><p>1）访问数据库采用联接池技术；</p><p>2）数据操作尽量采用批量处理；</p><p>3）尽量发挥数据库中索引的功效；</p><p>4）WEB端缓存</p><h3 id="1-连接池"><a href="#1-连接池" class="headerlink" title="1.连接池"></a>1.连接池</h3><p>可以建立一个连接，并不挂断，保持联线。于是省去了打通电话的时间，也省去了挂断电话的时间(也就是<strong>省去了连接开销</strong>)</p><ul><li>在<strong>连接池</strong>方案中，所有联接都由<strong>连接管理器</strong>来负责管理。联接管理器是一个线程，称作<strong>调度线程</strong>。当WEB服务器收到一个用户的请求时，就分派一个工作线程来处理该请求。工作线程A向调度线程提出<strong>连</strong>接申请。调度线程维护 空闲<strong>连</strong>接队列。</li></ul><h3 id="2-批量处理"><a href="#2-批量处理" class="headerlink" title="2.批量处理"></a>2.批量处理</h3><p>如果一个业务处理，涉及多个SQL语句，如果一个一个地送给数据库去执行，那么带来的大时延，用户难以接受。JDBC提供了<strong>Batch</strong>处理</p><h3 id="3-利用索引"><a href="#3-利用索引" class="headerlink" title="3.利用索引"></a>3.利用索引</h3><p><strong>尽量利用索引来提升查询效率</strong>。每个表，至少有主键索引，可供利用。以学号来查询学生最为常见。知道年级，学院的查询次之</p><h3 id="4-web应用端缓存"><a href="#4-web应用端缓存" class="headerlink" title="4.web应用端缓存"></a>4.web应用端缓存</h3><p>web应用端缓存，减少重复性的数据库查询操作</p><h2 id="3-安全威胁"><a href="#3-安全威胁" class="headerlink" title="3.安全威胁"></a>3.安全威胁</h2><h3 id="1-攻击"><a href="#1-攻击" class="headerlink" title="1.攻击"></a>1.攻击</h3><p>SQL注入攻击&amp;HTML注入攻击</p><h3 id="2-安全管理"><a href="#2-安全管理" class="headerlink" title="2.安全管理"></a>2.安全管理</h3><ul><li><p>利用<strong>消tag函数</strong>防御<strong>SQL注入攻击</strong>和<strong>HTML注入攻击</strong></p></li><li><p>用<strong>HTTPS协议</strong>做好用户<strong>对网站的认证</strong>。网站<strong>对用户认证</strong>的三个层级：<strong>账号，手机验证码，<strong>以及</strong>U盾</strong>；</p></li><li><p><strong>对称加密</strong>可解决<strong>偷看</strong>，<strong>篡改</strong>问题。<strong>抵赖</strong>问题要靠<strong>非对称加密</strong></p><ul><li>非对称加密技术——公钥与私钥</li></ul></li></ul><hr><h1 id="九、数据库技术的演进"><a href="#九、数据库技术的演进" class="headerlink" title="九、数据库技术的演进"></a>九、数据库技术的演进</h1><h2 id="1-云数据库"><a href="#1-云数据库" class="headerlink" title="1.云数据库"></a>1.云数据库</h2><p><strong>简介：</strong></p><ul><li><p>数据库系统运维的关键问题：低成本&#x2F;实惠性；弹性&#x2F;可伸缩性；可靠性</p></li><li><p><strong>动机：</strong> <strong>共享、规模效应和集约效应</strong></p></li><li><p><strong>特征：</strong></p><ul><li><p>标准化、专业化、自动化</p></li><li><p>全方位监控</p></li><li><p>实时&#x2F;动态部署</p></li></ul></li><li><p><strong>关键问题：</strong> <strong>随处运行</strong></p></li></ul><p><strong>云数据库国内产品(可能要考)</strong></p><ul><li>华为：<strong>GuassDB</strong></li><li>腾讯：<strong>TDSQL</strong></li><li>阿里：<strong>PolarDB</strong></li></ul><h2 id="2-分布式数据库"><a href="#2-分布式数据库" class="headerlink" title="2.分布式数据库"></a>2.分布式数据库</h2><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240615164025154.png" alt="image-20240615164025154"></p><p><strong>分布式数据库的结构</strong>：</p><p>由一个分布式数据库管理系统(DDBMS)+多个数据库服务器组成</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="分布式数据库"></p><p><strong>好处</strong>：</p><ul><li>为用户屏蔽了数据的物理存储概念，实现数据操作的简单性</li><li>提升处理性能——<strong>分区&#x2F;分片&#x2F;分段，提高扩展性</strong></li><li>提升系统的可靠性与可用性——<strong>复制，提高可靠性，可用性(冗余)</strong></li></ul><p><strong>以上三种的另一种说法：网络透明、分段透明、复制透明</strong></p><ul><li>透明：用户感知不到</li></ul><p><strong>分布式数据库主要针对哪些问题出现?</strong></p><ol><li><p><strong>扩展性（Scalability）：</strong></p><ul><li>传统单机数据库在数据量和访问量急剧增长时扩展困难。分布式数据库通过分片和复制，可以横向扩展，处理更大的数据量和更多的并发请求。</li></ul></li><li><p><strong>高可用性和容错性（High Availability and Fault Tolerance）：</strong></p><ul><li>单机数据库在服务器故障时会导致数据不可用。分布式数据库通过数据冗余和分布式架构，提高系统的容错能力和可用性，确保即使部分节点出现故障，系统依然能够正常运行。</li></ul></li><li><p><strong>地理分布和数据本地化（Geographical Distribution and Data Localization）：</strong></p><ul><li>对于跨地域的应用，需要将数据分布在不同的地理位置，以降低访问延迟并符合数据本地化的法律法规要求。分布式数据库支持跨地域部署，实现数据的本地化存储和访问。</li></ul></li><li><p><strong>性能（Performance）：</strong></p><ul><li>通过分布式数据库，可以将负载分散到多个节点上，提升系统的整体性能，特别是对于读写频繁的应用场景，能够显著提高吞吐量和响应速度。</li></ul></li><li><p><strong>弹性和灵活性（Elasticity and Flexibility）：</strong></p><ul><li>分布式数据库可以根据需求动态增加或减少节点，提供更大的灵活性和弹性，适应业务的变化。</li></ul></li></ol><hr><h2 id="3-NoSQL数据库"><a href="#3-NoSQL数据库" class="headerlink" title="3.NoSQL数据库"></a>3.NoSQL数据库</h2><p>NoSQL，全称是**<code>Not Only SQL</code>**，意思是<code>不仅仅是关系型数据库</code></p><p>NoSQL的由来：面向对象模型和关系模型的结合</p><p><strong>基本概念</strong></p><p>NoSQL（Not Only SQL）是对非关系型数据库管理系统的一种统称。NoSQL数据库被设计用于处理大规模数据存储和高吞吐量的应用程序，这些应用程序往往难以使用传统的关系型数据库进行管理。NoSQL数据库可以以多种数据模型进行存储和查询，常见的数据模型包括键值（Key-Value）、列族（Column-Family）、文档（Document）和图（Graph）</p><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h3><ul><li>面向对象模型中没有强调对象的标识问题，引用不是逻辑概念，而关系模型中强调使用主键来标识对象。主键&#x2F;外键：逻辑概念；</li><li>NOSQL模型提出了<strong>KEY-VALUE模型</strong>，兼顾了两者。</li><li>KEY，<strong>既可以是</strong>逻辑的**，也可是**物理的（由系统生成)，长度固定。VALUE则没有固定， 可灵活定义。<strong>灵活程度：在用户添加一个对象时，由用户来指定VALUE的数据类型，以及取值</strong>。</li><li>表是一个集合类型的实例对象。因此<strong>VALUE可以是一个表</strong></li></ul><h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2.特性"></a>2.特性</h3><ul><li>面对的是巨大的用户数，强调的是<strong>查找性能，可扩展性，可用性</strong></li><li>采用<strong>key-value</strong> 来实现目标，<strong>使得密切的数据聚集在一起存储</strong></li><li>水平方向具有扩展性，即<strong>Value可以没有固定的Schema</strong></li><li><strong>不能做灵活而复杂的处理</strong>：范围查询，模糊查询，联接运算</li><li><strong>只能做等值查询</strong>，按照已设计好的层次结构做引导式roll down查询</li></ul><h3 id="3-典型产品"><a href="#3-典型产品" class="headerlink" title="3.典型产品"></a>3.典型产品</h3><ul><li><strong>列存储</strong>类型：<strong>Hbase</strong> <strong>Hypertable</strong><ul><li>按列存储数据。方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势</li></ul></li><li><strong>文档存储</strong>类型：<strong>MongDB</strong><ul><li>用类似Json的格式存储，Schema不确定，易变。有机会对某些字段建立索引</li></ul></li><li><strong>Key-Value存储</strong>类型：<strong>Redis</strong><ul><li>可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收</li></ul></li><li><strong>图数据库存储</strong>类型：<strong>Neo4j</strong><ul><li>专门处理图结构数据（节点和边），适合社交网络、推荐系统等场景</li></ul></li></ul><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>互联网电商数据库的特点是用户量和数据量巨大，基于NoSQL的KEY-VALUE数据模型来设计，其购物记录表为ordersheet(useId,sheet),其中sheet的含义为userId所指用户的所有购物记录。另其商品表分成了3个表：1)goodsBasic(goodsId,BasicIfno);2)goodsDetail(goodsId,detail);3)goodsVideo(goodsId,video)。这3个表分别存储商品基本信息，详细信息，视频介绍信息。请问这4个表，满足关系模型的设计要求吗？说明理由。请基于互联网电商业务特性与用户访问特性，分析这种设计的合理性，且相对于关系模型，能带来哪些好处？说明理由</p><hr><p>基于NoSQL的KEY-VALUE数据模型设计的互联网电商数据库，其设计和关系模型设计的对比如下：</p><h4 id="是否满足关系模型的设计要求？"><a href="#是否满足关系模型的设计要求？" class="headerlink" title="是否满足关系模型的设计要求？"></a>是否满足关系模型的设计要求？</h4><p>这些表不完全满足传统关系数据库模型的设计要求。理由如下：</p><ol><li><strong>范式要求</strong>：关系数据库设计通常需要满足各种范式（如第一范式、第二范式、第三范式等）以消除冗余、避免数据异常。然而，上述NoSQL设计没有强调范式约束。</li><li><strong>表结构</strong>：NoSQL数据库的表结构通常是非固定的，可以根据需要进行调整，而关系数据库表结构相对固定且要求严格定义。</li><li><strong>数据完整性</strong>：关系数据库通过外键和约束来保证数据完整性，但NoSQL数据库通常依赖应用层逻辑来保证数据一致性和完整性。</li></ol><h4 id="设计的合理性分析"><a href="#设计的合理性分析" class="headerlink" title="设计的合理性分析"></a>设计的合理性分析</h4><p>基于互联网电商业务特性与用户访问特性，分析这种设计的合理性：</p><ol><li><p><strong>用户量和数据量巨大</strong>：</p><ul><li><strong>NoSQL优点</strong>：NoSQL数据库能够水平扩展，适应大规模数据和高并发访问，非常适合用户量和数据量巨大的电商应用。</li><li><strong>KEY-VALUE模型</strong>：简化了数据存储，能够快速存取数据，满足高性能需求。</li></ul></li><li><p><strong>用户访问特性</strong>：</p><ul><li><strong>频繁读取</strong>：电商网站需要频繁读取商品信息、用户购物记录等。NoSQL数据库通过分片和复制等技术，可以高效处理大量读操作。</li><li><strong>快速写入</strong>：用户的购物操作需要快速记录。NoSQL数据库的高写入性能能很好地满足这一需求。</li></ul></li><li><p><strong>商品信息的分表设计</strong>：</p><ul><li><strong>模块化存储</strong>：将商品基本信息、详细信息和视频信息分开存储，适合不同的访问模式和需求。比如，用户浏览商品列表时只需基本信息，而查看商品详情时才需要详细信息和视频。</li><li><strong>数据分离</strong>：这种设计减少了单表的数据量，提高了查询效率，特别是在需要频繁读取商品基本信息的情况下，分表可以显著提升性能。</li></ul></li></ol><h4 id="相对于关系模型的好处"><a href="#相对于关系模型的好处" class="headerlink" title="相对于关系模型的好处"></a>相对于关系模型的好处</h4><ol><li><p><strong>可扩展性</strong>：</p><ul><li><strong>NoSQL</strong>：NoSQL数据库通过分片（sharding）和复制（replication）技术，实现了水平扩展，能够轻松处理大规模数据和高并发请求。</li><li><strong>关系数据库</strong>：水平扩展相对困难，通常依赖垂直扩展（增加单台服务器的性能）。</li></ul></li><li><p><strong>灵活性</strong>：</p><ul><li><strong>NoSQL</strong>：数据模型灵活，支持半结构化和非结构化数据，可以方便地进行模式变更。</li><li><strong>关系数据库</strong>：数据模型固定，模式变更需要进行复杂的数据库迁移操作。</li></ul></li><li><p><strong>高性能</strong>：</p><ul><li><strong>NoSQL</strong>：设计为高性能访问，适合大规模数据的快速读取和写入。</li><li><strong>关系数据库</strong>：通常设计为满足事务处理的ACID特性，在大规模数据场景下可能存在性能瓶颈。</li></ul></li><li><p><strong>简化的操作</strong>：</p><ul><li><strong>NoSQL</strong>：使用KEY-VALUE模型简化了数据存取操作，尤其适用于电商这种高频读写操作场景。</li><li><strong>关系数据库</strong>：复杂的查询需要JOIN操作，在大数据量情况下性能可能较差。</li></ul></li></ol><p>综上所述，这种基于NoSQL的设计合理地利用了NoSQL数据库的优势，以满足互联网电商平台的大用户量、大数据量和高并发需求，同时通过分表设计优化了数据存储和访问性能。虽然不完全符合关系数据库的范式要求，但在实际应用中，它能提供更好的性能和扩展性。</p><hr><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>NoSQL数据库主要针对哪些问题出现？</p><hr><p>NoSQL数据库主要是针对以下几类问题和需求应运而生的：</p><ol><li><strong>高可扩展性（Scalability）：</strong><ul><li>传统的关系型数据库（RDBMS）在面对海量数据和高并发访问时，横向扩展（scale-out）比较困难。NoSQL数据库设计上更容易进行分布式扩展，能够处理大规模数据量和高吞吐量需求。</li></ul></li><li><strong>灵活的存储模型（Flexible Data Models）：</strong><ul><li>关系型数据库需要预定义严格的模式（schema），这在处理非结构化或半结构化数据（如文档、图像、日志等）时不够灵活。NoSQL数据库支持灵活的、动态的模式，使得开发和修改数据结构更加方便。</li></ul></li><li><strong>高性能（Performance）：</strong><ul><li>在处理大规模读写操作时，关系型数据库的性能可能受到限制。NoSQL数据库通过简化事务模型和优化特定的查询模式，提供更高的读写性能，适用于实时数据处理和大数据分析。</li></ul></li><li><strong>高可用性和容错性（Availability and Fault Tolerance）：</strong><ul><li>许多NoSQL数据库采用分布式架构，数据可以在多个节点间复制，从而提供高可用性和自动故障恢复能力，保证系统的稳定运行。</li></ul></li><li><strong>多样化的数据类型支持：</strong><ul><li>不同类型的NoSQL数据库（如键值存储、文档存储、列族存储、图数据库等）针对不同的数据模型进行了优化，能够有效地处理特定类型的数据和查询需求。</li></ul></li></ol><h2 id="5-小知识点"><a href="#5-小知识点" class="headerlink" title="5.小知识点"></a>5.小知识点</h2><ul><li>查尔斯·巴赫曼：数据库管理系统，图灵奖</li><li>埃德加·科特：关系模型(1970)，图灵奖</li><li>詹姆士·格雷：事务处理和可靠性，图灵奖</li><li>迈克尔·斯通布雷克：新型数据库系统(面向对象模型，NoSQL)，图灵奖</li><li>C&#x2F;S模式：C&#x2F;S模式（Client&#x2F;Server模式）指的是在软件架构中，系统被分为客户端和服务器两个部分，客户端负责用户界面和部分处理逻辑，而服务器则负责处理数据管理、业务逻辑和资源共享</li><li>B&#x2F;S模式：B&#x2F;S模式（Browser&#x2F;Server模式）是一种特殊的C&#x2F;S模式，其客户端部分是通过Web浏览器来实现的，称为浏览器（Browser），而服务器端仍然是处理数据和业务逻辑的服务器。<ul><li>B&#x2F;S模式已经成为许多应用的首选，因为它能够提供更大的灵活性和可扩展性。</li></ul></li><li>Web的国际标准：HTML、CSS、JavaScript</li><li>数据库访问编程接口国际标准ODBC&#x2F;JDBC</li><li>数据操作国际标准SQL</li><li>数据库技术的核心内容：<ul><li>关系模型</li><li>事务处理</li><li>数据库设计方法</li><li>SQL</li><li>ODBC&#x2F;JDBC</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库笔记-3</title>
      <link href="/2024/04/20/shu-ju-ku-bi-ji-3/"/>
      <url>/2024/04/20/shu-ju-ku-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="七、数据库设计"><a href="#七、数据库设计" class="headerlink" title="七、数据库设计"></a>七、数据库设计</h2><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><h4 id="1-数据库设计含义"><a href="#1-数据库设计含义" class="headerlink" title="1.数据库设计含义"></a>1.数据库设计含义</h4><ul><li><strong>数据库设计的诉求</strong>：根据一个数据模型而制定数据的组织形式<ul><li>具体一点来说</li><li>(1)设计者决定存储哪些数据，以及数据之间如何关联和交互</li><li>(2)基于(1)中的信息，将数据用数据模型表达</li><li>(3)最后由一个数据库管理系统，结合设计要求，来对数据进行存储管理</li></ul></li></ul><h4 id="2-数据库设计过程"><a href="#2-数据库设计过程" class="headerlink" title="2.数据库设计过程"></a>2.<strong>数据库设计过程</strong></h4><ul><li><p>(0)<strong>需求分析</strong>：确定存储哪些数据，建立哪些应用，常用的操作，对象有哪些</p></li><li><p>(1)<strong>概念数据建模</strong>：确定数据的理论模式(概念数据模型,如ER-model)，用概念模式输出表达(ER-diagram)</p><ul><li>ER-model是对数据关系的一种抽象，ER-diagram则是用来可视化表示ER-model的工具</li></ul></li><li><p>(2)<strong>逻辑数据建模</strong>：概念建模的映射，用逻辑结构来细化表达数据，将概念模型所描述的数据映射为某个特定的DBMS模式数据</p></li><li><p>(3)<strong>物理层面设计</strong>：确定数据库配置、存储媒介、数据元素与类型、安全性、冗余备份、性能……</p></li><li><p>当然，还有一种对数据库设计过程的划分：概念阶段&#x2F;逻辑阶段&#x2F;实现阶段(定义表等)&#x2F;物理阶段(索引、磁盘组织)</p></li></ul><h4 id="3-数据库设计目标"><a href="#3-数据库设计目标" class="headerlink" title="3.数据库设计目标"></a>3.数据库设计目标</h4><blockquote><p>设计目标，也就是需要解决的问题</p></blockquote><ul><li><strong>需求覆盖</strong>：满足和全覆盖所有业务需求，要求需求获取全面，分析到位<ul><li>覆盖：实体、属性、关联</li><li><strong>全局性</strong>：从列来看，一个类，在业务中凡是要用到的属性， 都要包含；从行来看，一个类的所有实例对象都在一个表中</li><li><strong>严格按类分表存储</strong>：一个类对应一个表；属于不同类的数据不能混合存储在一个表中</li><li><strong>属性</strong>：<strong>标示性属性</strong>(主键），<strong>联系属性</strong>(外键)，特征属性</li></ul></li><li><strong>数据正确性</strong>：尽量少的冗余，无数据更新异常，数据一致，要求使用正确的设计方法<ul><li><strong>没有更新异常</strong></li><li><strong>输出的数据正确</strong></li><li><strong>尽量少的冗余</strong></li></ul></li><li><strong>可伸展性</strong>：只要数据库中存在源头数据，任何业务需求想要的业务表单都能组合出来<ul><li>能够基于现有数据衍生出各种新的数据视图，服务于不断发展的业务</li></ul></li></ul><h4 id="4-数据库设计挑战"><a href="#4-数据库设计挑战" class="headerlink" title="4.数据库设计挑战"></a>4.数据库设计挑战</h4><ul><li><strong>业务表单和数据库中表的不一致</strong><ul><li>业务表单中通常包含的是综合信息</li><li>而数据库中的一个表只能存储单一类别的信息</li></ul></li><li><strong>需求获取时，见到的和听到的都是<em>局部</em>，而数据库设计需要站在<em>全局</em>来考虑</strong></li></ul><blockquote><p>P.S.数据库表与业务表的区别：</p><ul><li>数据库表：严格按类概念，分类存储</li><li>业务表：由分布在多个表中列组合而成</li></ul></blockquote><h4 id="5-关系型数据库"><a href="#5-关系型数据库" class="headerlink" title="5.关系型数据库"></a>5.关系型数据库</h4><ul><li>实质：<strong>表与表之间存在联系</strong></li></ul><h4 id="6-数据库设计专业性"><a href="#6-数据库设计专业性" class="headerlink" title="6.数据库设计专业性"></a>6.数据库设计专业性</h4><p>原因：</p><ul><li>业务需求发现技巧</li><li>不合理的数据库设计导致<ul><li>数据冗余</li><li>更新异常</li></ul></li><li>设计必须基于业务特性，迎合业务特性，覆盖业务需求</li><li><strong>设计方法学</strong>(步骤)<ul><li>需求表述</li><li>E-R建模</li><li>将ER-model映射为relation model</li><li>采用一个数据库管理系统，实现一个数据库，搭建起一个数据库服务器</li></ul></li></ul><h4 id="7-数据库设计包含方面"><a href="#7-数据库设计包含方面" class="headerlink" title="7.数据库设计包含方面"></a>7.数据库设计包含方面</h4><ul><li><strong>覆盖</strong>业务需求</li><li>数据的<strong>组织要合理</strong>(涵盖了正确性和可伸缩性)</li></ul><h4 id="8-获取需求"><a href="#8-获取需求" class="headerlink" title="8.获取需求"></a>8.获取需求</h4><p><strong>需要了解的业务</strong>：</p><ol><li>things (entity（实体&#x2F;事实）);</li><li>activity&#x2F;event(活动&#x2F;事件）</li><li>involved persons(相关人员);</li><li>procedure(过程)</li><li>record (记录);</li><li>业务特征与特性，发展态势;</li></ol><p><strong>五个获取业务需求的途径</strong>：</p><p>①查看业务规章制度的文档;</p><p>②收集已有的业务表单;</p><p>③面对面沟通交流；</p><p>④观察业务的运转情况；</p><p>⑤分析，推理，研究，归纳提炼；</p><h4 id="9-判断设计合理性"><a href="#9-判断设计合理性" class="headerlink" title="9.判断设计合理性"></a>9.判断设计合理性</h4><ul><li><p>程序的<strong>鲁棒性</strong>(稳健,坚韧)：</p><p>1）函数调用是否成功；</p><p>2）结果是否为空；</p><p>3）不为空时，才允许读结果</p></li><li><p>数据的<strong>正确性</strong>; <strong>完整性</strong>; <strong>安全性</strong>; 操作的<strong>简单性</strong>; 数据处理的<strong>高效性</strong></p></li><li><p>系统的<strong>可维护性</strong>：系统的<strong>模块化</strong>，<strong>层次化</strong>，接口的<strong>标准化</strong>：<strong>邦联性</strong>，<strong>可组合性</strong></p></li></ul><hr><h3 id="二、ER建模"><a href="#二、ER建模" class="headerlink" title="二、ER建模"></a>二、ER建模</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><ul><li><p>实体(Entity)</p><ul><li><strong>客观存在</strong>并可<strong>相互区分</strong>的事务叫做——实体</li></ul></li><li><p>属性(Attribute)</p><ul><li>实体所具有的某一特性</li><li>一个实体可以由若干个属性来刻画</li></ul></li><li><p>域(domain)</p><ul><li>属性的取值范围</li></ul></li><li><p>实体型(Entity Type)</p><ul><li>实体名与其属性名的集合共同构成实体型</li><li>例，学生（学号、姓名、年龄、性别、系、年级）</li><li>注意实体型与实体（值）之间的区别，后者是前者的一个特例</li></ul></li><li><p>实体集(Entity Set)</p><ul><li>同型实体的集合——实体集</li><li>如，全体学生</li></ul></li><li><p>联系(Relationship)</p><ul><li>实体之间的相互关联</li><li>联系也可以有属性，比如选课是一个联系，成绩可作为其属性</li><li>也可以称之为实体之间的”关系”</li></ul></li><li><p>元或度(Degree)</p><ul><li>参与联系的实体集的个数称为联系的元</li><li>一元联系：递归联系</li></ul></li><li><p>键或码(Key)</p><ul><li>唯一标识实体的属性或属性组称作超键</li><li>超键的任意超集也是超键</li><li>其任意真子集都不能成为超键的最小超键称为候选码</li><li>从所有候选键中选定一个用来区别同一实体集中的不同实体，称作主键</li><li>一个实体集中任意两个实体在主键上的取值不能相同</li></ul></li><li><p>参与(Participation)</p><ul><li>实体集之间的关联称为参与，即实体参与联系</li><li>如王军选修“数据库基础”，表示实体“王军”与 “数据库基础”参与了联系“选修”</li><li>如果实体集E中的每个实体都参与到联系集R中的至少一个联系，则称E全部参与R</li><li>如果实体集E中只有部分实体参与到联系集R的联系中，则称E部分参与R</li></ul></li></ul><h4 id="2-属性的类型"><a href="#2-属性的类型" class="headerlink" title="2.属性的类型"></a>2.属性的类型</h4><ul><li>简单属性<ul><li>不可再分</li></ul></li><li>复合属性<ul><li>可以划分为更小的属性</li><li>把相关属性聚集起来以反映更高层次的概念，可以使模型更清晰</li><li>如电话号码&#x3D;区号+本地号码</li></ul></li><li>单值属性<ul><li>每一个特定的实体在该属性上的取值唯一</li></ul></li><li>多值属性<ul><li>某个特定的实体在该属性上的有多于一个的取值</li></ul></li><li>NULL属性(两种情况)<ul><li>null表示“无意义”，当实体在某个属性上没有值时设为null</li><li>null表示“值未知”，即值存在，但目前没有获得该信息</li></ul></li></ul><h4 id="3-联系的种类"><a href="#3-联系的种类" class="headerlink" title="3.联系的种类"></a>3.联系的种类</h4><ul><li>实体之间的联系的数量，即一个实体通过一个联系集能与另一实体集相关联的实体的数目</li><li>可以有一对一的（1:1），一对多的（1:m），多对多的（m:n）几种情况</li></ul><h4 id="4-E-R图-旧"><a href="#4-E-R图-旧" class="headerlink" title="4.E-R图(旧)"></a>4.E-R图(旧)</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420212537974.png" alt="image-20240420212537974"></p><h4 id="5-概念数据库设计-ER-modeling"><a href="#5-概念数据库设计-ER-modeling" class="headerlink" title="5.概念数据库设计(ER modeling)"></a>5.概念数据库设计(ER modeling)</h4><ul><li><p>基本概念和要素：</p><ul><li><p>实体——(抽象)——实体类</p></li><li><p>联系——(抽象)——联系类</p></li></ul></li><li><p>实体：有类型(type)和实例(instance)两个概念</p><ul><li>符号表示：实体类型用长方形表示，其名称放在长方形中.其名称用单数名称，第一个字母大写</li></ul></li><li><p>联系(关系)：</p><ul><li>有类型(type)和实例(instance)两个概念</li><li>例如，WorksOn 是员工类型(Employee)和项目类型(Project)之间的一种关系。而(E1,P1)： ‘E1’ works on project ‘P1’ 是该关系类型的一个实例</li><li><strong>在两个实体之间可能存在多个联系</strong><ul><li>一个实体可以充当不同角色，比如A管理B，B拥有A(例如部门与经理)</li></ul></li><li><strong>关系的度</strong>：一个关系类型涉及的实体类型的数量</li><li><strong>符号表示</strong>：In UML, 两个实体类型之间的一条边线表示一个关系类型，边上标签为关系类型的名称，附加上一个箭头来表达关系的逻辑<ul><li>度&lt;3，用箭头表示关系</li><li>度&gt;&#x3D;3，用菱形表示关系类型</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420215550796.png" alt="image-20240420215550796"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420215745648.png" alt="image-20240420215745648"></p><ul><li><p>约束</p><ul><li><p>作用于<strong>实体类型</strong>的约束：标识属性</p></li><li><p>作用于<strong>关系类型</strong>的约束：</p><ul><li>对于二元关系，一共3类：1对1，1对多，多对多</li><li>进一步细化为两级：参(participation)和基(cardinality)<ul><li>参：实体集中，该实体是否参与，是否必须参与</li><li>基：描述两个实体集之间的关系数量，1vs1,1 vs many,many vs many</li></ul></li></ul></li><li><p>关联标注(UML格式)</p><ul><li>关联标注指的就是关系边线两侧的数值，基本格式为<code>i..j(i &lt;= j)</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420220450028.png" alt="image-20240420220450028"></p><ul><li>以上图为例，<code>0..N</code>靠近person，就是person的关联标注，表示<strong>当location实体集只有1个实体参与联系时，person实体集中可以有0~N个实体参与联系</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420220900898.png" alt="image-20240420220900898"></p><ul><li>1对1关系</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420221010038.png" alt="image-20240420221010038"></p><ul><li>1对多关系</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420221025605.png" alt="image-20240420221025605"></p><ul><li>多对多关系<ul><li><strong>注意，这里的一对一和一对多中的“一”，都是指自己，也就是箭头发出的一方是<code>0..1</code></strong></li></ul></li></ul></li><li><p><strong>多元关系下的约束标记</strong>：</p><ul><li>标记某一端的约束时，其它端的实例对象数都设为1，然后从最悲观和最乐观视角来确定约束</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420221129789.png" alt="image-20240420221129789"></p><h4 id="6-ER建模步骤"><a href="#6-ER建模步骤" class="headerlink" title="6.ER建模步骤"></a>6.ER建模步骤</h4><blockquote><p>注意，以下的ER图是UML格式的，该课程ER图设置为UML格式，但还存在其他格式，本课程内不考虑，不讨论</p></blockquote><p><strong>第一步：标识实体</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420213846921.png" alt="image-20240420213846921"></p><p><strong>第二步：标识关系</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420213918230.png" alt="image-20240420213918230"></p><p><strong>第三步：标识属性</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420213955041.png" alt="image-20240420213955041"></p><p><strong>第四步：标识实体约束</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420214033132.png" alt="image-20240420214033132"></p><p><strong>第五步：标识关系约束</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240420214101017.png" alt="image-20240420214101017"></p><h4 id="7-扩展E-R-强实体类型和弱实体类型"><a href="#7-扩展E-R-强实体类型和弱实体类型" class="headerlink" title="7.扩展E-R:强实体类型和弱实体类型"></a>7.扩展E-R:强实体类型和弱实体类型</h4><p>①<strong>强实体类型</strong>：它的实例的存在<strong>不依赖于任何其它实体类型</strong>的实例</p><ul><li>强实体类型在模式（Schema)上不依赖于任何其它实体类型</li><li>它有<strong>自己独立的主键</strong>，唯一性地标识它的实例<ul><li>换句话说，它实例的存在不依赖于其它实体的判断标准就是：是否有独立的主键</li><li>例如，信用卡类型是不是一个强实体类型？<ul><li>当然是！信用卡虽然需要有人的信息(身份证，手机)，但信用卡的主键是<strong>信用卡号</strong>，这个可是一个<strong>独立主键</strong>！</li></ul></li></ul></li></ul><p>②<strong>弱实体类型</strong>：它的实例的存在<strong>依赖于任何其它实体类型</strong>的实例</p><p>弱实体类型，是指<strong>它自身的所有属性都无法构成主码</strong>的实体类型，因此弱实体的主键必须由外键和一部分自身属性所构成，这个外键往往是弱实体所依赖的实体的主键。</p><ul><li>弱实体的主键包括两个部分：<ul><li>它所依赖的实体类型的主键</li><li>在此基础上，再加上它自己的标识性属性</li></ul></li></ul><p><strong>WARNING:<code>强实体与弱实体的联系只能是1：1或者1：N</code></strong></p><ul><li>原因：有一个强实体，就有一个主键，可以构成弱实体的主键。再多的强实体也只是锦上添花。所以不能是N：1或者N：M</li></ul><p>③<strong>弱实体集与存在依赖</strong></p><ul><li>弱实体集必然存在依赖于强实体集（Strong Entity Set) 即其拥有者</li><li>弱实体集与其拥有者之间的联系称作标识性联系(identifying relationship)</li><li>存在依赖并不总会导致一个弱实体集，从属实体集可以有自己的主键<ul><li>如实体集信用卡（信用卡号，客户帐号，金额），它存在依赖于客户帐号实体集，但信用卡有自己的主码信用卡号</li></ul></li></ul><p>④<strong>分辨符</strong></p><ul><li>弱实体集中用于区别依赖于某个特定强实体集的属性集合。也称作<strong>部分码（partial key)</strong><ul><li>如“还款”中的还款号</li></ul></li><li>弱实体集的主码由该弱实体集所存在依赖的强实体集的主码和该弱实体集的分辨符组成<ul><li>如“还款”主码＝贷款号＋还款号</li></ul></li></ul><p>⑤<strong>为什么使用弱实体集</strong></p><p>通过为弱实体集加上合适的属性，可转变为强实体集，为什么还要使用弱实体集？</p><ul><li><p>避免数据冗余（强实体集码重复），以及因此带来的数据的不一致性</p></li><li><p>弱实体集反映了一个实体对其它实体依赖的逻辑结构</p></li><li><p>弱实体集可以随它们的强实体集的删除而自动删除</p></li><li><p>弱实体集可以物理地随它们的强实体集存储</p></li></ul><p>⑥<strong>E-R图表示</strong></p><p>弱实体集在E-R图中的表示</p><ul><li><p>弱实体集以双边框的矩形表示</p></li><li><p>标识性联系以双边框的菱形表示</p></li><li><p>从联系集用双线（全部参与）连接弱实体集，用箭头（一对多联系）指向强实体集</p></li><li><p>弱实体集的分辨符用下划虚线标明</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613212937020.png" alt="image-20240613212937020"></p><h4 id="8-建模陷井"><a href="#8-建模陷井" class="headerlink" title="8.建模陷井"></a>8.建模陷井</h4><h5 id="1-扇子陷井"><a href="#1-扇子陷井" class="headerlink" title="1.扇子陷井"></a>1.扇子陷井</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613213211660.png" alt="image-20240613213211660"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613213249978.png" alt="image-20240613213249978"></p><p>但是，<strong>通过关系传递推导出的关系不一定正确</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613213313105.png" alt="image-20240613213313105"></p><h5 id="2-裂口陷井"><a href="#2-裂口陷井" class="headerlink" title="2.裂口陷井"></a>2.裂口陷井</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613213335171.png" alt="image-20240613213335171"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613213426183.png" alt="image-20240613213426183"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613213433778.png" alt="image-20240613213433778"></p><p>但是，<strong>通过关系传递推导出的结果不一定正确</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613213445378.png" alt="image-20240613213445378"></p><h4 id="9-注意事项"><a href="#9-注意事项" class="headerlink" title="9.注意事项"></a>9.注意事项</h4><ul><li><p><strong>避免冗余，不要在多处出现指向同一个概念的属性，实体，关系</strong></p></li><li><p><strong>能用属性表达的地方不要用实体来表达</strong></p></li></ul><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613213701989.png" alt="image-20240613213701989"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613213713279.png" alt="image-20240613213713279"></p><h4 id="10-处理多元关系"><a href="#10-处理多元关系" class="headerlink" title="10.处理多元关系"></a>10.处理多元关系</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613215009332.png" alt="image-20240613215009332"></p><p><strong>把多元关系模型化成弱实体，变成二元关系处理</strong></p><p>——<strong>把其中一个联系转换成实体再做依赖</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613215300735.png" alt="image-20240613215300735"></p><p>这里，我们将联系<code>enroll</code>转换成实体<code>enrollment</code>，再将<code>class_no</code>属性拎出来转换成实体<code>class</code>，重新构造关系：Teacher——teach——Class</p><p>Enrollment——assign(指定)——Class</p><p><strong>当要在多对多的二元联系上再建立联系时，将联系模型化成弱实体</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613215629326.png" alt="image-20240613215629326"></p><h4 id="11-时间实体-空间实体"><a href="#11-时间实体-空间实体" class="headerlink" title="11.时间实体&#x2F;空间实体"></a>11.时间实体&#x2F;空间实体</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613215747503.png" alt="image-20240613215747503"></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613215755670.png" alt="image-20240613215755670"></p><h4 id="12-对一对一关系的认识"><a href="#12-对一对一关系的认识" class="headerlink" title="12.对一对一关系的认识"></a>12.对一对一关系的认识</h4><p>将一对一关系所涉及的两个实体所对应的两个关系模式，将其一的主键加入到另一个关系模式中，作为外键，以此表达一对一关系。</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240613220001974.png" alt="image-20240613220001974"></p><p>这里可以这么理解：<br>首先，<code>0..1——1..1</code>这种约束不可能出现在强实体与弱实体之间，因为强实体：弱实体&#x3D;1：N，所以<strong>如果强实体弱实体之间有约束，也应该是<code>1..1——0..*</code></strong></p><p>那么，<code>0..1——1..1</code>这种约束又代表了什么呢？很显然，<code>0..1</code>这一方是不一定存在的，也就是说，它是<code>1..1</code>这一方的补充，故而，<strong><code>0..1</code>这一实体不存在主键，它的主键就是<code>1..1</code>的主键</strong></p><p>而<code>0..1——0..1</code>这一约束正如上述所言，在转关系模式时按照这种方式去转即可</p><p><code>1..1——1..1</code>这一约束不可能出现，因为既然A有1个的时候B只有1个，反之亦然的时候，那么B就可以作为A的属性了(或者A做B的属性)</p><h3 id="三、ER模型转关系模型"><a href="#三、ER模型转关系模型" class="headerlink" title="三、ER模型转关系模型"></a>三、ER模型转关系模型</h3><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614185748540.png" alt="image-20240614185748540"></p><h4 id="第一步：将每个强实体转换成一个关系-Relation"><a href="#第一步：将每个强实体转换成一个关系-Relation" class="headerlink" title="第一步：将每个强实体转换成一个关系(Relation)"></a><strong>第一步：将每个强实体转换成一个关系(Relation)</strong></h4><ul><li>对多值属性，在第6步处理</li><li>强实体的主键，也是关系的主键</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614191831657.png" alt="image-20240614191831657"></p><h4 id="第二步：将每个弱实体转换成一个关系"><a href="#第二步：将每个弱实体转换成一个关系" class="headerlink" title="第二步：将每个弱实体转换成一个关系"></a><strong>第二步：将每个弱实体转换成一个关系</strong></h4><ul><li>将弱实体所依赖的强实体的主键加入弱实体对应的关系中，作为关系主键的组成部分</li><li>如何辨别强弱实体？注意约束：<code>1..1——0..*</code>，是这个约束的，很可能就是弱实体与强实体</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614192141701.png" alt="image-20240614192141701"></p><h4 id="第三步：处理一对一关系"><a href="#第三步：处理一对一关系" class="headerlink" title="第三步：处理一对一关系"></a><strong>第三步：处理一对一关系</strong></h4><p>一对一关系有三种情况，分别处理：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614192447331.png" alt="image-20240614192447331"></p><ul><li><code>0..1——1..1</code>：将<code>1..1</code>的实体的主键加到**额外角色<code>0..1</code>**上，额外角色的主键就是<code>1..1</code>实体的主键</li><li><code>0..1——0..1</code>：哪一端的属性少，就把另一端的主键加到属性少的关系里作为外键</li><li><code>1..1——1..1</code>：不可能出现，不考虑</li></ul><p><strong>实际上，通过对下面对一对一关系的处理可以看到，如果联系也存在属性时，也要把联系属性加入属性少的实体中作为关系属性；或者可以这么说——先构建出联系的关系模型，再将联系的关系模型属性放入属性少的实体的关系模型中</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614193027153.png" alt="image-20240614193027153"></p><h4 id="第四步：处理一对多关系"><a href="#第四步：处理一对多关系" class="headerlink" title="第四步：处理一对多关系"></a><strong>第四步：处理一对多关系</strong></h4><p>将一对多关系所涉及的两个实体所对应的两个关系模式，将”<strong>一</strong>”那边的主键加入到**”多”**那边的关系模式中，作为外键，以此表达一对多关系。</p><ul><li><strong>实际上还是和一对一类似，将联系的关系模型构造出(两边实体的主键+自身属性)，再将联系的关系模型属性给到”多”(<code>0..*</code>)那边的关系模式中</strong></li><li>再强调一遍，是把<code>1</code>的主键给<code>多</code>！</li><li>另外，如何辨别一对多关系？严格的一对多，<code>1</code>是指<code>1..1</code>，<code>多</code>指最多是<code>*</code>即可。</li><li>另外要注意，<code>1</code>的主键给到<code>多</code>，也就是<code>多</code>的<strong>主键的一部分</strong>了，那么<code>多</code>再作为<code>1对多</code>关系的<code>1</code>端时，要把<strong>更新后的主键全部给到另一个”多”关系</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614193330923.png" alt="image-20240614193330923"></p><p><strong>WARNING：实体自己构成一对多关系，属性还是加在自己身上</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614193500400.png" alt="image-20240614193500400"></p><h4 id="第五步：处理多对多关系"><a href="#第五步：处理多对多关系" class="headerlink" title="第五步：处理多对多关系"></a><strong>第五步：处理多对多关系</strong></h4><p>单独创建一个关系(Relation)来表达多对多关系(Relationship)，将多对多关系所涉及的两个实体所对应的两个关系(Relation)的主键加入到新创建的关系中，作为该关系主键的组成部分，自然也是外键，以此表达多对多关系。</p><p><strong>实际上就是，将联系转换成一个单独的关系模式，独立于两个实体转成的关系模式之外</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614193555199.png" alt="image-20240614193555199"></p><p><strong>完成5步后得到的关系模式</strong></p><p>箭头指向外键所在的原本关系的属性</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614193721583.png" alt="image-20240614193721583"></p><h4 id="第六步：处理多值属性"><a href="#第六步：处理多值属性" class="headerlink" title="第六步：处理多值属性"></a><strong>第六步：处理多值属性</strong></h4><p>对多值属性，单独创建一个关系(Relation)来表达，将其所属的关系(Relation)的主键，加进所创建的关系中，作为主键的组成部分，自然也是外键</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614193832830.png" alt="image-20240614193832830"></p><h4 id="第七步：处理度-3的关系"><a href="#第七步：处理度-3的关系" class="headerlink" title="第七步：处理度&gt;&#x3D;3的关系"></a><strong>第七步：处理度&gt;&#x3D;3的关系</strong></h4><p>仍然是单独创建一个关系来表达，这个关系就是联系转换成的关系，关系的主键是各实体的主键</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614194001029.png" alt="image-20240614194001029"></p><h4 id="最终得到的关系模式："><a href="#最终得到的关系模式：" class="headerlink" title="最终得到的关系模式："></a><strong>最终得到的关系模式：</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614194028925.png" alt="image-20240614194028925"></p><hr><h3 id="四、数据库设计验证"><a href="#四、数据库设计验证" class="headerlink" title="四、数据库设计验证"></a>四、数据库设计验证</h3><h4 id="1-关系模式设计"><a href="#1-关系模式设计" class="headerlink" title="1.关系模式设计"></a>1.关系模式设计</h4><h5 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a><strong>设计问题</strong></h5><ul><li><strong>信息的不可表示问题</strong><ul><li><strong>插入异常</strong>：如果没有职工具有8级工资，则8级工资的工资数额就难以插入</li><li><strong>删除异常</strong>：如果仅有职工赵明具有4级工资，如果将赵明删除，则有关4级工资的工资数额信息也随之删除了</li></ul></li><li><strong>信息的冗余问题</strong><ul><li><strong>数据冗余</strong>：职工很多，工资级别有限，每一级别的工资数额反复存储多次</li><li><strong>更新异常</strong>：如果将5级工资的工资数额调为620，则需要找到每个具有5级工资的职工，逐一修改</li></ul></li></ul><h5 id="期望的关系模式特性"><a href="#期望的关系模式特性" class="headerlink" title="期望的关系模式特性"></a><strong>期望的关系模式特性</strong></h5><ol><li>一个关系(relation）：<strong>表达</strong>一个<strong>实体（Entity）</strong>，或者一个<strong>多对多</strong>的<strong>二元联系，<strong>或者</strong>多元</strong>联系。它由一组逻辑上相关联的属性构成。</li><li><strong>无损联接性</strong>是指将一个关系(relation）分解成2个或多个关系(relation）之后，原有的关系能够通过做<strong>自然联接</strong>来<strong>复原</strong>。</li><li><strong>依赖保留性</strong>指将一个关系分解成2个或多个关系，<strong>分解前的函数依赖性在分解之后仍然存在</strong>，其具体情况看后面的BC范式</li></ol><h4 id="2-函数依赖"><a href="#2-函数依赖" class="headerlink" title="2.函数依赖"></a>2.函数依赖</h4><blockquote><p>函数依赖 ≠ 约束，函数依赖在表上成立，约束则是在业务规则上符合指定要求</p></blockquote><p>定义：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614212328882.png"></p><h5 id="2-1平凡函数依赖"><a href="#2-1平凡函数依赖" class="headerlink" title="2.1平凡函数依赖"></a>2.1平凡函数依赖</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614212654849.png" alt="image-20240614212654849"></p><ul><li>课后思考：一个关系模式有n个属性，那么在它上面成立的所有可能的函数依赖有多少个？非平凡的函数依赖又有多少个？<ul><li>n个属性，则属性集有2^n个，X-&gt;Y，X,Y都是2^n的属性集，故属性依赖有2^n * 2^n &#x3D; 2^2n</li><li>平凡函数依赖有2^n个，故非平凡的有2^2n-2^n</li></ul></li></ul><h5 id="2-2部分函数依赖"><a href="#2-2部分函数依赖" class="headerlink" title="2.2部分函数依赖"></a>2.2部分函数依赖</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614212839943.png" alt="image-20240614212839943"></p><p><strong>候选键——f</strong></p><p><strong>超键——p</strong></p><h5 id="2-3传递函数依赖"><a href="#2-3传递函数依赖" class="headerlink" title="2.3传递函数依赖"></a>2.3传递函数依赖</h5><ul><li>注意传递函数依赖的条件：<ul><li>Y函数依赖于X，但是<strong>X并不函数依赖于Y</strong></li><li><strong>Z不是Y的子集</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614213126933.png" alt="image-20240614213126933"></p><h5 id="2-4键与主属性"><a href="#2-4键与主属性" class="headerlink" title="2.4键与主属性"></a>2.4键与主属性</h5><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614213311978.png" alt="image-20240614213311978"></p><h4 id="3-范式"><a href="#3-范式" class="headerlink" title="3.范式"></a>3.范式</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>范式是对关系的不同数据依赖程度的要求</li><li>通过模式分解，将一个低级范式转换成若干个高级范式的过程称作<strong>规范化</strong><ul><li>实际上，可以把范式粗略地理解为数据表结构所需要符合的<strong>某种标准级别</strong>，低级范式就是低级级别，高级范式就是高级级别</li><li>高级范式一定满足低级范式</li></ul></li><li>范式分为6个：1NF，2NF，3NF，BCNF，4NF，5NF</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614213540938.png" alt="image-20240614213540938"></p><h5 id="2-1NF"><a href="#2-1NF" class="headerlink" title="2.1NF"></a>2.1NF</h5><p><strong>本质：关系中不能有多值属性</strong></p><p>定义：关系中的<strong>每一分量不可再分</strong>(不能有多值属性)。即不能以集合、序列等作为属性值</p><ul><li>分量是否可再分，取决于业务逻辑。如果用到值的一部分，那就需要进一步分隔，也就是提高原子粒度<ul><li>原子粒度一般越细越好，更方便约束</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614213944597.png" alt="image-20240614213944597"></p><h5 id="3-2NF"><a href="#3-2NF" class="headerlink" title="3.2NF"></a>3.2NF</h5><p><strong>本质：消除非主属性对候选键的部份依赖</strong></p><p>定义：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614214057418.png" alt="image-20240614214057418"></p><p>改造：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614214122916.png" alt="image-20240614214122916"></p><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614214206103.png" alt="image-20240614214206103"></p><h5 id="4-3NF"><a href="#4-3NF" class="headerlink" title="4.3NF"></a>4.3NF</h5><p><strong>本质：消除非主属性对候选键的传递依赖</strong></p><p>定义：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614214311366.png" alt="image-20240614214311366"></p><p>另一种定义：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614214439167.png" alt="image-20240614214439167"></p><p>改造：</p><ul><li>实际上是把传递依赖的Y——Z部分单独拎出来做个表</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614214331585.png" alt="image-20240614214331585"></p><h5 id="5-BCNF"><a href="#5-BCNF" class="headerlink" title="5.BCNF"></a>5.BCNF</h5><p><strong>本质：消除主属性对候选键的部分依赖和传递依赖</strong></p><p>定义：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614214608732.png" alt="image-20240614214608732"></p><p>另一种定义：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614214623556.png" alt="image-20240614214623556"></p><p>满足3NF但不满足BCNF的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240614215256920.png" alt="image-20240614215256920"></p><h4 id="4-函数依赖的推理"><a href="#4-函数依赖的推理" class="headerlink" title="4.函数依赖的推理"></a>4.函数依赖的推理</h4><h5 id="1-逻辑蕴涵"><a href="#1-逻辑蕴涵" class="headerlink" title="1.逻辑蕴涵"></a>1.逻辑蕴涵</h5><ul><li>定义<ul><li>关系模式R，F是其函数依赖，X，Y是其属性子集，如果从F的函数依赖能够推出X→Y，则称F<strong>逻辑蕴涵</strong>X→Y，记作F├ X→Y</li><li>被F所逻辑蕴涵的函数依赖的全体所构成的集合称作F的<strong>闭包</strong>，记作F+ &#x3D; {X→Y | F├ X→Y}</li></ul></li><li>示例</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240615150317417.png" alt="image-20240615150317417"></p><ul><li><strong>注意</strong><ul><li>F包含于F+，如果F&#x3D;F+，则F为函数依赖的一个完备集</li><li>规定：若X为U的子集，X→Φ 属于F+</li></ul></li></ul><h5 id="2-Armstrong公理"><a href="#2-Armstrong公理" class="headerlink" title="2.Armstrong公理"></a>2.Armstrong公理</h5><ul><li><strong>3条公理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240615150442916.png" alt="image-20240615150442916"></p><ul><li><strong>推导公理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240615150525544.png" alt="image-20240615150525544"></p><ul><li><p>Armstrong公理的正确性与完备性</p><p>A &#x3D; { f | 可用Armstrong公理从F中导出的函数依赖f}</p><p>B &#x3D; {f | 被F所逻辑蕴涵的函数依赖f}</p><ul><li><strong>正确性</strong>：用Armstrong公理从F中导出的函数依赖必为F所蕴涵，即A$\subseteq$B</li><li><strong>完备性</strong>：F所蕴涵的函数依赖都能用Armstrong公理从F中导出，即B$\subseteq$A</li></ul></li><li><p>引理：</p><ul><li>引理一：X→A1A2…Ak成立⇔X→Ai成立(i&#x3D;1,2,…k)</li><li>引理二：X→Y能由Armstrong公理导出⇔Y$\subseteq$$X_{F}^{+}$</li></ul></li><li><p><strong>属性集的闭包</strong></p><ul><li>设F为属性集U上的一组函数依赖，X$\subseteq$U，$X_{F}^{+}$&#x3D;{属性A | X→A能由F根据Armstrong公理导出}，那么称$X_{F}^{+}$为属性集X关于函数依赖集F的闭包</li><li>WARNING:区分好属性集闭包$X_{F}^{+}$和依赖集闭包$F^{+}$！！！！$X_{F}^{+}$的元素是属性，$F^{+}$的元素是依赖！！！</li></ul></li></ul><h5 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h5><h6 id="1-判断函数依赖是否成立"><a href="#1-判断函数依赖是否成立" class="headerlink" title="1.判断函数依赖是否成立"></a>1.判断函数依赖是否成立</h6><p>当要判定一个<strong>函数依赖</strong> <strong>X → Y</strong> <strong>是否成立</strong>时，就只要计算 $X^{+}$ ，如果Y$\subset$$X^{+}$，那么函数依赖 X → Y就成立</p><p>也就是，计算X的属性集闭包，若Y在闭包中，则函数依赖成立</p><ul><li>如何求出属性集X的闭包$X^{+}$？</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">Let X<span class="token operator">+</span> <span class="token operator">=</span> X Repeat如果F中有某个<span class="token function">FD</span><span class="token punctuation">(</span>函数依赖<span class="token punctuation">)</span>，它的左边是X<span class="token operator">+</span>的子集，那么就将该FD的右边的属性合并到 X<span class="token operator">+</span><span class="token punctuation">;</span> <span class="token function">Until</span> <span class="token punctuation">(</span> X<span class="token operator">+</span> 不发生改变 or  X<span class="token operator">+</span> <span class="token operator">=</span> U<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果$X^{+}$&#x3D;$X$，则称<strong>X是封闭的</strong></li></ul><h6 id="2-求函数依赖集F的闭包F"><a href="#2-求函数依赖集F的闭包F" class="headerlink" title="2.求函数依赖集F的闭包F+"></a>2.求函数依赖集F的闭包F+</h6><ul><li>记得考虑X→Φ ！！！比如X→Φ ，XY→Φ都算在函数依赖集的闭包中！</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240615152014344.png" alt="image-20240615152014344"></p><h6 id="3-判断属性集X是否是R的候选键"><a href="#3-判断属性集X是否是R的候选键" class="headerlink" title="3.判断属性集X是否是R的候选键"></a>3.判断属性集X是否是R的候选键</h6><p><strong>候选键的定义</strong>：如果X→A成立，但X的任一真子集$X^{-}$→A都不成立，那么X才是关系R的候选键</p><p>对于关系R，它的属性集合A，函数依赖集F，对于属性集合 X， X$\subset$A：</p><p> <strong>判断方式</strong>：如果 $X^{+}$ &#x3D; A；然后计算X的所有真子集的闭包，如果它们都不等于A；那么X是R的候选键，否则不是；</p><p><strong>候选键计算</strong>：</p><p>前置定义：</p><ul><li>定义<ul><li>左部属性，只出现在F左边的属性</li><li>右部属性，只出现在F 右边的属性</li><li>双部属性，出现在F 两边的属性</li><li>外部属性，不出现在F 中的属性</li></ul></li><li>定理<ul><li>左部属性一定出现在任何候选码中</li><li>右部属性一定不出现在任何候选码中</li><li>外部属性一定出现在任何候选码中</li></ul></li></ul><p><strong>如何通过给出的U和F找出关系R的所有候选码？</strong></p><ol><li>通过依赖集F找出<strong>左部属性、右部属性、双部属性</strong></li><li>先尝试求<strong>左部属性的子集的闭包</strong>，是否符合候选键的定义</li><li>如果都不符合，<strong>再加上双部属性求闭包</strong>，看是否符合候选键定义</li></ol><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240615152828517.png" alt="image-20240615152828517"></p><h6 id="4-函数依赖集的等价与覆盖"><a href="#4-函数依赖集的等价与覆盖" class="headerlink" title="4.函数依赖集的等价与覆盖"></a>4.函数依赖集的等价与覆盖</h6><ul><li><p>函数依赖集的等价性</p><ul><li>函数依赖集F，G，若$F^{+}&#x3D;G^{+}$，则称F和G等价</li><li>$F^{+}&#x3D;G^{+}$⇔$F \subseteq G^{+}$，$G \subseteq F^{+}$​</li></ul></li><li><p>函数依赖集的覆盖</p><ul><li><p>函数依赖集F，E，对E中的每一个函数依赖X → Y ，基于F，计算X+(也就是$X_{F}^{+}$)，然后检查Y是否在$X_{F}^{+}$中；</p><p>如果全部成立，那么F覆盖E；</p></li></ul></li><li><p>最小覆盖$F_{min}$</p><ul><li>**单属性化：**F中任一函数依赖X→A，A必是单属性</li><li>**无冗余化：**F中不存在这样的函数依赖X → A，使得F与F - {X → A}等价</li><li>**既约化：**F中不存在这样的函数依赖X→A，在X中有真子集Z，使得F与F - {X → A}$\cup${Z → A}等价</li></ul></li><li><p>求解最小覆盖$F_{min}$​</p><ul><li>通过下面的算法可以得出这样的结论：<ul><li>首先，将依赖右部的多值属性拆成单值</li><li>接着，删去一个依赖做左属性的属性集闭包，如右属性存在于闭包中，则删除这个依赖</li><li>最后，若$A \subseteq (X-Bi)_{F}^{+}$，那么就用$(X-Bi)-&gt;A$代替$X-&gt;A$<ul><li><strong>注意</strong>：$(X-Bi)_{F}^{+}$的计算是基于<strong>原依赖集F</strong>的，也就是在计算属性集闭包时，X-&gt;A的依赖还是存在的！</li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240615153553387.png" alt="image-20240615153553387"></p><h4 id="5-模式分解"><a href="#5-模式分解" class="headerlink" title="5.模式分解"></a>5.模式分解</h4><ul><li>定义</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240615153704878.png" alt="image-20240615153704878"></p><ul><li>示例</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240615153723844.png" alt="image-20240615153723844"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库笔记-2</title>
      <link href="/2024/04/11/shu-ju-ku-bi-ji-2/"/>
      <url>/2024/04/11/shu-ju-ku-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h2><h3 id="1-事务概念"><a href="#1-事务概念" class="headerlink" title="1.事务概念"></a>1.事务概念</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>事务是由一系列操作的序列构成的程序执行单元，这些操作<strong>要么都做，要么都不做</strong>，是<strong>不可分割</strong>的工作单位</li><li>SQL中事务的定义<ul><li>事务以<code>Begin transaction</code>开始，以<code>commit transaction</code>(提交事务)或<code>rollback transaction</code>结束(回滚，撤销已执行的那部分操作)</li><li><code>Commit transaction</code>表示提交，事务正常结束</li><li><code>Rollback transaction</code>表示事务非正常结束，撤销事务已做的操作，回滚到事务开始时的状态</li><li>格式如下：</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">TRANSACTION</span> <span class="token keyword">BEGIN</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>一系列操作<span class="token punctuation">)</span><span class="token keyword">END</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span> <span class="token comment">-- 正常结束提交，commit不可省略！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-事务特征"><a href="#2-事务特征" class="headerlink" title="2.事务特征"></a>2.事务特征</h4><ul><li>一个事务本质是用户的一次业务请求，是对数据库的一组操作，这些操作涉及对 一个或多个数据项进行更新&#x2F;修改</li><li>要求：中间状态对外部不可见</li></ul><h4 id="3-事务特性-ACID"><a href="#3-事务特性-ACID" class="headerlink" title="3.事务特性(ACID)"></a>3.事务特性(ACID)</h4><blockquote><p>事务特性，即一个DBMS支持事务的话，其所必须满足的特性</p></blockquote><ul><li><strong>原子性</strong>：事务中包含的所有操作要么全做，要么全不做。原子性由*<code>恢复机制</code>*实现</li><li><strong>一致性</strong>：事务的执行必须保证数据库的一致性。事务开始前与结束后，数据库都应该处于一致性状态<ul><li>一致性指的是，在外部看来，数据库中的数据总是正确的</li><li>这涉及到了数据正确性的问题，分为两种情况：<ul><li>出现故障(事务故障、系统崩溃、磁盘故障、灾难故障)时，数据会丢失&#x2F;残缺</li><li>无故障时，因为数据组织不合理，而导致数据更新异常、冗余、数据不正确</li></ul></li></ul></li><li><strong>隔离性</strong>：系统必须保证事务不受其他并发事务的影响。隔离性通过*<code>并发控制机制</code>*实现<ul><li>对任何一对事务T1,T2，在T1看来，T2要么在T1开始前就已经结束，要么在T1完成后再执行</li><li><strong>满足隔离性的条件</strong>：多事务并发执行，但从外部看，其结果与串行执行的结果一样</li></ul></li><li><strong>持久性</strong>：一个事务一旦提交后，它对数据库的影响必须是永久的；系统发生故障不能改变事务的持久性；持久性通过*<code>恢复机制</code>*实现<ul><li>一个事务一旦提交，即使随后发生故障，其结果在数据库中也不会丢失</li><li>P.S.事务未commit前，write操作在写入新值的同时还会备份旧值，方便回滚。commit后，备份删除</li></ul></li></ul><h4 id="4-事务生命周期图"><a href="#4-事务生命周期图" class="headerlink" title="4.事务生命周期图"></a>4.事务生命周期图</h4><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240411192116309.png" alt="image-20240411192116309"></p><hr><h3 id="2-事务调度"><a href="#2-事务调度" class="headerlink" title="2.事务调度"></a>2.事务调度</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>有多个事务需要执行时，<strong>这组事务对应的所有操作的执行顺序</strong>称为这组事务的一个调度，表示<strong>事务的指令在系统中执行的时间顺序</strong></li><li>一组事务的调度必须保证：<ul><li>包含了该组所有事务的操作指令</li><li>同一事务中的指令，在调度中的先后顺序，同其在事物内部的先后顺序必须保持一致</li></ul></li></ul><h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h4><ul><li><p>串行调度</p><ul><li>串行调度中，属于同一事务的指令紧挨一起</li><li>对于n个事务的事务组，可以有n!个不同的串行调度</li></ul></li><li><p>并行调度</p><ul><li>并行调度中，来自不同事务的指令可以交叉执行</li><li>当并行调度<strong>等价</strong>于某个串行调度时，则称它是正确的</li></ul></li><li><p>基本比较</p><ul><li>并行事务容易破坏数据库的一致性</li><li>串行事务效率低</li></ul></li><li><p>并行的优点</p><ul><li>一个事务由不同的步骤组成，所涉及的系统资源也不同。这些步骤可以并发执行，以提高系统的<strong>吞吐量</strong><ul><li>吞吐量：数据库在单位时间内处理请求的数量(每秒处理多少条请求)<ul><li>请求≠指令，请求通常指的是对数据库的一次操作请求，比如查询、插入、更新或删除数据等。请求可以是单个简单的操作，也可以是一组操作的组合。目前可以认为，请求＝事务</li></ul></li></ul></li><li>系统中存在着周期不等的各种事务，串行会导致难于预测的时延。如果各个事务所涉及的是数据库的不同部分，采用并发会减少<strong>平均响应时间</strong>（例如事务操作的表各不相同）<ul><li>平均响应时间：吞吐量的倒数(1&#x2F;吞吐量&#x3D;平均响应时间)</li><li>注意，倒数关系仅在串行条件下始终满足，并行关系不一定</li></ul></li></ul></li></ul><h4 id="3-可恢复调度"><a href="#3-可恢复调度" class="headerlink" title="3.可恢复调度"></a>3.可恢复调度</h4><ul><li><strong>事务的恢复</strong>：一个事务失败了，为保证事务的原子性，我们应该能够撤消（回滚）该事务对数据库已经造成的影响，如write过的数据项。如果有其它事务Tx读取了失败事务写入的数据，则该事务Tx也应该撤消（前提是Tx尚未commit，如果已经commited，那么就无法恢复，出现不一致）</li><li><strong>可恢复调度</strong>：指该调度可以回滚，也就是，在需要回滚的步骤之间不能有COMMIT</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240411193744096.png" alt="image-20240411193744096"></p><ul><li>结合上述案例：可恢复调度是指，对于每对事务T1和T2，如果T2<strong>读取</strong>了T1所写的数据，则T1必须<strong>先于</strong>T2提交</li></ul><h4 id="4-无级联调度"><a href="#4-无级联调度" class="headerlink" title="4.无级联调度"></a>4.无级联调度</h4><ul><li>级联回滚：因一个事务故障，导致一系列事务回滚的现象。因为需要撤销大量工作，一般应避免</li><li><strong>无级联调度</strong>：不会发生级联回滚的调度<ul><li>对于每对事务T1和T2，如果T2读取了T1所写的数据，则T1必须在T2<strong>读取前提交</strong></li><li>因此，无级联调度必然是可恢复调度</li></ul></li></ul><h4 id="5-Write-VS-Commit"><a href="#5-Write-VS-Commit" class="headerlink" title="5.Write VS Commit"></a>5.Write VS Commit</h4><ul><li>Write(又称 save)<ul><li>将数据项的值从内存中写入到数据库中，同时会备份好旧值，以便事务失败的时候需要回滚（将旧值写回该数据项），因此Write对数据库的修改是临时性的</li></ul></li><li>Commit<ul><li>事务提交之后，会终止该事务，并且所有的备份旧值会被清除，事务对数据项的修改（Write）将因为commit的完成，实现由临时性变为永久性。</li></ul></li></ul><hr><h3 id="3-事务隔离性"><a href="#3-事务隔离性" class="headerlink" title="3.事务隔离性"></a>3.事务隔离性</h3><h4 id="1-事务问题"><a href="#1-事务问题" class="headerlink" title="1.事务问题"></a>1.事务问题</h4><ul><li>丢失修改(写-写冲突)<ul><li><strong>两个事务T1和T2读入同一数据并修改，T1提交的结果破坏了T2提交的结果，导致T2的修改丢失</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240411195616016.png" alt="image-20240411195616016"></p><ul><li>读脏数据——脏读(写-读冲突)<ul><li><strong>事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤消，这时T1已修改过的数据恢复原值，<code>T2读到的数据与数据库中数据不一致</code>，则T2读到的数据就是脏数据</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240411195800399.png" alt="image-20240411195800399"></p><ul><li>不能重复读(读-写冲突)<ul><li><strong>事务T2读取某一数据后，事务T1对其做了修改，当T2再次读取该数据时，得到与前次不同的值，重复读导致不同值则表示出错，即不能重复读</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240411195900182.png" alt="image-20240411195900182"></p><ul><li>发生幻象<ul><li><strong>事务T2按一定条件读取了某些数据后，事务T1插入了一些满足这些条件的数据，当T2再次按相同条件读取数据时，发现多了一些记录</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240411200011641.png" alt="image-20240411200011641"></p><blockquote><p>总结：</p><p>丢失修改：两个事务读同一数据，各自修改后，先后写入时会出现吞掉某个修改的情况</p><p>脏读：重点是回滚，读入数据与数据库数据不一致</p><p>不可重复读：重点是update，数据在两次读取前被修改，导致同样的条件，读取的数据再次读取后值不一样了</p><p>幻读：重点是insert&#x2F;delete，第一次和第二次读出来的<strong>记录数目</strong>不一样</p></blockquote><h4 id="2-事务隔离性级别"><a href="#2-事务隔离性级别" class="headerlink" title="2.事务隔离性级别"></a>2.事务隔离性级别</h4><ul><li><p>数据库事务的隔离级别有4种，由高到低分别为：</p><ul><li>serializable(可串行化)：一个调度的执行必须等价于一个串行调度的结果</li><li>repeatable read(可重复读)：只允许读取已提交的记录，并要求调度中，一个事务对同一记录的两次读取之间，不存在其它事务对该记录的更新（update）操作</li><li>read committed(读提交)：只允许读取已提交的记录，但不要求可重复读 （两次读之间能够有其它事务的对数据项的更新）</li><li>read uncommitted(读未提交)：允许读取未提交的记录</li></ul></li><li><p>隔离性级别与不一致现象</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240411201105943.png" alt="image-20240411201105943"></p><h4 id="3-冲突可串行化"><a href="#3-冲突可串行化" class="headerlink" title="3.冲突可串行化"></a>3.冲突可串行化</h4><h5 id="1-指令的顺序"><a href="#1-指令的顺序" class="headerlink" title="1.指令的顺序"></a>1.指令的顺序</h5><p>考虑一个调度S中的两条连续指令（仅限于read与 write操作）Ii与Ij，分别属于事务Ti与Tj</p><p>①Ii &#x3D; read(Q), Ij &#x3D; read(Q);</p><p>②Ii &#x3D; read(Q), Ij &#x3D; write(Q);</p><p>③Ii &#x3D; write(Q), Ij &#x3D; read(Q);</p><p>④Ii &#x3D; write(Q), Ij &#x3D; write(Q);</p><p>在① 情况下，Ii与Ij的次序无关紧要。其余情况下，Ii与Ij的次序不同，其执行结果也不同，数据库最终状态也不同</p><p><strong><code>先读后写或先写后读显然会导致结果不同，但先写后写的区别？——Q的备份值被改变了！</code></strong></p><p><strong>WARNING：以上取决于read和write的对象是同一个，如果不是一个，又会有不同！</strong></p><h5 id="2-冲突指令"><a href="#2-冲突指令" class="headerlink" title="2.冲突指令"></a>2.冲突指令</h5><p>当两条指令是不同事务在相同数据项上的操作，并且其中至少有一个是write指令时，则称这两条指令是冲突的</p><p>如在②、③、④情况下，Ii与Ij 是冲突的</p><p>非冲突指令交换次序不会影响调度的最终结果</p><h5 id="3-冲突等价"><a href="#3-冲突等价" class="headerlink" title="3.冲突等价"></a>3.冲突等价</h5><p>如果调度S可以经过一系列<strong>非冲突指令</strong>交换转换成调度S’，则称调度S与S’是冲突等价的</p><ul><li><strong>交换操作都默认是两个连续的指令调换先后执行顺序</strong></li><li><strong>不同事务的两条连续指令，对应不同数据项的话，任何操作都是不冲突的</strong></li><li><strong>调度中，同一事务内的指令先后必须与原事务中的指令先后保持一致</strong></li></ul><h5 id="4-冲突可串行化定义"><a href="#4-冲突可串行化定义" class="headerlink" title="4.冲突可串行化定义"></a>4.冲突可串行化定义</h5><p><code>当一个调度S与一个串行调度冲突等价时，则称该调度是冲突可串行化的</code></p><h5 id="5-冲突可串行化判定"><a href="#5-冲突可串行化判定" class="headerlink" title="5.冲突可串行化判定"></a>5.冲突可串行化判定</h5><ul><li><p>判定方法——优先图</p><ul><li><p>一个调度S的优先图是这样构造的：它是一个有向图G &#x3D;（V，E），V是顶点集，E是边集。顶点集由所有参与调度的事务组成，边集由满足下述条件之一的边Ti—&gt; Tj组成：</p><p> ①在Tj执行read(Q)之前，Ti执行write(Q)</p><p> ②在Tj执行write(Q)之前，Ti执行read(Q)</p><p> ③在Tj执行write(Q)之前，Ti执行write(Q)</p></li><li><p>总结：<strong>存在读写冲突或者写写冲突时，先操作的事务，指向后操作的事务：<code>Ti—&gt;Tj</code></strong></p></li></ul></li><li><p>判定标准</p><ul><li>如果优先图中存在边Ti—&gt;Tj ，则在任何等价于S的串行调度S’中，Ti都必须出现在Tj之前</li><li><strong>如果调度S的优先图中有环，则S是非冲突可串行化的。如果图中无环，则S是冲突可串行化的</strong></li></ul></li></ul><h5 id="6-串行顺序"><a href="#6-串行顺序" class="headerlink" title="6.串行顺序"></a>6.串行顺序</h5><ul><li>串行顺序可由拓扑排序得到，求出与优先图的偏序相一致的线序<ul><li>也就是说，画出优先图，按照拓扑顺序拆解优先图得到的顺序就是事务串行顺序</li></ul></li></ul><hr><h3 id="4-封锁"><a href="#4-封锁" class="headerlink" title="4.封锁"></a>4.封锁</h3><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>封锁就是一个事务对某个数据对象加锁，取得对它一定的控制，限制其它事务对该数据对象使用</li><li>要访问一个数据项R，事务Ti必须先申请对R的封锁，如果R已经被事务Tj加了<strong>不相容</strong>的锁，则Ti需要等待，直至Tj释放它的封锁</li></ul><h4 id="2-基本锁类型"><a href="#2-基本锁类型" class="headerlink" title="2.基本锁类型"></a>2.基本锁类型</h4><ul><li><strong>排它锁(X锁)</strong><ul><li>事务T对数据对象R加上X锁，则<strong>其它事务对R的<em>任何</em>封锁请求都不能成功</strong>，直至T释放R上的X锁；又称写锁</li><li>申请对R的排它锁：lock-X(R)</li></ul></li><li><strong>共享锁(S锁)</strong><ul><li>事务T对数据对象R加上S锁，则<strong>其它事务对R的X锁请求不能成功</strong>，而<strong>对R的S锁&#x2F;U锁请求可以成功</strong>；又称读锁</li><li>申请对R的共享锁： lock-S(R)</li></ul></li><li><strong>更新锁(U锁)</strong><ul><li>事务T对数据对象R加上U锁，则表示R<strong><em>稍后</em>更新</strong>。<strong>修改值未写入时，U锁与S锁兼容，与X锁互斥；修改值写入时，U锁转换成为X锁</strong></li><li>确切的说，更新锁是<code>“即将更新锁”</code></li><li>这里的更新，是狭义上的更新，也就是替换旧值，<strong>不包括插入、删除</strong></li></ul></li></ul><table><thead><tr><th align="center">相容矩阵comp(A,B)</th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">请求锁模式A</td><td align="center">现有锁模式B</td><td align="center">现有锁模式B</td><td align="center">现有锁模式B</td></tr><tr><td align="center"></td><td align="center">S</td><td align="center">X</td><td align="center">U</td></tr><tr><td align="center">S</td><td align="center">是</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">X</td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">U</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><h4 id="3-锁持有期"><a href="#3-锁持有期" class="headerlink" title="3.锁持有期"></a>3.锁持有期</h4><ul><li>保持到事务结束时才释放的锁：长锁</li><li>在事务中途就可以释放的锁：短锁</li><li>例：<ul><li>可重复读(repeatable read)：长S锁</li><li>读提交(read commited)：短S锁</li><li>读不提交(read uncommited)：不申请锁</li></ul></li></ul><h4 id="4-封锁粒度"><a href="#4-封锁粒度" class="headerlink" title="4.封锁粒度"></a>4.封锁粒度</h4><ul><li><p>封锁对象</p><ul><li>属性值、属性值集合、元组、关系、某索引项（key）、整个索引、整个数据库、物理页、块</li></ul></li><li><p>封锁粒度大，则并发度低，封锁机构简单，开销小</p></li><li><p>封锁粒度小，则并发度高，封锁机构复杂，开销高</p></li><li><p>理想的情况是<strong>只封锁与规定的操作有关的的数据对象</strong>，称之为事务的<strong>完整性相关域</strong></p></li><li><p><strong>意向封锁(预约封锁)</strong></p><ul><li>在分层封锁中，封锁了上层节点就意味着封锁了所有内层节点。如果有事务T1对某元组加了S锁，而事务T2对该元组所在的关系加了X锁，因而隐含地X封锁了该元组，从而造成矛盾</li><li>引入意向锁I（Intend）：当某节点加上I锁，表明该节点的某些内层节点(子节点)已发生事实上的封锁，防止其它事务再去显式封锁该节点</li><li>I锁的实施是<strong>从封锁层次的根开始，依次占据路径上的所有节点，直至要真正进行显式封锁的节点的父节点</strong>为止<ul><li>下图中，S锁不兼容I锁的原因是，I锁有可能指的是IX锁</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240412154414404.png" alt="image-20240412154414404"></p><ul><li><strong>细化意向锁</strong><ul><li><strong>IS锁</strong><ul><li>如果对一个数据对象加IS锁，表示它的后裔节点拟（意向）加S锁</li><li>例如，要对元组加S锁，则首先要对关系和数据库加IS锁</li></ul></li><li><strong>IX锁</strong><ul><li>如果对一个数据对象加IX锁，表示它的后裔节点拟（意向）加X锁</li><li>例如，要对元组加X锁，则首先要对关系和数据库加IX锁<ul><li><strong>IS和IX能够兼容是因为同一节点的后代可以一部分被加S锁，其它部分被加X锁，只要没有同一部分被冲突性加锁，就没问题</strong></li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240412154946231.png" alt="image-20240412154946231"></p><p><strong><code>意向锁不是真的锁，只是一种提示，即某节点被加了意向锁之后，表明其下层后代节点存在对应的锁</code></strong></p><h4 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5.死锁"></a>5.死锁</h4><ul><li><p><strong>定义</strong>：两个事务都封锁了一些数据对象，并相互等待对方释放另一些数据对象以便对其封锁，结果两个事务都不能结束，则发生死锁</p></li><li><p><strong>发生条件</strong></p><ul><li>①互斥条件：事务请求对资源的独占控制</li><li>②占有等待条件：事务已持有一定资源，又去申请并等待其它资源</li><li>③非抢占条件：直到资源被持有它的事务释放之前，不可能将该资源强制从持有它的事务夺去</li><li>④循环等待条件：存在事务相互等待的等待圈</li><li><strong>定理</strong>：<strong>在条件① ② ③成立的前提下，条件④是死锁存在的充分必要条件</strong><ul><li>如下图所示，事务T2和T3间存在环——死锁</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240412155410401.png" alt="image-20240412155410401"></p><ul><li><p>预防死锁</p><ul><li>预先占据所需的全部资源，要么一次全部封锁要么全不封锁 <ul><li>缺点：难于预知需要封锁哪些数据并且数据使用率低</li></ul></li><li>所有资源预先排序，事务按规定顺序封锁数据</li><li>使用抢占与事务回滚<ul><li>wait-die(抢占)：如果T1等待T2，仅当T1的时间戳小于T2时，允许T1等待，否则回滚T1。</li><li>wound-wait(回滚)：如果T1等待T2，仅当T1的时间戳大于T2时，允许T1等待，否则回滚T2</li></ul></li></ul></li><li><p>死锁检测和恢复</p><ul><li>超时法：如果等待封锁的时间超过限时，则撤销该事务</li><li>等待图法(略)</li></ul></li></ul><hr><h3 id="5-并发处理策略"><a href="#5-并发处理策略" class="headerlink" title="5.并发处理策略"></a>5.并发处理策略</h3><p>略</p><hr><h3 id="6-故障处理"><a href="#6-故障处理" class="headerlink" title="6.故障处理"></a>6.故障处理</h3><h4 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h4><ul><li>事务故障</li><li>系统崩溃故障(一般说的故障，默认是系统崩溃故障)</li><li>硬件故障</li><li>天灾</li></ul><h4 id="2-故障恢复的方法"><a href="#2-故障恢复的方法" class="headerlink" title="2.故障恢复的方法"></a>2.故障恢复的方法</h4><ul><li>分页方法(效率低)</li><li>日志方法(常用)</li></ul><h4 id="3-事务故障恢复"><a href="#3-事务故障恢复" class="headerlink" title="3.事务故障恢复"></a>3.事务故障恢复</h4><p><strong>特征：事务不能执行下去，未完成；</strong></p><p>**恢复方法：**执行回卷(Rollback)操作：当事物Ti要撤销时，反向扫描日志内容，对Ti的每项数据操作记录，执行undo(Ti) 操作，使用旧值恢复数据项的原有值，即撤销事务已做的数据操作；直至遇到<Ti start> 记录为止，然后放弃Ti </p><h4 id="4-系统崩溃故障"><a href="#4-系统崩溃故障" class="headerlink" title="4.系统崩溃故障"></a>4.系统崩溃故障</h4><h5 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h5><p>①重启数据库管理系统；</p><p>②从日志磁盘读取日志文件；</p><p>③反向扫描日志，即从日志文件的结束位置开始后向扫描。对于在日志记录中没有<Ti commit> 记录的事物，执行回卷操作(Rollback)，使用旧值恢复数据项，做undo( )处理:</p><p>④然后从日志文件的开始位置前向扫描。 对日志记录中含有<Ti commit>的事务，执行redo(Ti) 操作，使用新值赋值数据库中的数据项，确保事物的有效性；</p><h5 id="2-检查点-加快故障恢复"><a href="#2-检查点-加快故障恢复" class="headerlink" title="2.检查点(加快故障恢复)"></a>2.检查点(加快故障恢复)</h5><ul><li><p>概念</p><ul><li>**做检查点的目的：***<strong>加快系统崩溃故障恢复过程</strong> <strong>。基于如下观察：</strong><ul><li>*扫描整个日志文件很费时；</li><li>对已经输出到了数据库磁盘的事务数据项没有必要再做redo操作；**</li></ul></li></ul></li><li><p><strong>周期性地</strong>做检查点(checkpointing):</p><p>①<strong>暂停所有当前活动事务；</strong></p><p>②<strong>把日志缓冲区中的所有日志记录输出到日志磁盘；</strong></p><p>③<strong>把数据库缓冲区中的所有修改输出到数据库磁盘；</strong></p><p>④<strong>写一条</strong> <strong>&lt; checkpoint, &lt;** **当前活动事务的标识号列表** **&gt;&gt;</strong> <strong>日志记录到日志磁盘；</strong></p></li><li><p>有检查点的系统崩溃恢复</p><ul><li><strong>①从日志文件的结尾处反向扫描，直至遇到最近的 <checkpoint> 记录为止；</strong></li><li><strong>②对反向扫描中只有<Ti start> 而没有<Ti commit>的事务，执行回卷操作(Rollback (Ti) )，做撤销处理；</strong></li><li><strong>③从<checkpoint>开始前向扫描日志记录，对有<Ti commit>的事务，执行redo(Ti)操作，保证其生效；</strong></li></ul></li></ul><h4 id="5-数据库磁盘故障"><a href="#5-数据库磁盘故障" class="headerlink" title="5.数据库磁盘故障"></a>5.数据库磁盘故障</h4><h5 id="1-处理手段：备份操作-Dump"><a href="#1-处理手段：备份操作-Dump" class="headerlink" title="1.处理手段：备份操作(Dump)"></a>1.处理手段：备份操作(Dump)</h5><p>周期性地执行备份(dump) 操作，对磁盘数据库进行磁盘备份:</p><ul><li><p>①不再接收客户事务请求，让当前所有活动事务执行完毕；</p></li><li><p>②输出日志缓冲区中的日志记录到日志磁盘中;</p></li><li><p>③输出数据库缓冲区中的缓冲数据到数据库磁盘中;</p></li><li><p>④把数据库磁盘中的数据库文件拷贝到另一个磁盘上；</p></li><li><p>⑤往日志磁盘中写入一条 <dump> 日志记录；</p></li><li><p>⑥接收客户事物请求，恢复正常处理；</p></li></ul><h5 id="2-数据库磁盘故障的特征：数据库数据全部丢失"><a href="#2-数据库磁盘故障的特征：数据库数据全部丢失" class="headerlink" title="2.数据库磁盘故障的特征：数据库数据全部丢失"></a>2.数据库磁盘故障的特征：<strong>数据库数据全部丢失</strong></h5><h5 id="3-恢复方法"><a href="#3-恢复方法" class="headerlink" title="3.恢复方法"></a>3.恢复方法</h5><p>①用最近备份的数据库磁盘替换掉失效的数据库磁盘；</p><p>②重启数据库管理系统；</p><p>③读日志文件，从文件末尾反向扫描直至<dump>记录；</p><p>④再顺向扫描日志记录，对有<Ti commit>记录的事务做redo(Ti)操作；</p><p><strong>忽略哪些dump-故障之间未完成的事务，因为不需要处理了，数据都没了</strong></p><h4 id="6-日志磁盘故障"><a href="#6-日志磁盘故障" class="headerlink" title="6.日志磁盘故障"></a>6.日志磁盘故障</h4><p>日志本来就是冗余的，只要数据库不发生故障，日志就没用场</p><p><strong>恢复方法：</strong></p><p>①不再接收客户事务请求，让当前的所有活动事务执行完毕；</p><p>②输出数据库缓冲区中的缓冲数据到数据库磁盘中;</p><p>③执行备份(Dump)操作，把磁盘中的数据库文件拷贝到另一个磁盘上；</p><p>④用一个好的磁盘更换日志磁盘；</p><p>恢复正常处理；</p><ul><li>日志磁盘和数据库磁盘同时故障——<strong>无法恢复</strong></li></ul><h4 id="7-灾难故障-容灾"><a href="#7-灾难故障-容灾" class="headerlink" title="7.灾难故障(容灾)"></a>7.灾难故障(容灾)</h4><p>远程备份</p><hr><h2 id="五、性能提升"><a href="#五、性能提升" class="headerlink" title="五、性能提升"></a>五、性能提升</h2><h3 id="1-数据库性能指标"><a href="#1-数据库性能指标" class="headerlink" title="1.数据库性能指标"></a>1.数据库性能指标</h3><ul><li><p><strong>事务吞吐量</strong><strong>(Transaction throughput):</strong> 单位时间中能够处理的交易(事务)数量.</p></li><li><p><strong>响应时间</strong><strong>(Response time):</strong> 完成单个交易所用的时间**.**</p></li><li><p>**总指标：***<strong>事务吞吐量</strong> <strong>&#x2F;</strong> <strong>响应时间</strong></p></li></ul><h3 id="2-提高数据库性能的策略"><a href="#2-提高数据库性能的策略" class="headerlink" title="2.提高数据库性能的策略"></a>2.提高数据库性能的策略</h3><ul><li>挖掘和使用：<ul><li>数据特性</li><li>硬件特性</li><li>数据访问特性<ul><li>将用户<strong>访问频繁的数据</strong>放置在中央位置，把<strong>联系紧密的数据</strong>邻近存储</li></ul></li></ul></li></ul><h3 id="3-提高数据库性能的方法"><a href="#3-提高数据库性能的方法" class="headerlink" title="3.提高数据库性能的方法"></a>3.提高数据库性能的方法</h3><ul><li><strong>方法1: 排序;</strong></li><li><strong>方法2: 索引 （Tree索引和哈希索引）；</strong></li><li><strong>方法3: 连续的磁盘存储;</strong></li><li><strong>方法4: 分类、聚簇;</strong></li><li><strong>方法5: 内存缓冲;</strong></li><li><strong>方法6: 并发执行;</strong></li><li><strong>方法7: 查询优化;</strong></li><li><strong>方法8: 日志和数据分盘存储；</strong></li></ul><p><strong><code>其中，与数据库设计相关的方法：排序、索引、连续磁盘存储、分类聚簇、内存缓冲、日志和数据分盘存储</code></strong></p><blockquote><p>重点记住上面的几种方法的名称即可</p></blockquote><h4 id="1-索引"><a href="#1-索引" class="headerlink" title="1.索引"></a>1.索引</h4><ul><li><p>原理：<strong>压缩+排序</strong></p></li><li><p>详见之前的索引</p></li><li><p>需要注意的是索引分为两类：顺序索引、散列索引(哈希)</p><ul><li>散列索引更适合等值类的查询，而不适合范围查询和模糊查询，因为其本身是用哈希函数来作为映射关系，故不保留原列的顺序，也没法对未知键值进行映射</li></ul></li><li><p>数据量少的表不要创建索引，没有意义，直接读可能比顺序索引找B+树更快</p></li><li><p>增大压缩比，也就是压缩B+树的大小，使得层数更少，查找更快</p><ul><li>方式：合理选择索引字段顺序，选择性高的字段在前，也就是具有较多唯一值的字段</li><li>对于一个表的外键字段，创建索引时，由于很多行的外键字段值相同，该如何处理，以增大压缩比？<ul><li><strong>考虑字段的基数（Cardinality）</strong>：如果外键字段的基数（即唯一值的数量）较低，那么它们的索引可能不会太大。相反，如果基数较高，索引可能会变得较大。这一点可以影响索引的压缩比。如果一个字段的基数高，即有很多不同的值，那么对这个字段进行索引可能会更有意义，因为它可以帮助查询快速定位到特定的记录</li><li><strong>字段顺序</strong>：将字段相同的记录放在一起可以增加索引的压缩比。这意味着尽量将字段相同的记录放在索引中靠近一起的位置。因此，如果外键字段的大部分值相同，可以考虑将这些值放在索引的最前面。</li></ul></li></ul></li><li><p><strong>要求创建主键索引，本质上是要求添加主键约束！！！</strong></p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> tablename<span class="token keyword">add</span> <span class="token keyword">constraint</span> pk <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">(</span>member_id<span class="token punctuation">,</span> community_id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-聚簇"><a href="#2-聚簇" class="headerlink" title="2.聚簇"></a>2.聚簇</h4><p>减少磁头移动路程—把关系紧密的数据临近存储——聚簇(Clustering)</p><ul><li><strong>把关系紧密的数据临近存储</strong> <strong>—连续空间存储</strong><ul><li>访问频繁的数据存储在中央位置</li></ul></li></ul><h4 id="3-内存缓冲-缓存"><a href="#3-内存缓冲-缓存" class="headerlink" title="3.内存缓冲(缓存)"></a>3.内存缓冲(缓存)</h4><p><strong>缓存</strong>能使得<strong>批量读磁盘</strong>，<strong>批量写磁盘</strong>成为可能，<strong>可减少磁盘运输次数，也可减少磁头移动的总路程</strong>。其原理：<strong>规模效益</strong>。；</p><h4 id="4-并发执行"><a href="#4-并发执行" class="headerlink" title="4.并发执行"></a>4.并发执行</h4><p>略</p><hr><h2 id="六、安全管理"><a href="#六、安全管理" class="headerlink" title="六、安全管理"></a>六、安全管理</h2><h3 id="1-DBMS安全措施"><a href="#1-DBMS安全措施" class="headerlink" title="1.DBMS安全措施"></a>1.DBMS安全措施</h3><ul><li>第一道防线：账号登陆，建立连接</li><li>第二道防线：权限管理</li><li>威慑措施(技术手段与工具)：审计</li></ul><h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2.权限管理"></a>2.权限管理</h3><h4 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>用户登录后，要访问数据库中的每一个对象，还有权限要求。权限的授予可用&lt;**授予者, 对象，权限，被授予者**&gt;四元组来标识。</li><li>权限管理有三条准则：<ul><li>1）某个对象，其创建者拥有对其访问的全部权限；</li><li>2）一个用户可将其拥有的权限授予给其它用户；</li><li>3）授权者可收回其授予出去的权限，权限的收回具有连带性。</li></ul></li></ul><h4 id="2-实施："><a href="#2-实施：" class="headerlink" title="2.实施："></a>2.实施：</h4><ul><li>在数据库中创建表，创建<strong>用户类别</strong>，然后为每个用户类别指定其能访问的对象，明确其<strong>操作权限</strong><ul><li>在SQL语言中，<strong>用户类别</strong>被叫做<strong>角色ROLE</strong>(本质上是一个权限组)</li><li>也就是在数据库中为每个用户<strong>创建</strong>一个<strong>账号</strong>，再确定其<strong>所属的用户类别</strong></li></ul></li></ul><h4 id="3-访问权限的管理粒度："><a href="#3-访问权限的管理粒度：" class="headerlink" title="3.访问权限的管理粒度："></a>3.访问权限的管理粒度：</h4><ul><li><p><strong>读权限</strong>：SELECT；粒度：表。</p></li><li><p><strong>更新权限</strong>：INSERT， UPDATE。 粒度：表，还可进一步指定列</p><p>​                  DELETE；粒度：表。</p></li><li><p><strong>DBMS中的权限管理</strong>是<strong>粗放型的</strong>。粒度并没有细化到表中的<strong>行</strong>。对于SELECT权限，也没有细化到<strong>列</strong>。<strong>并不能满足业务需求</strong>。</p></li><li><p><strong>细化的其它辅助措施</strong>：<strong>视图，存储过程，应用程序</strong></p></li></ul><h4 id="4-SQL"><a href="#4-SQL" class="headerlink" title="4.SQL"></a>4.SQL</h4><p>1.创建用户和角色</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">user</span> aaa identified <span class="token keyword">by</span> <span class="token string">'123'</span> <span class="token comment">-- identified by 密码</span><span class="token keyword">create</span> role teacher<span class="token keyword">drop</span> <span class="token keyword">user</span> aaa<span class="token keyword">drop</span> role teacher<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.授权</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">select</span> <span class="token keyword">on</span> dept <span class="token keyword">to</span> <span class="token keyword">public</span><span class="token punctuation">;</span> <span class="token comment">-- 将dept表的select权限给予public(全体)，如果只想select(部分列)，就要用视图(见下)</span><span class="token keyword">grant</span> <span class="token keyword">select</span><span class="token punctuation">,</span> <span class="token keyword">update</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">on</span> emp <span class="token keyword">to</span> Manager<span class="token punctuation">,</span> Director<span class="token punctuation">;</span><span class="token keyword">grant</span> <span class="token keyword">all</span> <span class="token keyword">privileges</span> <span class="token keyword">on</span> Proj <span class="token keyword">to</span> Director <span class="token keyword">with</span> <span class="token keyword">grant</span> <span class="token keyword">option</span><span class="token punctuation">;</span><span class="token comment">-- with grant option：权限可转发，=relay</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3.收回权限</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">revoke</span> <span class="token keyword">select</span> <span class="token keyword">on</span> dept <span class="token keyword">from</span> <span class="token keyword">public</span><span class="token punctuation">;</span><span class="token keyword">revoke</span> <span class="token keyword">all</span> <span class="token keyword">privileges</span> <span class="token keyword">on</span> emp <span class="token keyword">from</span> Director<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5-访问粒度细化"><a href="#5-访问粒度细化" class="headerlink" title="5.访问粒度细化"></a>5.访问粒度细化</h4><p>通过视图来增强安全——将SELECT权限细化到列</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> EmpView <span class="token keyword">AS</span><span class="token keyword">SELECT</span> eno<span class="token punctuation">,</span> ename<span class="token punctuation">,</span> title<span class="token punctuation">,</span> supereno<span class="token punctuation">,</span> dno <span class="token keyword">FROM</span> emp；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过视图来增强安全——将权限细化到行</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> AccountEmp <span class="token keyword">AS</span><span class="token keyword">SELECT</span> eno<span class="token punctuation">,</span> name<span class="token punctuation">,</span> title<span class="token punctuation">,</span> superno<span class="token punctuation">,</span> dno <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> dno <span class="token operator">=</span> <span class="token string">'410'</span><span class="token punctuation">;</span><span class="token comment">-- 授权</span><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span> <span class="token keyword">ON</span> AccountEmp <span class="token keyword">TO</span> AccountStaff<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-访问权限管理的技巧"><a href="#6-访问权限管理的技巧" class="headerlink" title="6.访问权限管理的技巧"></a>6.访问权限管理的技巧</h4><p><strong>不要给某个用户授权，而只给角色授权。然后再将角色授予给某个用户</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 给角色(role)授权,student是role</span><span class="token keyword">GRANT</span> <span class="token keyword">INSERT</span><span class="token punctuation">(</span>s_no<span class="token punctuation">,</span> c_no<span class="token punctuation">,</span> semester<span class="token punctuation">)</span> <span class="token keyword">ON</span> enroll <span class="token keyword">TO</span> student<span class="token punctuation">;</span><span class="token comment">-- 将角色授予用户</span><span class="token comment">-- WARNING：授权时，不要用用户身份授权，而应以角色身份授权</span><span class="token keyword">GRANT</span> student <span class="token keyword">TO</span> B<span class="token punctuation">;</span><span class="token comment">-- B可以是用户，也可以是role，本质上是把角色(role)的权限给到了用户/别的角色</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-审计"><a href="#3-审计" class="headerlink" title="3.审计"></a>3.审计</h3><ul><li><p>数据库中的另一种安全机制是<strong>审计(Audit)</strong>。审计就如在公共场所安装摄像机，对登录进数据库的用户的一举一动都进行记录。一旦发现安全问题，就可调阅审计记录，查清事实真相。</p></li><li><p><strong>用触发器实现安全审计</strong></p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> cheatingEmployee<span class="token keyword">AFTER</span> <span class="token keyword">UPDATE</span> <span class="token keyword">OF</span> salary <span class="token keyword">ON</span> EmpREFERENCING OLD <span class="token keyword">ROW</span> <span class="token keyword">AS</span> oldNEW <span class="token keyword">ROW</span> <span class="token keyword">AS</span> new<span class="token keyword">FOR EACH ROW</span><span class="token keyword">WHEN</span> <span class="token punctuation">(</span><span class="token variable">@new.salary</span> <span class="token operator">></span> <span class="token variable">@old.salary</span><span class="token operator">*</span><span class="token number">1.1</span><span class="token punctuation">)</span>            <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> auditEmpSalary<span class="token keyword">VALUES</span> <span class="token punctuation">(</span>get_user_id<span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> get_connect_ip<span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">timestamp</span><span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">@new.eno</span><span class="token punctuation">,</span><span class="token variable">@new.salary</span><span class="token punctuation">,</span><span class="token variable">@old.salary</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-攻击"><a href="#4-攻击" class="headerlink" title="4.攻击"></a>4.攻击</h3><p>SQL注入攻击——拒绝动态拼接SQL语句</p><p>HTML注入攻击</p><ul><li>由数据库应用程序来解决的安全问题包括：<ul><li>SQL注入攻击</li><li>HTML注入攻击</li><li>非法篡改数据库中信息</li></ul></li><li>由网络安全措施和协议保障解决的安全问题包括：<ul><li>假冒复制攻击</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库笔记-1</title>
      <link href="/2024/03/09/shu-ju-ku-bi-ji-1/"/>
      <url>/2024/03/09/shu-ju-ku-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul><li>课堂核心内容：<code>易证完全性</code></li></ul><blockquote><p>易：易用性，即数据使用简单性问题</p><p>证：正确性，即数据正确性问题</p><p>完：完整性，即数据完整性问题</p><p>全：安全性，即数据安全性问题</p><p>性：性能，即数据处理性能问题</p></blockquote><h3 id="1-数据与数据库"><a href="#1-数据与数据库" class="headerlink" title="1.数据与数据库"></a>1.数据与数据库</h3><ul><li><p>数据的3个属性</p><ul><li><p>类别性（每类数据都有很多条项，构成一个数据集）</p></li><li><p>有用性（必要）</p></li><li><p>语义性（有特定的含义，便于理解使用）</p></li></ul></li><li><p>数据库概念</p><ul><li>解决<code>更新费时费力，数据不一致，可靠性低</code>的方法，数据不再分散存储，而是<code>集中存储</code>在数据库中，谁要数据，都从数据库中取</li><li>特点：数据库中<code>一个数据只存一份</code></li><li>好处：提高数据的共享性、真实性；降低数据存储、管理成本；提高数据利用率</li><li>适用范围：数据发布者众多，数据使用者众多，且数据的使用交互频繁，数据库与使用者之间是一对多的关系</li></ul></li><li><p>数据库的特点</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/Snipaste_2024-03-09_13-57-55.jpg" alt="Snipaste_2024-03-09_13-57-55"></p><p><strong>总结</strong></p><ul><li>数据库由<code>表(Table)</code>组成。<code>表</code>包括<code>模式(schema)</code>和<code>数据(data)</code><ul><li>模式是<strong>数据库的组织和结构</strong>，模式中包含了schema对象，可以是表(table)、列(column)、数据类型(data type)、视图(view)、存储过程(stored procedures)、关系(relationships)、主键(primary key)、外键(foreign key)等。数据库模式可以用一个可视化的图来表示，它<strong>显示了数据库对象及其相互之间的关系</strong></li></ul></li><li>数据在数据库中的组织：用户数据不是原样存储在数据库中，而是要<code>严格按照类分表存储</code></li><li>同类数据都存储于同一张表中</li><li>类与类之间具有关系——实例和实例之间具有关系</li></ul><hr><h3 id="2-对数据库的访问——数据操作"><a href="#2-对数据库的访问——数据操作" class="headerlink" title="2.对数据库的访问——数据操作"></a>2.对数据库的访问——数据操作</h3><p><strong>用户对数据库中的数据进行的操作包括：</strong></p><ul><li>添加数据</li><li>查询数据</li><li>删除数据</li><li>修改数据</li><li>统计数据</li></ul><p><strong>对于关系型数据库，国际标准数据操作语言，称为<code>SQL语言</code></strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">例如:<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> stu <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*插入记录*/</span><span class="token keyword">UPDATE</span> stu <span class="token keyword">SET</span> birthdate <span class="token operator">=</span> <span class="token keyword">DATE</span><span class="token string">'2003-11-22'</span> <span class="token keyword">WHERE</span> stuNO <span class="token operator">=</span> <span class="token string">'202226010407'</span><span class="token punctuation">;</span><span class="token comment">/*插入记录*/</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> stu <span class="token keyword">WHERE</span> stuNO <span class="token operator">like</span> <span class="token string">'2007%'</span><span class="token punctuation">;</span><span class="token comment">/*删除记录*/</span><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> phone <span class="token keyword">FROM</span> stu <span class="token keyword">WHERE</span> nation<span class="token operator">&lt;></span><span class="token string">'汉'</span><span class="token punctuation">;</span><span class="token comment">/*查找记录*/</span><span class="token keyword">SELECT</span> sex<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> stu <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sex<span class="token punctuation">;</span><span class="token comment">/*统计*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-数据库系统的架构"><a href="#3-数据库系统的架构" class="headerlink" title="3.数据库系统的架构"></a>3.数据库系统的架构</h3><p><strong>数据库系统 &#x3D; 数据库 + 数据库管理系统(DBMS) + 数据库应用程序</strong></p><ul><li>数据库管理系统:受理用户的数据操作请求，完成数据操作，反馈结果给用户</li><li>数据库应用程序：方便用户实现对数据库访问的工具</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/Snipaste_2024-03-09_14-19-11.jpg" alt="Snipaste_2024-03-09_14-19-11"></p><p><strong>系统架构特点——相互独立性，可组合性</strong></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/Snipaste_2024-03-09_14-32-41.jpg" alt="Snipaste_2024-03-09_14-32-41"></p><p><strong>数据库系统架构特性——邦联式</strong></p><p><em>Browser——(HTTP&#x2F;HTML)——Web——(SQL)——DBMS——Database</em></p><p><strong>DB的三级模式架构</strong></p><p><em>用户&#x2F;应用——外模式——概念模式——内模式——数据库</em></p><p><strong>总结</strong>:</p><p>数据库的两个关键特性：</p><ul><li><code>系统的结构特性</code>：模块化，分层结构</li><li><code>数据的组织特性</code>：关系模型要求数据严格按类分表存储，以此保证数据库中数据的正确一致</li></ul><hr><h2 id="一-关系数据模型及其数据完整性约束"><a href="#一-关系数据模型及其数据完整性约束" class="headerlink" title="一.关系数据模型及其数据完整性约束"></a>一.关系数据模型及其数据完整性约束</h2><p><strong>数据模型的概念</strong>——<code>数据结构</code>+<code>数据完整性约束</code>+<code>数据运算</code></p><p>​          <strong>目的</strong>——提供框架，实现<code>易证完全性</code></p><p><strong>关系数据模型</strong>：</p><ul><li>数据结构：<code>二维表</code></li><li>数据完整性约束：<code>实体</code>，<code>引用</code>，<code>域</code>，<code>业务规则</code></li><li>数据运算：<code>关系代数</code></li></ul><h3 id="1-“关系”基本概念"><a href="#1-“关系”基本概念" class="headerlink" title="1.“关系”基本概念"></a>1.“关系”基本概念</h3><p><strong>域：</strong></p><ul><li>一组值的集合，这组值具有相同的数据类型（例如整数集合，字符串集合……）</li></ul><p><strong>笛卡尔积</strong>：</p><ul><li>一组域D<sub>1</sub>，D<sub>2</sub>，……，D<sub>n</sub>的笛卡尔积为：</li></ul><p>​$$ D_1 \times D_2 \times …\times D_n &#x3D; {(d_1, d_2,…,d_n)|d_i\in D_i, i&#x3D;1,…,n} $$​</p><ul><li>笛卡尔积的每个元素$(d_1,d_2,…,d_n)$称为一个<em>n-<strong>元组</strong></em></li><li>元组的每一个值$d_i$叫做一个分量</li></ul><p><strong>关系</strong>：</p><ul><li>笛卡尔积$ D_1 \times D_2 \times …\times D_n $ 的子集叫做在域 $D_1,D_2,…,D_n$ 上的关系，用 $R(D_1,D_2,…,D_n)$ 表示</li><li>R是关系的名字，n是关系的度或目</li><li>关系是笛卡尔积中有意义的子集</li><li>关系可以表示为二维表</li></ul><p><strong>关系的特性</strong>：</p><ol><li>在一个数据库中，表名唯一，不能重复</li><li>在一个表中，列名唯一，不能重复</li><li>每行数据表达一个实例，一个实例在表中只有一行数据</li><li>表中的列具有对等性，没有等级区别</li><li>表中的列具有对等性，没有先后概念</li><li>每一列中的分量来自同一个域，是同类型数据，<code>且分量不可再分</code></li><li>不同列可来自同一域</li></ol><p><strong>关系模式</strong>：</p><ul><li>关系的描述称作关系模式，包括关系名、关系中的属性名、属性向域的映象(<strong>域</strong>)、属性间的数据依赖关系等，记作R(A1 , A2 ,…, An ) <ul><li>R是关系名（表名），Ai是属性名（列）</li><li>属性向域的映象(<strong>域</strong>)一般直接说明为属性的类型、长度等</li><li>某一时刻对应某个关系模式的内容(元组的集合)称作关系</li><li><em><strong>关系模式是型（schema），是稳定的</strong></em></li><li><em><strong>关系是某一时刻的值，是随时间不断变化的</strong></em></li></ul></li></ul><hr><h3 id="2-键-Key"><a href="#2-键-Key" class="headerlink" title="2.键(Key)"></a>2.键(Key)</h3><p><strong>1.超键(Super Key)</strong></p><ul><li>关系中的一个属性组(含有1个或多个列的组)，<code>其值能唯一标识一个元组(行)</code></li><li>性质：一个属性组，如果其子集是超键，则该属性组也是超键，即任何超键的超集还是超键</li></ul><p><strong>2.候选键(Candidate Key)</strong></p><ul><li>满足特殊条件的超键：<code>如果一个超键删除任何一个属性后都不再是超键，则该键为关系的候选键。即**子集都不是超键的超键为候选键**</code></li><li>任何一个候选键中的属性称为<code>主属性</code></li></ul><p><strong>3.主键(Primary Key)</strong></p><ul><li>主键是候选键中的一个，是由关系选择的</li><li>实际上，主键是人为选择的，必须考虑<code>关系的特性以及现实意义</code>(例如，身份证号不能作为微信账号表的主键，因为微信账号是虚拟人，一个真人是可以绑定多个虚拟人的)</li><li><strong>主键是人为选择后，用SQL语言写在表的模式中的，所以并不是任一候选键都是主键</strong></li><li><code>除主键外的候选键</code>称为该关系的<code>唯一键</code>或<code>替代键</code></li></ul><p><strong>4.外键(Foreign Key)</strong></p><ul><li>关系中的一组属性，这组属性在其他表中是主键</li><li>外键在本表中也是需要指明的(即写在当下表的schema模式中)，<strong>不能遗漏</strong></li></ul><hr><h3 id="3-表与表分类"><a href="#3-表与表分类" class="headerlink" title="3.表与表分类"></a>3.表与表分类</h3><p><strong>1.强关系与弱关系</strong></p><p>A表有外键K，外键K是B表的主键，那么A,B表是强关系</p><p>A表与B表之间没有外键联系，仅有其他更弱的联系，比如有相同属性，那就是弱关系</p><p><strong>2.分类</strong></p><p>数据库中的表分为两种：<code>实体表</code>和<code>联系表(关系表)</code></p><p>例如，学生表，课程表都是实体表，而选课表就是联系表</p><blockquote><p>对于联系表，它表达了两个类的实例之间是多对多的关系</p><p>联系表的主键至少由两个外键组成</p></blockquote><p><strong>3.实体表中也可能包含外键</strong></p><p>例如，学生表里会有一个属性：学院编号，学院编号是学院表的主键</p><p><em><strong>实体表中含有外键，就代表着两个类的实例之间是一对多的关系</strong></em></p><hr><h3 id="4-域约束"><a href="#4-域约束" class="headerlink" title="4.域约束"></a>4.域约束</h3><p>在<strong>表</strong>的<strong>模式</strong>(schema)中，每个字段(属性)都有<code>数据类型和取值范围的约束</code></p><hr><h3 id="5-业务规则约束"><a href="#5-业务规则约束" class="headerlink" title="5.业务规则约束"></a>5.业务规则约束</h3><ul><li>数据库中的数据，要求完整，也就是必须满足业务规则要求(必须有业务规则所要求的属性)</li></ul><hr><h3 id="6-完整性约束"><a href="#6-完整性约束" class="headerlink" title="6.完整性约束"></a>6.完整性约束</h3><blockquote><p>数据完整性：数据有现实意义，与现实情况相符，满足业务规则</p><p>关系模型的三类完整性规则：</p><p>实体完整性</p><p>参照完整性</p><p>用户自定义完整性</p><p>数据库的完整性和安全性是两个不同的概念。数据库的完整性是指数据的正确性和相容性，是为了防止数据库中存在不符合语义的、不正确的数据；数据库的安全性是指保护数据库防止恶意破坏和非法存取。</p></blockquote><ul><li>实体完整性（约束)：必须指明主键</li><li>参照完整性（约束）：指明所有外键(没有就是null)，<strong>并确保外键值与同一表&#x2F;另一表的主键值相匹配</strong></li><li>域完整性（约束）：每一列要有明确的数据类型、数据格式和取值范围、以及是否可以为null</li><li>用户自定义完整性（约束）：针对某一具体应用的数据必须满足的语义要求</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Enroll <span class="token punctuation">(</span>sno  <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>cno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">,</span>semester <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>classNo <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>score  <span class="token keyword">SMALLINT</span>     <span class="token comment">/*前6行域约束*/</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>sno<span class="token punctuation">,</span> cno<span class="token punctuation">,</span> semester<span class="token punctuation">)</span><span class="token comment">/*主键约束*/</span><span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>sno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> student<span class="token punctuation">(</span>sno<span class="token punctuation">)</span><span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>cno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Course<span class="token punctuation">(</span>cno<span class="token punctuation">)</span><span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>tno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Teacher<span class="token punctuation">(</span>tno<span class="token punctuation">)</span><span class="token comment">/*外键约束*/</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/*用户自定义约束*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="7-关系代数"><a href="#7-关系代数" class="headerlink" title="7.关系代数"></a>7.关系代数</h3><p><em>关系代数是关系操作的一种表示形式，用于对集合进行操作，它的等价语言是关系演算，后者不展开</em></p><ul><li><p><strong>意义</strong>：因为数据库中的表要求必须严格按类分表存储，且一份数据只存一次，而业务表则需要多个类的实例同时出现在一张表上，因此引发了<code>业务表与数据库中的表不一致的问题</code></p><ul><li><strong>不一致问题用关系代数解决，这就是关系代数存在的意义!</strong></li></ul></li><li><p><strong>特性</strong>：<strong>输入是关系，输出也是关系</strong></p></li><li><p><strong>运算类型</strong>：</p><ul><li>一元运算：<ul><li>$ \sigma $ 选择</li><li>$\prod$​ 投影</li><li>$\rho$ 更名</li></ul></li><li>二元运算：<ul><li>$\times$ 笛卡尔积</li><li>$\Join$ 联接</li><li>$\cup$ 并</li><li>$-$ 集合差</li><li>$\cap$ 集合交</li><li>$\div$​ 除</li></ul></li></ul></li></ul><h4 id="1-选择运算"><a href="#1-选择运算" class="headerlink" title="1.选择运算"></a>1.选择运算</h4><ul><li><p>定义：在关系R中选择满足给定条件的元组(从行的角度)：</p><p>$$\sigma_F(R)&#x3D;{t|t\in R,F(t) &#x3D; ‘true’} $$​</p><ul><li>F为选择的条件，由<code>逻辑运算符</code>连接<code>算术表达式</code>而成，即<code>关系代数表达式</code><ul><li>逻辑表达式：$\wedge, \vee, \urcorner$</li><li>算术表达式：$ X \Theta Y$<ul><li>X, Y是属性名、常量或简单函数</li><li>$\Theta$是比较算符，$\Theta \in {&gt;,\geq,&lt;, \leq, &#x3D;, \neq}$</li></ul></li></ul></li><li>R为表名</li></ul></li></ul><h4 id="2-投影运算"><a href="#2-投影运算" class="headerlink" title="2.投影运算"></a>2.投影运算</h4><ul><li><p>定义：从关系R中取若干列组成新的关系(从列的角度)：</p><p>$$\prod_A(R) &#x3D; {t[A]|t \in R}, A \subseteq R$$</p></li><li><p><strong>投影的结果要去掉相同的行</strong></p><ul><li>具体一点就是，若<code>t[A]</code>这一列的分量中有重复的才会去重，如果是<em>非被选取列</em>的分量重复不影响</li></ul></li></ul><h4 id="3-更名运算"><a href="#3-更名运算" class="headerlink" title="3.更名运算"></a>3.更名运算</h4><ul><li>定义：给一个关系表达式赋予名字：<ul><li>$\rho_x(E)$——返回表达式E的结果，并把名字x赋给E</li><li>$\rho_{x(A_1,A_2,\ldots,A_n)}(E)$——返回表达式E的结果，并将名字x赋给E，同时将各属性更名为$A_1,A_2,\ldots,A_n$</li></ul></li><li><strong><code>关系被看作一个最小的关系代数表达式</code></strong>，所以可以将更名运算施加到关系上，得到具有不同名字的同一关系。这<strong>在同一关系多次参与同一运算时很有帮助</strong></li></ul><h4 id="4-并运算"><a href="#4-并运算" class="headerlink" title="4.并运算"></a>4.并运算</h4><ul><li><p>定义：所有至少出现在两个关系中之一的元组集合：</p><p>$$R \cup S &#x3D; {r|r \in R \vee r \in S}$$</p></li><li><p>关系R和S进行并运算的前提是它们必须是<strong>相容</strong>的：</p><ul><li><strong>关系R和S必须是同元的，即它们的<code>属性数目必须相同</code></strong></li><li><strong>对$\forall$​i，R的第i个属性的域必须和S的第i个属性的域相同</strong><ul><li>此时列的顺序就可能对是否能运算产生影响了</li></ul></li></ul></li></ul><h4 id="5-差运算"><a href="#5-差运算" class="headerlink" title="5.差运算"></a>5.差运算</h4><ul><li><p>定义：所有出现在一个关系而不在另一关系中的元组集合</p><p>$$R - S &#x3D; {r|r \in R \wedge r \notin S}$$</p></li><li><p><strong>R和S必须是相容！！！</strong></p></li><li><p>示例：求选修了001号而没有选002号课程的学生号</p><ul><li>错误的写法:<ul><li>$$\prod_{Sno}(\sigma_{Cno &#x3D; 001 \wedge Cno \neq 002}(SC))$$</li></ul></li><li>正确的写法：<ul><li>$$\prod_{Sno}(\sigma_{Cno &#x3D; 001}(SC))-\prod_{Sno}(\sigma_{Cno &#x3D; 002}(SC))$$​</li></ul></li><li><strong>“有A无B”必须用差运算，而不是在投影运算中的关系运算式中用与运算!</strong></li></ul></li></ul><h4 id="6-交运算"><a href="#6-交运算" class="headerlink" title="6.交运算"></a>6.交运算</h4><ul><li><p>定义：所有同时出现在两个关系中的元组集合</p><p>$$R \cap S &#x3D; {r|r \in R \wedge r \in S}$$</p></li><li><p>交运算可以通过差运算来重写 $R \cap S &#x3D; R - (R - S) $</p></li><li><p>示例：求同时选修了001号和002号的课程的学生号</p><ul><li><p>错误的写法：</p><ul><li>$$\prod_{Sno}(\sigma_{Cno &#x3D; 001 \wedge Cno &#x3D; 002}(SC))$$</li></ul></li><li><p>正确的写法：</p><ul><li>$$\prod_{Sno}(\sigma_{Cno &#x3D; 001}(SC))\cap\prod_{Sno}(\sigma_{Cno &#x3D; 002}(SC))$$</li></ul></li><li><p><strong>“同时”必须用交运算，而不是在投影运算中的关系运算式中用与运算!</strong></p></li></ul></li></ul><h4 id="7-笛卡尔乘积"><a href="#7-笛卡尔乘积" class="headerlink" title="7.笛卡尔乘积"></a>7.笛卡尔乘积</h4><ul><li><p>定义：两个关系R，S，其度分别为n，m，则它们的笛卡尔积是所有这样的元组集合：元组的前n个分量是R中的一个元组，后m个分量是S中的一个元组</p><p>$$ R \times S &#x3D; {\mathop{rs}\limits^{\frown}|r \in R \wedge s \in S}$$</p><ul><li><p>元组的连串：</p><ul><li><p>若元组$r &#x3D; (r_1,r_2,\ldots,r_n)$$,$$s&#x3D;(s_1,s_2,\ldots,s_m)$,则定义r和s的连串为：</p><p>$\mathop{rs}\limits^{\frown}&#x3D;(r_1,\ldots,r_n,s_1,\ldots,s_m)$</p></li></ul></li></ul></li><li><p>$R\times S$的度为R和S的度(列)之和，$R \times S$的元组个数为R和S的元组个数的乘积</p></li></ul><h4 id="8-Theta联接"><a href="#8-Theta联接" class="headerlink" title="8.Theta联接"></a>8.Theta联接</h4><ul><li><p>定义：从两个关系的广义笛卡儿积中选取给定属性间满足一定条件的<strong>元组</strong></p><p>$$R \underset{A \theta B}{\bowtie} S &#x3D; {\mathop{rs}\limits^{\frown}|r \in R \wedge s \in S \wedge r[A] \theta s[B]}$$</p><ul><li>A和B为R和S上度数相等且可比的属性列</li><li>$\theta$为算术比较符，为等号时称为等值连接</li><li>$A \theta B$​为算术表达式</li><li>$\theta$ 联接<strong>不去重</strong>！！！</li></ul></li><li><p>当算术表达式$A \theta B$$的$$\theta$为等号时，又叫<strong>等值联接</strong></p></li></ul><h4 id="9-自然联接"><a href="#9-自然联接" class="headerlink" title="9.自然联接"></a>9.自然联接</h4><p><em><strong>一种特殊的等值联接</strong></em></p><ul><li><p>定义：从两个关系的广义笛卡儿积中选取在<code>相同属性列B</code>上取值相等的元组，<code>并去掉重复的列</code></p><p>$$R {\bowtie} S &#x3D; {\mathop{rs}\limits^{\frown}|r \in R \wedge s \in S \wedge r[B] &#x3D; s[B]}$$</p></li><li><p>自然联接与等值联接的不同</p><ul><li>自然连接中相等的分量必须是相同的属性组，并且<code>要在结果中去掉重复的属性</code>，而等值连接则不必</li></ul></li><li><p>两个表做自然联接的基本要求：</p><ul><li>要有共同的属性</li></ul></li><li><p>如果两个表没有公共属性：</p><ul><li>自然联接退化为<em>笛卡尔积操作</em>，而不是<em>空关系</em></li></ul></li><li><p>多个表做自然联接：<strong><code>做自然联接的顺序非常重要，如果先做自然联接的表连串后没有出现后面的表中的属性，那么就不会有结果!</code></strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/Snipaste_2024-03-09_19-16-35.jpg" alt="自然联接图例"></p><h4 id="10-外联接与半联接"><a href="#10-外联接与半联接" class="headerlink" title="10.外联接与半联接"></a>10.外联接与半联接</h4><p><em>笛卡尔积、θ联接 （包括不等值联接、等值联接，当然也包含自然连接）称为 内联接(inner-join)</em></p><p><strong>外联接</strong>：</p><ul><li><p>为避免自然连接时因失配而发生的信息丢失，可以假定往参与连接的一方表中附加一个<code>取值全为空值的行</code>，它和参与连接的另一方表中的任何一个未匹配上的元组都能匹配，称之为<strong>外连接</strong></p></li><li><p>外连接 &#x3D; 自然连接 + 未匹配元组(<strong>悬挂元组</strong>)</p></li><li><p>外连接的形式：左外连接、右外连接、全外连接 </p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/Snipaste_2024-03-09_19-35-48.jpg" alt="Snipaste_2024-03-09_19-35-48"></p></li></ul><p><strong>半联接</strong>($\ltimes$)：</p><ul><li>半连接返回左表中与右表至少匹配一次的数据行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/Snipaste_2024-03-09_19-37-19.jpg" alt="Snipaste_2024-03-09_19-37-19"></p><h4 id="11-除运算"><a href="#11-除运算" class="headerlink" title="11.除运算"></a>11.除运算</h4><ul><li><p>象集：关系R(X , Z), X, Z是属性组，x是X上的取值，t是关系R的元组，定义x在R中的象集为：</p><p>$$Z_x&#x3D;{t[Z]|t \in R \wedge t[X]&#x3D;x}$$</p><ul><li>意义：从R中选出在X上取值为x的元组，<code>去掉X上的分量</code>，只留Z上的分量</li></ul></li><li><p>除运算定义：</p><p>$$R \div S &#x3D; {t[a_1,\ldots,a_n]|t \in R \wedge \forall s \in S((t[a_1,\ldots,a_n]\cup s)\in R)}$$</p><ul><li>{a1,…an}是R中存在但S中不存在的属性（列）集合</li><li>t[a1,…an] 是R中元组t在{a1,…an}上的分量</li><li><strong>除法要求S的属性集是R属性集的子集，否则除法结果为空集，现实情况，大部分都是S属性集是R属性集的子集的情况</strong></li></ul></li><li><p>可以这么理解，$R \div S &#x3D; T$，则T包含所有在R但不在S中的属性及其值，且$T \times S \in R$</p></li><li><p><code>示例：求选修了所有课程的学生(两张表：所有学生课程成绩表SC(Sno,Cno,score,...),课程表C(Cno,...))，哪个方案正确？</code></p><ul><li>方案1：$\prod_{Sno,Cno}(SC)\div \prod_{Cno}(C)$</li><li>方案2：$\prod_{Sno}(SC \div \prod_{Cno}(SC))$</li></ul></li><li><p>答案：方案1正确！</p><ul><li>正确的不必谈，方案2中，$SC \div \prod_{Cno}(SC)$的结果不是所有学生的学号(Sno)与成绩(score)，而是所有<code>每门课程分数一致的学生</code>的学号与成绩！(否则$T \times S \notin R$!!!!)</li></ul></li></ul><hr><h2 id="二、数据操作语言DML"><a href="#二、数据操作语言DML" class="headerlink" title="二、数据操作语言DML"></a>二、数据操作语言DML</h2><h3 id="1-SQL规范"><a href="#1-SQL规范" class="headerlink" title="1.SQL规范"></a>1.SQL规范</h3><blockquote><p><strong>SQL</strong>语言，全称是<strong>structured query language</strong>，即<strong>结构化查询语言</strong>，是一种用于管理和操作关系型数据库的标准语言，广泛应用于数据库查询、数据插入、更新和删除等操作</p></blockquote><ul><li>语言预留关键字 ，比如 <strong>SELECT, FROM, WHERE</strong>等</li><li>SQL <strong>不区分大小写</strong></li><li>分号为一个语句的结束标识符</li><li>基本数据类型：数值型，字符型。字符型常量的前后用单引号括起来。其它类型的常量都要用函数来转化成所想要的类型。例如，日期型： DATE ‘1975-05-17’， TIME ‘15:00:00’</li><li>字符串内部，需要打出一个单引号的话，需要转义：<strong>两个单引号表示一个单引号字符</strong>。 例如 ‘Master‘’s‘ 显示出来就是 Master’s</li></ul><hr><h3 id="2-SQL数据查询基本结构"><a href="#2-SQL数据查询基本结构" class="headerlink" title="2.SQL数据查询基本结构"></a>2.SQL数据查询基本结构</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> A1<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> An <span class="token comment">/*目标列，考虑顺序*/</span><span class="token keyword">from</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> rm <span class="token comment">/*表名*/</span><span class="token keyword">where</span> P <span class="token comment">/*关系表达式*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>查询基本结构可以用关系代数等价表示：</li></ul><p>​$$\prod_{A_1,A_2,\ldots,A_n}(\sigma_P(r_1\times r_2 \times \ldots \times r_m))$$</p><ul><li><strong><code>SQL规范中，select结果允许重复</code></strong></li><li><strong>warning</strong>:<strong>SQL中，一个查询语句就相当于一个程序，所以诸如更名运算等运算，仅在那一个查询语句中生效，该语句结束后，更名运算等运算就失效了!</strong></li></ul><hr><h3 id="3-select子句"><a href="#3-select子句" class="headerlink" title="3.select子句"></a>3.select子句</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> A <span class="token comment">/*A='目标列'*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>A &#x3D; 列名 &#x2F; * &#x2F; 算术表达式 &#x2F; 聚集函数</p><ul><li><code>&quot;*&quot;</code>：表示”所有的属性”<ul><li>例：给出所有学生的<em>所有信息</em></li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span><span class="token keyword">from</span> stu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p><strong><code>算术表达式</code></strong>：带 +，-，*，&#x2F;的算术表达式</p><ul><li><p>例：给出所有学生的姓名及出生年份</p></li><li><p>“2010-AGE”就是用2010减去每个元组中”AGE”字段(属性)的值得到的结果，将这个结果和SNAME一起组成一个新的关系(注意顺序)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> SNAME<span class="token punctuation">,</span> <span class="token number">2010</span><span class="token operator">-</span>AGE<span class="token keyword">from</span> stu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul></li><li><p>A &#x3D; 多个列组合成一列</p><ul><li><p>例：给出每个老师信息的自然语言描述</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> pname <span class="token operator">+</span> <span class="token string">'老师的工资是'</span> <span class="token operator">+</span> salary <span class="token operator">+</span><span class="token string">',年龄是'</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">', 职称是'</span> <span class="token operator">+</span> title<span class="token keyword">from</span> professor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><hr><h3 id="4-from子句"><a href="#4-from子句" class="headerlink" title="4.from子句"></a>4.from子句</h3><ul><li><p>from子句的作用在于<code>列出查询的对象表</code></p><ul><li><p>示例：找出选修课程的学生姓名、课程名、成绩</p><p>$$\prod_{Sname,Cname,Grade}(S \Join SC \Join C)$$</p><p>$$S \Join SC \Join C &#x3D; \sigma_{S.Sno &#x3D; SC.Sno \wedge SC.Cno &#x3D; C.Cno}(S \times SC \times C)$$</p></li><li><p>用SQL语言表达为：</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> Sname<span class="token punctuation">,</span> Cname<span class="token punctuation">,</span> Grade<span class="token keyword">from</span> S<span class="token punctuation">,</span> C<span class="token punctuation">,</span> SC<span class="token keyword">where</span> S<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno <span class="token operator">and</span> SC<span class="token punctuation">.</span>Cno <span class="token operator">=</span> C<span class="token punctuation">.</span>Cno<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>当目标列取自多个表时，需要<strong>显式指明</strong>来自那个关系</p><ul><li>示例：写出与$R(A,B) \Join S(B,C)$等价的SQL</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> A<span class="token punctuation">,</span> R<span class="token punctuation">.</span>B<span class="token punctuation">,</span> C<span class="token keyword">from</span> R<span class="token punctuation">,</span> S<span class="token keyword">where</span> R<span class="token punctuation">.</span>B <span class="token operator">=</span> S<span class="token punctuation">.</span>B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>在联接操作中，可能存在多个表具有相同列名的情况，使用<code>SELECT *</code>将无法区分这些列到底来自哪个表。</strong></li></ul></li></ul><hr><h3 id="5-where子句"><a href="#5-where子句" class="headerlink" title="5.where子句"></a>5.where子句</h3><ul><li><p>where子句的意义在于筛选出符合某种条件的元组，再交由select投影</p></li><li><p><strong>where语句工作是一行一行去筛选的，也就是说，直接在where的对象中使用聚集函数，得到的永远都是当下这一行(元组)的某个属性的值</strong></p></li><li><p>语法成分：</p><ul><li><p>比较运算符：&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D;，&#x3D;，&lt;&gt;(不等于)</p></li><li><p>逻辑运算符：and，or，not</p></li><li><p>between：判断表达式的值是否在某范围内</p><ul><li>例：列出工资在500到800之间的老师姓名</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> Tname<span class="token keyword">from</span> Teacher<span class="token keyword">where</span> Sal <span class="token operator">between</span> <span class="token number">500</span> <span class="token operator">and</span> <span class="token number">800</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><hr><h3 id="6-重复元组的处理"><a href="#6-重复元组的处理" class="headerlink" title="6.重复元组的处理"></a>6.重复元组的处理</h3><ul><li><p>语法约束：SQL<code>缺省为保留重复元组</code>，也可用关键字<strong>all</strong>显式指明。若要去掉重复元组，可用关键字<strong>distinct</strong>指明</p><ul><li><strong>注意，DISTINCT 关键字只能在 SELECT 子句的开头用于整个结果集的去重，而不能单独用于某个列。</strong></li></ul></li><li><p>示例：找出所有选修课程的学生</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> Sno<span class="token keyword">from</span> SC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>Question：两个表R(A,B)，S(A,C)，其中A是这两个表的主码，哪些查询中的<strong>distinct</strong>可以去掉？</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> R<span class="token punctuation">.</span>A<span class="token punctuation">,</span> S<span class="token punctuation">.</span>A<span class="token keyword">from</span> R<span class="token punctuation">,</span> S<span class="token keyword">where</span> R<span class="token punctuation">.</span>B <span class="token operator">=</span> S<span class="token punctuation">.</span>C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>这个查询选择了两个表中R.B和S.C相等的行，并且返回R.A和S.A这两列。由于A是R和S的主码，因此对于每个R.A的值，对应的S.A值只能有一个，所以结果集中不会有重复的R.A和S.A的组合。因此，<code>DISTINCT</code>关键字可以去掉</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> R<span class="token punctuation">.</span>A<span class="token keyword">from</span> R<span class="token punctuation">,</span> S<span class="token keyword">where</span> R<span class="token punctuation">.</span>B <span class="token operator">=</span> S<span class="token punctuation">.</span>C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>这个查询只选择了R.A列，并且条件是R.B &#x3D; S.C。同样由于A是R和S的主码，所以对于每个R.A的值，结果集中不会有重复的R.A值。因此，<code>DISTINCT</code>关键字可以去掉</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> R<span class="token punctuation">.</span>A<span class="token keyword">from</span> R<span class="token punctuation">,</span> S<span class="token keyword">where</span> R<span class="token punctuation">.</span>B <span class="token operator">=</span> S<span class="token punctuation">.</span>A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>这个查询选择了R.A列，并且条件是R.B &#x3D; S.A。由于A是R和S的主码，对于每个R.A的值，结果集中不会有重复的R.A值。因此，<code>DISTINCT</code>关键字可以去掉</li></ul><hr><h3 id="7-元组显示顺序"><a href="#7-元组显示顺序" class="headerlink" title="7.元组显示顺序"></a>7.元组显示顺序</h3><p><strong>-升&#x2F;降序</strong></p><ul><li>命令:<ul><li>列名可以是表的属性名，也可以是在select子句中的顺序号</li><li>一个order by可以设置多个列名，优先级由在order by中的先后顺序决定</li><li>order by语句中的列名不一定在select子句中，但一定在from子句的表内</li><li>不指明升序or降序，<code>默认升序排列</code></li></ul></li></ul><blockquote><p>order by + 列名 + asc(升序排列);order by + 列名 + desc(降序排列)</p></blockquote><ul><li><p>示例：</p><ul><li>1.按年龄升序列出学生信息，相同年龄学生按姓名降序排列</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span><span class="token keyword">from</span> stu<span class="token keyword">order</span> <span class="token keyword">by</span> AGE <span class="token keyword">asc</span><span class="token punctuation">,</span> Sname <span class="token keyword">desc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>2.对教工按缴纳所得税的多少排序</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> Tname<span class="token punctuation">,</span> salary<span class="token operator">*</span><span class="token number">0.2</span><span class="token keyword">from</span> TSAL<span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">2</span><span class="token comment">/*选择select的第2个对象*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>select的对象可以是列名&#x2F; * &#x2F;算术表达式&#x2F;聚集函数</strong></p><ul><li>3.按年龄顺序输出学生姓名</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> Sname<span class="token keyword">from</span> Stu<span class="token keyword">order</span> <span class="token keyword">by</span> AGE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="8-更名运算"><a href="#8-更名运算" class="headerlink" title="8.更名运算"></a>8.更名运算</h3><ul><li>格式：</li></ul><blockquote><p>old_name <strong>as</strong> new_name</p></blockquote><ul><li><p><strong>as</strong>大多数情况下可以省略，但为了增加可读性，建议显式写明!</p></li><li><p>更名运算可以为<code>关系</code>和<code>属性</code>重新命名，可出现在<code>select</code>和<code>from</code>子句中</p><ul><li>属性更名：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> Sname<span class="token string">'姓名'</span><span class="token punctuation">,</span> SEX<span class="token string">'性别'</span><span class="token punctuation">,</span> <span class="token number">2007</span><span class="token operator">-</span>AGE<span class="token string">'出生日期'</span><span class="token comment">/*省略as的属性更名*/</span><span class="token keyword">from</span> S<span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token string">'出生日期'</span><span class="token punctuation">(</span><span class="token operator">or</span> <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>关系更名：<ul><li>找出比s1学生选修c1课程成绩高的学生号</li></ul></li></ul><p>$$\prod_{S_2.Sno}(\sigma_{S_1.Sno &#x3D; s1 \wedge S_1.Cno &#x3D; c1 \wedge S_2.Cno &#x3D; c1 \wedge S_1.G &lt;S_2.G}(\rho_{S_1}(SC)\times \rho_{S_2}(SC)))$$</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> S2<span class="token punctuation">.</span>Sno<span class="token keyword">from</span> SC <span class="token keyword">as</span> S1<span class="token punctuation">,</span> SC <span class="token keyword">as</span> S2<span class="token keyword">where</span> S1<span class="token punctuation">.</span>Sno <span class="token operator">=</span> <span class="token string">'s1'</span> <span class="token operator">and</span> S1<span class="token punctuation">.</span>Cno <span class="token operator">=</span> <span class="token string">'c1'</span><span class="token operator">and</span> S2<span class="token punctuation">.</span>Cno <span class="token operator">=</span> <span class="token string">'c1'</span> <span class="token operator">and</span> S1<span class="token punctuation">.</span>G <span class="token operator">&lt;</span> S2<span class="token punctuation">.</span>G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="9-字符串操作"><a href="#9-字符串操作" class="headerlink" title="9.字符串操作"></a>9.字符串操作</h3><ul><li>格式：<ul><li>加上not 表示 not like (反向查找)</li><li>不加not 表示 like(查找，类似于模糊匹配)</li></ul></li></ul><blockquote><p>列名  [not] like ‘字符串’</p></blockquote><ul><li><p>匹配规则：</p><ul><li>‘%’：匹配零个或多个字符</li><li>‘_’：匹配任意单个字符</li><li>[]：任何在指定范围内的字符<ul><li>[a-f] or [abcdef]</li></ul></li><li>[^]：任何不在指定范围内的字符<ul><li>[^ a-f] or [ ^ abcdef]</li></ul></li></ul></li><li><p><strong>escape</strong></p><ul><li><p>定义转义字符，以去掉特殊字符的特定含义，使其被作为普通字符看待</p></li><li><p>如<code>escape &#39; \ &#39;</code>，定义 <code>\ </code>作为转义字符，则可用<code>\%</code>去匹配<code>%</code>，用<code>\＿</code>去匹配<code>＿</code></p><ul><li>例如， <code>where c1 like &#39;x%%xx&#39; escape &#39;x&#39;</code>，就是定义转义字符x，那么字符串’x%%xx’中，第一个x是转义字符，则它后面的第一个’%’就作为普通字符；第二个%是特殊字符，用于匹配字符；后两个xx，第一个是转义字符，用来去掉第二个x的特殊含义，所以’xx’表示一个普通字符’x’。所以最终，这句话的意思是，查找一个能匹配上’%…(x)…’的字符串，也就是<code>第一个字符是&#39;%&#39;，且%后有字符&#39;x&#39;的字符串</code></li></ul></li><li><p>示例：</p><ul><li>列出姓名以“张”打头的教师的所有信息</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span><span class="token keyword">from</span> Prof<span class="token keyword">where</span> Pname <span class="token operator">like</span> <span class="token string">'张%'</span><span class="token comment">/*意思是匹配张xx，xx可以没有字符，或任意多个字符*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>列出名称中含有3个以上字符，且倒数第三个是d，倒数第二个是_的课程<ul><li><code>&#39;%_d\__&#39;</code>中，%匹配任意多的字符，第一个<code>&#39;_&#39;</code>匹配任意1个字符，普通字符d匹配一个d，<code>&#39;\_&#39;</code>匹配一个普通字符<code>&#39;_&#39;</code>，最后一个<code>&#39;_&#39;</code>匹配任意1个字符，除’%’外共匹配4个字符，满足要求，多出的’%’又满足更多字符数的要求，OK!</li><li><strong><code>不要随便在匹配字符串中加空格，空格算普通字符，也是会被拿去匹配的！</code></strong></li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span><span class="token keyword">from</span> C<span class="token keyword">where</span> Cname <span class="token operator">like</span> <span class="token string">'%_d\__'</span> <span class="token keyword">escape</span> '\'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p><strong>全文索引？正则表达式？</strong></p><hr><h3 id="10-空值"><a href="#10-空值" class="headerlink" title="10.空值"></a>10.空值</h3><ul><li>空值测试(用于where)：<ul><li>测试指定列的值是否为空值</li></ul></li></ul><blockquote><p>is [not] null</p></blockquote><ul><li><p>注意事项：</p><ul><li>除<code>is [not] null</code>之外，空值不满足任何查找条件</li><li>如果null参与算术运算，则该算术表达式的值为null</li><li>如果null参与比较运算，则结果视为false</li><li><strong>定义上，任意值<em>不等于</em>null，包括null也不等于null</strong><ul><li>假设表中存在两行(1, 2, <strong>null</strong>), (1, 2, <strong>null</strong>)，<strong>select distinct</strong> * ?<ul><li>结果还是两个(1,2,null)!两个不重复，因为<strong>null≠null</strong>!!!</li></ul></li></ul></li></ul></li><li><p><strong>isnull</strong>:</p><ul><li>如果check_expression值为空null，则返回replacement_value</li><li>否则返回check_expression</li></ul></li></ul><blockquote><p>isnull(check_expression, replacement_value)</p></blockquote><ul><li><strong>coalesce</strong>:<ul><li>返回第一个不为null的expression</li></ul></li></ul><blockquote><p>coalesce(expression1, expression2, expression3,….);</p></blockquote><ul><li><strong>默认情况下空值NULL的值是最大的，所以由于缺省情况下升序排序，故NULL最后一个输出</strong></li></ul><hr><h3 id="11-统计"><a href="#11-统计" class="headerlink" title="11.统计"></a>11.统计</h3><ul><li><p>五个基本聚集函数(<code>目的：将一列中所有的值聚集成单个值</code>)</p><ul><li>COUNT——求行数</li><li>SUM——求和</li><li>AVG——求平均值</li><li>MIN——求最小值</li><li>MAX——求最大值</li></ul></li><li><p>COUNT, MAX, MIN 可对<strong>任一类型的字段</strong>, 而SUM and AVG 只对<strong>数值型字段</strong>.</p></li><li><p>SUM, AVG, MIN, MAX 要求<strong>查询结果只有一列</strong>.</p></li><li><p>先查询，再对查询结果进行统计.</p></li><li><p>除了 COUNT(* ) , 其它函数都<strong>忽略null值</strong>；<strong>count(列)也会忽略null</strong>；</p></li><li><p>统计结果是单一的值；从表概念来说，只一行数据</p></li><li><p><strong>Warning</strong>:</p></li><li><p>左右两段代码，左侧的where子句，因为where是逐行检测，所以grade永远等于grade</p></li><li><p>而右侧的通过嵌套查询，先找到了列最大值，再逐行比较，就能得到正确结果</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> S<span class="token comment">#                          select S#</span><span class="token keyword">from</span>SC                          <span class="token keyword">from</span> SC<span class="token keyword">where</span>GRADE <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span> GRADE <span class="token punctuation">)</span>        <span class="token keyword">where</span> GRADE <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>GRADE<span class="token punctuation">)</span>                                                   <span class="token keyword">from</span> SC<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="12-分组统计"><a href="#12-分组统计" class="headerlink" title="12.分组统计"></a>12.分组统计</h3><p><em>先对*<em>查询结果</em></em>，选定某一字段或者某些字段（叫<strong>分组字段</strong>）进行<strong>分组</strong>：对<strong>查询结果</strong>的<strong>行，将分组字段</strong>的<strong>值相同的行</strong>放在一起构成<strong>一个组。于是，可能会形成多个组。<strong>再对每个</strong>组</strong>分别进行统计.*</p><ul><li>分组命令：<ul><li>group by将表中的元组先按指定列上值相等的原则分组，然后在每一分组上使用聚集函数，得到单一值</li><li>having则对分组进行额外选择，只将聚集函数作用到满足条件的分组上，也就是对计算聚合函数后的结果进行组级别的过滤，只保留符合过滤条件的组<ul><li>HAVING子句中可以是列，也可以是聚集函数</li></ul></li><li>Having的筛查按分组， 而Where的筛查按行</li><li><strong>group by的对象不一定是select子句中的列</strong></li><li><strong>当在 GROUP BY 子句中指定了两个列名时，查询将按照这两个列名的组合进行分组。具体来说，查询将按照每个不同的列名组合创建一个独立的组。</strong></li></ul></li></ul><blockquote><p>group by 列名 [having 条件表达式]</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> s<span class="token comment"># </span><span class="token keyword">from</span> sc <span class="token keyword">group</span> <span class="token keyword">by</span> s<span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>以上查询过程起到了对s#去重的效果</p></li><li><p>理解：按照s#(学号)给表sc(学生选课表)分组，每个学生及其所有选课数据就是一组，一组中可能有多个元组，也就是一个学生有多个选课数据；再由select来查询s#学号，就是在每组中查找学号，又因为每组的学号相同，所以查询1组只会得到1个学号，而这实质上达到了去重的目的</p></li><li><p><strong><code>分组统计执行顺序</code></strong></p><ul><li>先执行查询， <strong>WHERE</strong> 语句</li><li>然后执行分组， <strong>GROUP BY</strong> 语句</li><li>执行统计，<strong>聚集函数</strong></li><li>再执行筛选， <strong>HAVING</strong>进行过滤</li><li>最后执行排序，<strong>ORDER BY</strong>  对结果排序</li></ul></li></ul><hr><h3 id="13-in子查询"><a href="#13-in子查询" class="headerlink" title="13.in子查询"></a>13.in子查询</h3><ul><li>格式：</li></ul><blockquote><p>表达式 [not] in (子查询)</p></blockquote><ul><li>作用：判断表达式的值是否在子查询的结果中</li><li><strong>in子查询</strong>比用<strong>笛卡尔积</strong>去查找要更加高效</li><li>示例：列出张军和王红同学的所有信息</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span><span class="token keyword">from</span> S<span class="token keyword">where</span> Sname <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'张军'</span><span class="token punctuation">,</span><span class="token string">'王红'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>示例2：列出选修了c1和c2号课程的学生的学号<ul><li>在不知道in子查询时，唯一的办法就是$\prod_{S_1.Sno}(\sigma_{S_1.Sno &#x3D; S_2.Sno \wedge S_1.Cno &#x3D; ‘c1’ \wedge S_2.Cno &#x3D; ‘c2’}(\rho_{S_1}(SC)\times \rho_{S_2}(SC))$</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> Sno<span class="token keyword">from</span> SC<span class="token keyword">where</span> SC<span class="token punctuation">.</span>C<span class="token comment"># = c1</span><span class="token operator">and</span> Sno <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> Sno               <span class="token keyword">from</span> SC               <span class="token keyword">where</span> SC<span class="token punctuation">.</span>C<span class="token comment"># = c2)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="14-some-all子查询"><a href="#14-some-all子查询" class="headerlink" title="14.some&#x2F;all子查询"></a>14.some&#x2F;all子查询</h3><ul><li><blockquote><p>表达式  (比较运算符)$\theta$  <strong>some</strong> (子查询)</p></blockquote><ul><li>表达式的值至少与子查询结果中的一个值相比满足比较运算符$\theta$</li></ul></li><li><blockquote><p>表达式  (比较运算符)$\theta$  <strong>all</strong> (子查询)</p></blockquote><ul><li>表达式的值与子查询结果中的所有的值相比都满足比较运算符$\theta$</li></ul></li><li><p>示例：找出平均成绩最高的学生号</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> S<span class="token comment">#</span><span class="token keyword">from</span> SC<span class="token keyword">group</span> <span class="token keyword">by</span> S<span class="token comment">#</span><span class="token keyword">having</span> <span class="token function">avg</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token keyword">all</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">avg</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>                        <span class="token keyword">from</span> SC                        <span class="token keyword">group</span> <span class="token keyword">by</span> S<span class="token comment"># )</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="15-exists子查询"><a href="#15-exists子查询" class="headerlink" title="15.exists子查询"></a>15.exists子查询</h3><ul><li>exists子查询的作用：判断子查询的结果集合中是否有任何元组存在</li></ul><blockquote><p>exists子查询：[not] exists</p></blockquote><ul><li>in后的子查询与外层查询无关，每个子查询执行一次，而exists后的子查询与外层查询有关，需要执行多次，称之为相关子查询<ul><li><strong>独立子查询（in后的子查询）</strong>：独立子查询是在外层查询执行之前独立地执行，并且其结果集不受外层查询影响。每次外层查询执行时，独立子查询都会重新执行一次。独立子查询的执行次数与外层查询的行数无关。这意味着无论外层查询返回多少行，独立子查询都会执行相同的次数。</li><li><strong>相关子查询（exists后的子查询）</strong>：相关子查询与外层查询是相关联的，内部查询的结果依赖于外部查询的行。每次外层查询执行时，相关子查询都会执行一次，并且对于外层查询的每一行，相关子查询都会执行一次。这意味着相关子查询的执行次数取决于外层查询返回的行数，对于每一行外层查询，相关子查询都会被执行一次。</li><li><strong>也就是说，exists子查询中，where子句必须调用主查询的表的属性!</strong></li></ul></li><li>示例：列出选修了c1和c2号课程的学生的学号</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> Sno<span class="token keyword">from</span> SC SC1<span class="token keyword">where</span> SC1<span class="token punctuation">.</span>Cno <span class="token operator">=</span> c1<span class="token operator">and</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> Sno     <span class="token keyword">from</span> SC     <span class="token keyword">where</span> Cno <span class="token operator">=</span> c2    <span class="token operator">and</span> Sno <span class="token operator">=</span> SC1<span class="token punctuation">.</span>Sno<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="16-uniqe子查询"><a href="#16-uniqe子查询" class="headerlink" title="16.uniqe子查询"></a>16.uniqe子查询</h3><ul><li><blockquote><p>测试集合是否存在重复元组：<code>[not] unique(子查询)</code></p></blockquote><ul><li>如果子查询结果中没有重复元组，则返回true</li></ul></li><li><p>示例：找出所有只教授一门课程的老师姓名</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> Tname<span class="token keyword">from</span> Teacher<span class="token keyword">where</span> <span class="token keyword">unique</span><span class="token punctuation">(</span><span class="token keyword">select</span> Cno         <span class="token keyword">from</span> TeacherCourse         <span class="token keyword">where</span> Teacher<span class="token punctuation">.</span>Tno <span class="token operator">=</span> TeacherCourse<span class="token punctuation">.</span>Tno<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>找出至少教两门的：<code>not unique</code></li></ul><hr><h3 id="17-派生关系"><a href="#17-派生关系" class="headerlink" title="17.派生关系"></a>17.派生关系</h3><ul><li>命令：</li></ul><blockquote><p>派生关系：(子查询)  <strong>as</strong> 关系名(列名，列名，……)</p></blockquote><ul><li>允许在from子句中使用子查询表达式，这时可将该子查询的结果命名为一个**<code>临时关系</code>**加以引用</li><li>示例：找出平均成绩及格的学生(先求每个学生的平均成绩，再从中找出及格的学生)</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> Sname<span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> Sname<span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span>Score<span class="token punctuation">)</span>  <span class="token keyword">from</span> SC    <span class="token keyword">group</span> <span class="token keyword">by</span> Sno<span class="token punctuation">)</span> <span class="token keyword">as</span> Result<span class="token punctuation">(</span>Sname<span class="token punctuation">,</span> avgscore<span class="token punctuation">)</span><span class="token keyword">where</span> avgscore <span class="token operator">>=</span> <span class="token number">60</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="18-集合操作"><a href="#18-集合操作" class="headerlink" title="18.集合操作"></a>18.集合操作</h3><ul><li>命令：</li></ul><blockquote><p>集合并：<strong>union(all)</strong></p><p>集合交：<strong>intersect(all)</strong></p><p>集合差：<strong>except(all)</strong></p></blockquote><ul><li><p><strong>集合操作 缺省时去除重复元组</strong></p></li><li><p><strong>intersect的优先级高于其他集合操作的优先级</strong></p></li><li><p><strong>union和union all在一起是不满足结合律，因为union去重，而union all不去重</strong></p></li></ul><hr><h3 id="19-插入操作"><a href="#19-插入操作" class="headerlink" title="19.插入操作"></a>19.插入操作</h3><ul><li>命令：</li></ul><blockquote><p>插入一条指定好的值的元组：<strong>insert into 表名(列名，列名，…)</strong></p><p>​       <strong>values (值，值，…)</strong></p><p>插入子查询结果中的若干条元组： <strong>insert into 表名(列名，列名，…)</strong></p><p>​       <strong>(子查询)</strong></p></blockquote><ul><li>insert指令最好写全列名，防止出错</li><li>防止插入带有空值的元组：在创建表时为某列添加了<code>NOT NULL</code>约束后，插入操作在该列中插入空值的尝试将会失败</li></ul><hr><h3 id="20-更新操作"><a href="#20-更新操作" class="headerlink" title="20.更新操作"></a>20.更新操作</h3><ul><li>命令：</li></ul><blockquote><p>指定对哪些列进行更新，以及更新后的值是什么：</p><p><strong>update</strong> 表名</p><p><strong>set</strong> 列名1 &#x3D; 表达式 or 子查询，列名2 &#x3D; 表达式 or 子查询，……</p><p><strong>where</strong> 条件表达式</p></blockquote><ul><li>示例：将D01系系主任的工资改为该系的平均工资</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> TeacherSAL<span class="token keyword">set</span> SAL <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">avg</span><span class="token punctuation">(</span>SAL<span class="token punctuation">)</span>           <span class="token keyword">from</span> TeacherSAL           <span class="token keyword">where</span> TeacherSAL<span class="token punctuation">.</span>Dno <span class="token operator">=</span> <span class="token string">'D01'</span><span class="token punctuation">)</span><span class="token keyword">where</span> Tno <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> Tno             <span class="token keyword">from</span> Department             <span class="token keyword">where</span> Department<span class="token punctuation">.</span>Dno <span class="token operator">=</span> <span class="token string">'D01'</span><span class="token punctuation">)</span><span class="token comment">/*从系表中找到D01系的元组，得到系主任编号*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="21-删除操作"><a href="#21-删除操作" class="headerlink" title="21.删除操作"></a>21.删除操作</h3><ul><li>命令：</li></ul><blockquote><p>从表中删除符合条件的元组，如果没有where语句，则删除所有元组:</p><p><strong>delete from</strong> 表名</p><p><strong>where</strong> 条件表达式</p></blockquote><ul><li>示例：删除王明老师的所有任课记录</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">delete</span> <span class="token keyword">from</span> TCrecord<span class="token keyword">where</span> Tno <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> Tno             <span class="token keyword">from</span> Teacher             <span class="token keyword">where</span> Tname <span class="token operator">=</span> <span class="token string">'王明'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>truncate table</strong><ul><li>删除表中的所有行，而不记录单个行删除操作</li><li><strong>truncate table</strong>在功能上与不带where子句的 delete语句相同。但truncate table比delete 速度快，且使用的系统和事务日志资源少</li></ul></li></ul><hr><h2 id="三、数据库定义功能"><a href="#三、数据库定义功能" class="headerlink" title="三、数据库定义功能"></a>三、数据库定义功能</h2><h3 id="1-SQL概述-操作符"><a href="#1-SQL概述-操作符" class="headerlink" title="1.SQL概述(操作符)"></a>1.SQL概述(操作符)</h3><table><thead><tr><th>SQL功能</th><th>操作符</th></tr></thead><tbody><tr><td>数据查询(DQL语言)</td><td>SELECT</td></tr><tr><td>数据定义(DDL语言)</td><td>CREATE,ALTER,DROP</td></tr><tr><td>数据操作(DML语言)</td><td>INSERT,UPDATE,DELETE</td></tr><tr><td>数据控制(DCL语言)</td><td>GRANT,REVOKE</td></tr></tbody></table><hr><h3 id="2-域定义"><a href="#2-域定义" class="headerlink" title="2.域定义"></a>2.域定义</h3><ul><li><p>char（n）：固定长度的字符串</p></li><li><p>varchar（n）：可变长字符串</p><ul><li>n也是要写的，表示可变长字符串最大多长</li></ul></li><li><p>int：整数</p></li><li><p>smallint：小整数类型</p></li><li><p>numeric（p，d）：定点数，小数点左边p位，右边q位</p></li><li><p>real：浮点数</p></li><li><p>double precision：双精度浮点数</p></li><li><p>date：日期（年、月、日）</p><ul><li>如果定义了列类型为date，那么插入元组时，不需要显式声明，即不需要DATE’2003-11-22’，只需要符合日期格式的字符串’2003-11-22’即可，数据库系统会自动将这个字符串转换成日期类型</li></ul></li><li><p>time：时间（小时、分、秒）</p></li><li><p>interval：两个date或time类型数据之间的差</p></li></ul><hr><h3 id="3-基本表的定义"><a href="#3-基本表的定义" class="headerlink" title="3.基本表的定义"></a>3.基本表的定义</h3><ul><li>创建基本表定义</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> 表名<span class="token punctuation">(</span>    列名 数据类型<span class="token punctuation">[</span>defalut 缺省值<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">unique</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">,</span>列名 数据类型<span class="token punctuation">[</span>defalut 缺省值<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">unique</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>列名<span class="token punctuation">[</span><span class="token punctuation">,</span>列名<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token keyword">foreign</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>列名<span class="token punctuation">[</span><span class="token punctuation">,</span>列名<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">references</span> 表名 <span class="token punctuation">(</span>列名<span class="token punctuation">[</span><span class="token punctuation">,</span>列名<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token keyword">check</span> <span class="token punctuation">(</span>条件<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改基本表定义<ul><li>更改、添加、去除列和约束</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> 表名<span class="token punctuation">[</span><span class="token keyword">add</span> 子句<span class="token punctuation">]</span> 增加新列和约束<span class="token punctuation">[</span><span class="token keyword">drop</span> 子句<span class="token punctuation">]</span> 删除列和约束<span class="token punctuation">[</span><span class="token keyword">modify</span> 子句<span class="token punctuation">]</span> 修改列定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>撤销基本表定义<ul><li>删除表定义及该表的所有数据、索引、触发器、约束和权限规范</li><li>任何引用已除去表的视图或存储过程必须通过 drop view或drop procedure语句<strong>显式</strong>除去</li><li>**drop table不能用于除去由foreign key约束引用的表。必须先除去引用的foreign key约束或引用的表 **</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">table</span> 表名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="4-临时表的定义"><a href="#4-临时表的定义" class="headerlink" title="4.临时表的定义"></a>4.临时表的定义</h3><ul><li><p>草稿簿，试验中间的数据处理</p></li><li><p>只记录回滚信息，不记录重做信息</p></li><li><p>临时表上的数据更新比其他表快4倍</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token comment">#my_table /*私有临时表*/</span><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token comment">##my_table /*全局临时表*/</span><span class="token keyword">create</span> <span class="token keyword">table</span> my_table <span class="token comment">/*tempdb*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>在数据库中，tempdb是一个特殊的系统数据库，用于存储临时对象和临时数据。</p></li><li><p><strong>存储临时表格数据</strong>：当用户在数据库中创建临时表格时，临时表格的数据会存储在tempdb中。这些临时表格通常用于存储中间结果、临时数据等。</p></li><li><p><strong>处理排序和哈希操作</strong>：在执行查询时，数据库可能需要进行排序和哈希操作来处理数据。这些操作可能会涉及到临时存储，而tempdb提供了这样的功能。</p></li><li><p><strong>存储临时对象</strong>：除了临时表格数据外，tempdb还用于存储其他类型的临时对象，如表格变量、临时存储过程等。</p></li><li><p>tempdb是所有用户和系统都共享的</p></li></ul><hr><h3 id="5-数据库特征"><a href="#5-数据库特征" class="headerlink" title="5.数据库特征"></a>5.数据库特征</h3><ul><li>数据库中的表有三性：<strong>专一性、全局性、联系性</strong></li><li>用户业务数据表也有三性：<strong>局部性、综合性、多样性</strong></li></ul><hr><h3 id="6-数据模型"><a href="#6-数据模型" class="headerlink" title="6.数据模型"></a>6.数据模型</h3><p>数据模型，是数据库系统中用于提供<strong>信息表示</strong>和<strong>操作手段</strong>的形式构架</p><p>数据模型包括<strong>概念数据模型</strong>和<strong>结构数据模型</strong>，他们分别代表着从<strong>用户</strong>和<strong>计算机</strong>的角度对数据和信息的建模</p><ul><li><p>概念数据模型</p><ul><li>按照用户的观点来对数据和信息建模</li><li>用户与数据库设计人员之间的交流语言</li><li>例见：E-R模型，ODL模型</li></ul></li><li><p>结构数据模型</p><ul><li>从计算机实现的观点对数据建模</li><li>有严格的形式化定义，以便于在计算机上实现</li><li>例见：层次模型、网状模型、关系模型、面向对象模型</li><li><strong>结构数据模型</strong>三要素：<ul><li>数据结构：数据+数据间联系(例如关系模型中的外键)</li><li>数据操作</li><li>数据的约束条件</li></ul></li><li><strong>关系模型</strong><ul><li>用二维表来表示实体及其相互联系</li><li>优点：简单、直观；数据独立性</li><li>缺点：效率低(引申：NoSQL)</li></ul></li></ul></li></ul><hr><h3 id="7-数据库模式"><a href="#7-数据库模式" class="headerlink" title="7.数据库模式"></a>7.数据库模式</h3><h4 id="1-元数据"><a href="#1-元数据" class="headerlink" title="1.元数据"></a>1.元数据</h4><p><strong>元数据</strong>(meta-data)</p><ul><li>描述数据的数据</li><li>描述数据的含义和性质</li><li>示例：<ul><li>数据：图书馆的书籍</li><li>元数据：标题，作者，关键词，ISBN号</li></ul></li></ul><h4 id="2-模式"><a href="#2-模式" class="headerlink" title="2.模式"></a>2.模式</h4><p>数据的抽象，数据的描述</p><h4 id="3-数据字典"><a href="#3-数据字典" class="headerlink" title="3.数据字典"></a>3.数据字典</h4><p>系统目录：存取和管理数据的依据</p><p><em><strong>*关于数据库中数据的描述，是元数据而非数据本身；*</strong></em></p><p><strong>包括：数据项，数据流，数据结构，数据存储，处理过程</strong></p><p>在数据字典中存储的都是相应的元数据</p><p>例如：视图建立后，在数据字典中存放的是视图的定义，也就是视图的元数据</p><h4 id="4-实例与模式"><a href="#4-实例与模式" class="headerlink" title="4.实例与模式"></a>4.实例与模式</h4><p><strong>型是相对稳定的，值是随时间不断变化的</strong></p><h4 id="5-模式的分级"><a href="#5-模式的分级" class="headerlink" title="5.模式的分级"></a>5.模式的分级</h4><p>为提高数据的<strong>物理独立性</strong>和<strong>逻辑独立性</strong>，将用户看到的数据库和实际存储的数据库区分开——<code>数据库系统三级模式结构</code></p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240326084804608.png" alt="三级模式"></p><ul><li><p>外模式：</p><ul><li>用户的数据视图</li><li>是数据的局部逻辑结构，模式的子集</li><li>业务表，各种类别数据的综合</li></ul></li><li><p>模式(概念模式)：</p><ul><li>所有用户的公共数据视图</li><li>是数据库中全体数据的全局逻辑结构和特性的描述</li><li>数据的正确性要求，数据必须严格按类分表存储</li></ul></li><li><p>内模式：</p><ul><li>又称存储模式</li><li>是数据的物理结构及存储方式</li></ul></li><li><p>外模式&#x2F;模式映象</p><ul><li>定义某一个外模式和模式之间的对应关系，映象定义通常包含在各外模式中</li><li>当模式改变时，修改外模式&#x2F;模式映象，使外模式保持不变，从而应用程序可以保持不变，称为数据的逻辑独立性</li><li>包括视图、存储过程</li></ul></li><li><p>模式&#x2F;内模式映象</p><ul><li>定义数据逻辑结构与存储结构之间的对应关系</li><li>存储结构改变时，修改模式&#x2F;内模式映象，使模式保持不变，从而应用程序可以保持不变，称为数据的物理独立性</li></ul></li></ul><hr><h3 id="8-视图"><a href="#8-视图" class="headerlink" title="8.视图"></a>8.视图</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li><p>视图是一个虚拟表，定义在一个查询上，因此视图对应的虚拟表的行的集合就是该查询的结果集</p></li><li><p>视图定义：</p><ul><li><code>create view 视图名(列名1，列名2，xxx) as select ...</code></li><li>当用户需要读取视图对应的结果集时，系统会临时执行视图对应的查询，生成临时表供使用，临时表在执行完后不再存在，视图保持为虚拟表</li><li>sql的语句中，子查询容易大幅增加查询语句的复杂度，因此视图有利于简化用户的查询，也能对用户屏蔽底层细节，并且视图并不实际存储数据，空间开销忽略不计</li><li>实际上，有时也存在物化视图，即实际生成一个持久化的针对视图的数据表，以提升频繁访问视图的操作的效率</li></ul></li><li><p>提出视图概念的动机——放低用户操作数据库的门槛，实现数据操作的简单性</p></li></ul><h4 id="2-创建视图"><a href="#2-创建视图" class="headerlink" title="2.创建视图"></a>2.创建视图</h4><ul><li>创建视图</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> view_name<span class="token punctuation">(</span>列名<span class="token punctuation">,</span>列名<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">-- 视图是否需要显式注明列名？根据个人需要，可以不加，加上了方便观看意思</span><span class="token keyword">AS</span><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>用户查询</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> view_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-相关思考"><a href="#3-相关思考" class="headerlink" title="3.相关思考"></a>3.相关思考</h4><ul><li><strong>对于用户层来说，视图就是表，根本就没有视图概念；</strong></li><li><strong>视图里的数据就是用户的业务数据，恰好，不多不少；</strong></li><li><strong>视图里的SQL语句，在用户查询时实时执行；</strong></li><li><strong>既然视图对用户而言是表，那么用户可能会对其进行INSERT，UPDATE，DELETE操作，如何处理？</strong></li><li><strong>是否可以基于视图，再创建视图？</strong></li><li><strong>数据库中自然会有很多视图；</strong></li></ul><h4 id="4-视图更新"><a href="#4-视图更新" class="headerlink" title="4.视图更新"></a>4.视图更新</h4><ul><li><code>with check option</code><ul><li><code>with check option</code>指明当对视图进行insert，update时，要检查是否满足视图定义的条件</li></ul></li></ul><p>e.g. </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> SC_V <span class="token keyword">AS</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> GRADE <span class="token operator">></span> <span class="token number">85</span><span class="token punctuation">)</span><span class="token keyword">WITH</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> SC_V <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'s2'</span><span class="token punctuation">,</span><span class="token string">'c4'</span><span class="token punctuation">,</span><span class="token number">82</span><span class="token punctuation">)</span>检查 GRADE 是否大于<span class="token number">85</span>，<span class="token number">82</span><span class="token operator">&lt;</span><span class="token number">85</span>，故拒绝插入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>视图更新反例</p><ul><li>插入数据少于表字段，未赋值(缺失)字段会用缺省值或NULL填补<ul><li>如主键缺失，违反完整性约束，插入失败</li></ul></li><li>对聚集值(5大函数)的更新不能回逆到元组</li><li>SELECT中将两表联接($\Join$)，但是视图中不包含联接属性时，对视图的插入无效(联接属性为NULL，无法联接)</li></ul></li><li><p>视图更新约束</p><ul><li>SELECT子句中的目标列不能包含聚集函数</li><li>SELECT子句中不能使用unique或distinct</li><li>不能包括group by子句</li><li>不能包括经算术表达式计算出来的列</li><li>对于行列子集视图一般可以更新(即，视图是从单个基本表使用选择、投影操作导出，并包含基本表的主键)</li></ul></li></ul><h4 id="5-物化视图"><a href="#5-物化视图" class="headerlink" title="5.物化视图"></a>5.物化视图</h4><ul><li>视图的计算结果被实际存储</li><li>物化视图可以看作数据库的cache(缓存)</li><li>查询物化视图比重新计算视图快得多</li><li>需要进行物化视图与基本表之间的一致性维护(视图则不需要)</li></ul><h4 id="6-是否允许用户在视图上做更新操作"><a href="#6-是否允许用户在视图上做更新操作" class="headerlink" title="6.是否允许用户在视图上做更新操作"></a>6.是否允许用户在视图上做更新操作</h4><ul><li><p>视图里的SELECT语句只对单个表;</p></li><li><p>输出字段包含主键，</p></li><li><p>无 DISTINCT，无计算字段；</p></li><li><p>所有非空字段都是输出字段；</p></li><li><p>要求更新后的行，会出现在视图中，即满足WHERE后的条件；</p></li><li><p>要求更新不违背数据完整性约束:</p></li></ul><h4 id="7-视图的好处与问题"><a href="#7-视图的好处与问题" class="headerlink" title="7.视图的好处与问题"></a>7.视图的好处与问题</h4><p>好处：</p><ul><li><p>逻辑独立性：<strong>实现了应用程序与数据库的比彼此独立，通用性增强，应用程序只见视图，不见表。</strong></p></li><li><p>增强安全(Security)：需要的字段才会被访问</p></li></ul><p>问题：</p><ul><li>没有灵活应变性</li></ul><hr><h3 id="9-存储过程"><a href="#9-存储过程" class="headerlink" title="9.存储过程"></a>9.存储过程</h3><h4 id="1-创建存储过程"><a href="#1-创建存储过程" class="headerlink" title="1.创建存储过程"></a>1.创建存储过程</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> procedure_name<span class="token punctuation">(</span><span class="token variable">@variable1</span> <span class="token operator">IN</span> <span class="token keyword">type</span><span class="token punctuation">,</span> @ courseV <span class="token operator">IN</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">)</span><span class="token keyword">AS</span><span class="token keyword">BEGIN</span><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">INSERT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token keyword">end</span>之间的内容可以不止一个查询，包括多个语句组成的一系列操作<span class="token punctuation">)</span><span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用户使用</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CALL</span> procedure_name<span class="token punctuation">(</span><span class="token string">'2014/01'</span><span class="token punctuation">,</span><span class="token string">'sfjhaoi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-好处"><a href="#2-好处" class="headerlink" title="2.好处"></a>2.好处</h4><ul><li><strong>提升视图的适应性，使其通用化</strong></li><li><strong>应用程序或者用户见到的是存储过程，视图，而不是表；</strong></li><li><strong>用户不用学SQL语言了；</strong></li><li><strong>因为带变量，有很强的适应性，通用性；</strong></li><li><strong>能够将业务规则约束，放在存储过程中加以实现；</strong></li><li><strong>还有函数，可以带上返回值；</strong></li></ul><h4 id="3-视图与存储过程的差异与联系"><a href="#3-视图与存储过程的差异与联系" class="headerlink" title="3.视图与存储过程的差异与联系"></a>3.视图与存储过程的差异与联系</h4><ul><li><p><strong>在用户看来，视图是一个表，存储过程是一个具备特定功能的函数；</strong></p></li><li><p><strong>视图既然是一个表，用户就可在其上进行五大数据操作；对存储过程，则不具备这种特性；</strong></p></li><li><p><strong>存储过程尽管它的功能固定，但是带有变量，因此具有适配性，能够满足不同参数下的同一功能要求；</strong></p></li></ul><hr><h3 id="10-索引"><a href="#10-索引" class="headerlink" title="10.索引"></a>10.索引</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。</li><li>主键默认建立索引</li><li>通过索引查询的算法：二分查找</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240410162525642.png" alt="索引表"></p><ul><li>索引码：索引列的数据值，索引就是根据这些值来组织的(当然，也会对这些值做一些处理和排序)<ul><li>因此，这里的索引码是B列值升序排列</li><li>但如果列的数据值过于复杂，为了保证索引数据结构的简洁，会对值做处理(例如压缩)，可能就不是原值了</li></ul></li><li>指针：指向表中标识这些值的数据页的地址</li></ul><blockquote><p>假设B列中有多个3，索引应该如何处理？</p><p>1.聚集；2.指针存所有的3；3.指针存第一个‘3’，再做所有‘3’的链表</p></blockquote><h4 id="2-创建索引"><a href="#2-创建索引" class="headerlink" title="2.创建索引"></a>2.创建索引</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token punctuation">[</span><span class="token keyword">unique</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span> <span class="token keyword">index</span> 索引名<span class="token keyword">on</span> 表名<span class="token punctuation">(</span>列名<span class="token punctuation">[</span><span class="token keyword">asc</span><span class="token operator">/</span><span class="token keyword">desc</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">,</span>列名 <span class="token keyword">asc</span><span class="token operator">/</span><span class="token keyword">desc</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">-- 注意，这里的列名是需要做索引的列的名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>unique：唯一性索引，不允许表中不同的行在索引列上取相同值。若已有相同值存在，则系统给出相关信息，不建此索引。<strong>系统拒绝违背唯一性的插入、更新</strong></li><li>cluster：聚簇索引，表中元组按索引项的值排序并物理地聚簇在一起（索引码到指针的则是非物理聚簇）。<strong>一个基本表上只能建一个聚簇索引</strong>。通俗的说，cluster是直接改变原表中元组的先后顺序，而且不会另外产生一个数据结构；其他索引则不会改变原表</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240410164001100.png" alt="image-20240410164001100"></p><ul><li>asc&#x2F;desc：索引表中索引值的排序次序，缺省为asc(升序)<ul><li>为什么需要降序索引？——业务需要，身高从高到矮，降序索引的效率高于升序</li></ul></li></ul><p><strong>WARNING:create table时指定的primary key或者unique列，均会触发系统自动创建相应的索引用作重复性检查</strong></p><h4 id="3-作用"><a href="#3-作用" class="headerlink" title="3.作用"></a>3.作用</h4><ul><li>索引的作用<ul><li>查找元组</li><li>表连接</li><li>排序</li><li>分组</li><li>保证唯一性</li></ul></li><li>索引对约束的支持<ul><li>通过创建唯一性索引(unique)来支持主码约束和唯一性约束</li></ul></li><li>副作用<ul><li>表的元组很少时，二分查找的效率反而不如顺序查找</li><li>更新效率低，需要对索引表进行更新</li></ul></li></ul><h4 id="4-组合索引"><a href="#4-组合索引" class="headerlink" title="4.组合索引"></a>4.组合索引</h4><ul><li>建立在多个属性列上的索引</li><li>如果组合索引建立在A,B,C上，那它只对检索A,A+B,A+B+C列的查询起作用</li><li>如果是A,B列的组合索引，且先按A排序，再按B排序，此时检索对B不会二分，因为先A后B，则B局部有序</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240410165102693.png" alt="image-20240410165102693"></p><h4 id="5-删除索引"><a href="#5-删除索引" class="headerlink" title="5.删除索引"></a>5.删除索引</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">index</span> 索引名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>drop index语句不适用于通过定义primary key或unique约束时系统自动创建的索引，<strong>它们必须通过删除约束来撤销</strong><ul><li>所以，索引是不可视的</li></ul></li></ul><h4 id="6-相关说明"><a href="#6-相关说明" class="headerlink" title="6.相关说明"></a>6.相关说明</h4><ul><li><p>可以动态地定义索引，即可以随时建立和删除索引</p></li><li><p>不允许用户在数据操作中引用索引。索引如何使用完全由系统决定，这支持了数据的物理独立性</p></li><li><p>应该在使用频率高的、经常用于连接的列上建索引</p></li><li><p>一个表上可建多个索引。索引可以提高查询效率，但索引过多耗费空间，且降低了插入、删除、更新的效率</p></li></ul><hr><h3 id="11-约束"><a href="#11-约束" class="headerlink" title="11.约束"></a>11.约束</h3><h4 id="1-数据完整性问题"><a href="#1-数据完整性问题" class="headerlink" title="1.数据完整性问题"></a>1.数据完整性问题</h4><p>数据完整性的四大保障措施：</p><ul><li>主键约束</li><li>外键约束</li><li>域约束</li><li>业务规则约束</li></ul><h4 id="2-约束类型"><a href="#2-约束类型" class="headerlink" title="2.约束类型"></a>2.约束类型</h4><ul><li>primary key</li><li>unique</li><li>foreign key</li><li>check</li><li>default</li></ul><h4 id="3-primay-key与unique"><a href="#3-primay-key与unique" class="headerlink" title="3.primay key与unique"></a>3.primay key与unique</h4><ul><li>PK和unique都是通过唯一性索引来支持</li><li>两者的区别：<ul><li>PK:唯一性+尽量不改</li><li>unique:唯一性，但可频繁改</li></ul></li><li>一个带有唯一性声明的属性，可以有多少个NULL元素？——无限个，NULL≠NULL</li><li>多列的组合unique——unique(col2, col3)</li></ul><h4 id="4-foreign-key"><a href="#4-foreign-key" class="headerlink" title="4.foreign key"></a>4.foreign key</h4><ul><li><p>作为主码的关系称为基本关系，作为外码的关系称为依赖关系</p></li><li><p>删除基本关系元组</p><ul><li><p><code>RESTRICT</code></p><p>只有当依赖关系中没有一个外码值与要删除的基本关系的主码值相对应时，才可以删除该元组，否则系统拒绝此删除操作</p></li><li><p><code>CASCADE</code></p><p>将依赖关系中所有外码值与基本关系中要删除的主码值所对应的元组一起删除</p></li><li><p><code>SET NULL</code></p><p>删除基本关系中元组时，将依赖关系中与基本关系中被删主码值相对应的外码值置为空值</p></li><li><p>例：同步删除</p></li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>sno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> student<span class="token punctuation">(</span>sno<span class="token punctuation">)</span> <span class="token keyword">ON</span> <span class="token keyword">DELETE</span> <span class="token keyword">CASCADE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>修改基本关系主码</p><ul><li><p><code>RESTRICT</code></p><p>只有当依赖关系中没有一个外码值与要修改的基本关系的主码值相对应时，才可以修改该元组主码，否则系统拒绝此次修改</p></li><li><p><code>CASCADE</code></p><p>将依赖关系中所有与基本关系中要修改的主码值所对应的外码值一起修改为新值</p></li><li><p><code>SET NULL</code></p><p>修改基本关系中元组主码时，将依赖关系中与基本关系中被修改主码值相对应的外码值置为空值</p></li><li><p>例：同步修改</p></li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>sno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> student<span class="token punctuation">(</span>sno<span class="token punctuation">)</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CASCADE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-check"><a href="#5-check" class="headerlink" title="5.check"></a>5.check</h4><p><strong>check,又称为全局约束</strong></p><ul><li>全局约束涉及多个属性间的或多个关系间的关系</li><li>例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> SC<span class="token punctuation">(</span>S<span class="token comment"># CHAR(4),</span>     C<span class="token comment"># CHAR(4),</span>     GRADE <span class="token keyword">SMALLINT</span>     <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>S<span class="token comment">#, C#),</span>     <span class="token keyword">CHECK</span><span class="token punctuation">(</span>S<span class="token comment"># in (SELECT S# FROM S)),</span>     <span class="token keyword">CHECK</span><span class="token punctuation">(</span>C<span class="token comment"># in (SELECT C# FROM C)))</span><span class="token comment">-- 如果S中删除元组，不会触发CHECK子句；只有对SC表的更新会触发</span><span class="token comment">-- 这里的更新是指：插入、删除、更新！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-SQL语句"><a href="#6-SQL语句" class="headerlink" title="6.SQL语句"></a>6.SQL语句</h4><ul><li>命名约束</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">constraint</span> 约束名 <span class="token operator">&lt;</span>约束条件<span class="token operator">></span>例：Sno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">constraint</span> S_PK <span class="token keyword">primary</span> <span class="token keyword">key</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>关系上约束的撤销</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> table_name <span class="token keyword">drop</span> <span class="token keyword">constraint</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>e<span class="token punctuation">.</span>g<span class="token punctuation">.</span><span class="token keyword">alter</span> <span class="token keyword">table</span> S <span class="token keyword">drop</span> <span class="token keyword">constraint</span> S_PK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>关系上约束的添加</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> table_name <span class="token keyword">add</span> <span class="token keyword">constraint</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>e<span class="token punctuation">.</span>g<span class="token punctuation">.</span><span class="token keyword">alter</span> <span class="token keyword">table</span> SC <span class="token keyword">add</span> <span class="token keyword">constraint</span> SC_CHECK <span class="token keyword">check</span><span class="token punctuation">(</span>S<span class="token comment"># in select S# from S)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h3 id="12-触发器"><a href="#12-触发器" class="headerlink" title="12.触发器"></a>12.触发器</h3><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li><p><strong>表模式（Schema）的定义中，包含了主键，外键，域约束的定义；</strong></p></li><li><p><strong>业务规则约束用触发器（Trigger）来定义;</strong></p></li><li><p><strong>所有完整性约束在DBMS内部最终都用触发器来表示；</strong></p></li><li><p><strong>操作会先触发约束检查和处理，确认可以操作之后才完成操作</strong></p></li></ul><h4 id="2-元组约束"><a href="#2-元组约束" class="headerlink" title="2.元组约束"></a>2.元组约束</h4><ul><li>域约束：<ul><li>当前数据行，每个字段取值受其域约束：data type，取值范围，NOT NULL，UNIQUE等；</li></ul></li><li>业务规则约束<ul><li>1.当前行数据，不同字段的取值彼此之间存在关联约束；（家庭地址与邮政编码）</li><li>2.当前行数据，它受该表中已有行的约束；</li><li>3.当前行数据，它受其它表中已有行的约束</li></ul></li></ul><h4 id="3-触发器类型"><a href="#3-触发器类型" class="headerlink" title="3.触发器类型"></a>3.触发器类型</h4><ul><li>BEFORE触发器：在语句开始做任何增删改之前被触发</li><li>INSTEAD OF触发器：<strong>只能被定义在视图上，负责将对视图的修改需求转换成修改底层表</strong>，在语句开始做任何增删改之前被触发</li><li>AFTER触发器：在语句做完所有增删改之后被触发</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/image-20240411003151894.png" alt="image-20240411003151894"></p><h4 id="4-创建触发器-SQL"><a href="#4-创建触发器-SQL" class="headerlink" title="4.创建触发器(SQL)"></a>4.创建触发器(SQL)</h4><ul><li>BEFORE TRIGGER格式</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TRIGGER trigger_nameBEFORE INSERT ON table_nameREFERENCING NEW ROW AS newFOR EACH ROWBEGIN...END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>例：使用触发器实现每学期选课不超过25学分</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_insertEnrollBEFORE <span class="token keyword">INSERT</span> <span class="token keyword">ON</span>  enroll <span class="token comment">-- BEFORE:触发时间；INSERT:触发语句</span>REFERENCING NEW <span class="token keyword">ROW</span> <span class="token keyword">AS</span> new<span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span>creditAll <span class="token keyword">integer</span> <span class="token comment">-- 创建了一个int型变量creditAll</span><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>credit<span class="token punctuation">)</span> <span class="token keyword">INTO</span> creditAll  <span class="token keyword">FROM</span> course <span class="token keyword">WHERE</span> courseId <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> courseId <span class="token keyword">FROM</span> enroll <span class="token keyword">WHERE</span> studentId <span class="token operator">=</span> <span class="token variable">@new.studentId</span> <span class="token operator">AND</span> semester <span class="token operator">=</span><span class="token variable">@new.semester</span><span class="token punctuation">)</span> <span class="token operator">OR</span> courseId <span class="token operator">=</span> <span class="token variable">@new.courseId</span><span class="token punctuation">;</span><span class="token keyword">WHEN</span> <span class="token punctuation">(</span>creditAll  <span class="token operator">></span> <span class="token number">25</span> <span class="token punctuation">)</span>    raise_application_error<span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">,</span> <span class="token string">'这个学期已经选修学分'</span> <span class="token operator">+</span> @ creditAll<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>INSTEAD OF 格式</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_nameINSTEAD <span class="token keyword">OF</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> view_nameREFERENCING NEW <span class="token keyword">ROW</span> <span class="token keyword">AS</span> <span class="token keyword">row</span><span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>例：实现对视图执行插入操作</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_insertEmpINSTEAD <span class="token keyword">OF</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> staffREFERENCING NEW <span class="token keyword">ROW</span> <span class="token keyword">AS</span> new<span class="token keyword">FOR EACH ROW</span><span class="token keyword">WHEN</span> <span class="token punctuation">(</span><span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> dno <span class="token keyword">FROM</span> dept  <span class="token keyword">WHERE</span> dname <span class="token operator">=</span> <span class="token variable">@new.deptname</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>String deptno       <span class="token keyword">SELECT</span> dno <span class="token keyword">INTO</span> deptno <span class="token keyword">FROM</span> dept  <span class="token keyword">WHERE</span> dname <span class="token operator">=</span> <span class="token variable">@new.deptname</span>       <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Emp <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token variable">@new.e_no</span><span class="token punctuation">,</span> <span class="token variable">@new.name</span><span class="token punctuation">,</span><span class="token variable">@new.job</span><span class="token punctuation">,</span> <span class="token variable">@new.birthday</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">@deptno</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>AFTER 格式</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_name<span class="token keyword">AFTER</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">-- 插入、更新、删除(更新要指明字段,update of 字段 on table)</span>REFERENCING NEW <span class="token keyword">ROW</span> <span class="token keyword">AS</span> newOLD <span class="token keyword">ROW</span> <span class="token keyword">AS</span> old <span class="token comment">-- 新插入行和上一行，固定格式，要用哪个写哪个</span><span class="token keyword">FOR EACH ROW</span> <span class="token comment">-- 固定格式</span><span class="token comment">-- WHEN 条件</span><span class="token keyword">BEGIN</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">END</span><span class="token punctuation">;</span> <span class="token comment">-- 动作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>例：使用触发器来执行审计</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> cheatingEmployee<span class="token keyword">AFTER</span> <span class="token keyword">UPDATE</span> <span class="token keyword">OF</span> salary <span class="token keyword">ON</span> Emp <span class="token comment">-- 事件</span>REFERENCING OLD <span class="token keyword">ROW</span> <span class="token keyword">AS</span> oldNEW <span class="token keyword">ROW</span> <span class="token keyword">AS</span> new<span class="token keyword">FOR EACH ROW</span><span class="token keyword">WHEN</span> <span class="token punctuation">(</span><span class="token variable">@new.salary</span> <span class="token operator">></span> <span class="token variable">@old.salary</span><span class="token operator">*</span><span class="token number">1.1</span><span class="token punctuation">)</span> <span class="token comment">-- 条件</span>            <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> auditEmp     <span class="token comment">-- 动作</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token variable">@new.eno</span><span class="token punctuation">,</span> <span class="token keyword">date</span><span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">@new.salary</span><span class="token punctuation">,</span>                               <span class="token variable">@old.salary</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注：在BEGIN..END中间，或者是FOR EACH ROW后面，是可以使用WHEN和IF ELSE的，但是格式与c语言略有差异</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">WHEN</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">AND</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">OR</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">-- 没啥格式要求</span><span class="token keyword">IF</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">THEN</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">ELSE</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">-- ifelse的格式要有个then</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-完整性约束的表示"><a href="#5-完整性约束的表示" class="headerlink" title="5.完整性约束的表示"></a>5.完整性约束的表示</h4><blockquote><p>DBMS内部，所有完整性约束，都是用触发器来表示的</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> enroll_InsertBEFORE <span class="token keyword">INSERT</span>  <span class="token keyword">ON</span> enrollREFERENCING NEW <span class="token keyword">ROW</span> <span class="token keyword">AS</span> new<span class="token keyword">FOR EACH ROW</span><span class="token keyword">WHEN</span> <span class="token punctuation">(</span><span class="token operator">NOT</span> EXIST <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> sudentNo <span class="token operator">=</span> <span class="token variable">@new.studentNo</span> <span class="token operator">OR</span>  <span class="token operator">NOT</span> EXIST <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> course <span class="token keyword">WHERE</span> courseNo <span class="token operator">=</span> <span class="token variable">@new.courseNo</span><span class="token punctuation">)</span>           raise_application_error<span class="token punctuation">(</span>“违背外键约束”<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>一个主键，对应几个触发器？</li><li>一个外键，对应几个触发器？</li></ul><h4 id="6-删除与修改"><a href="#6-删除与修改" class="headerlink" title="6.删除与修改"></a>6.删除与修改</h4><ul><li>删除</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> trigger_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>修改</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TRIGGER</span> trigger_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>其他诸如table,view,procedure都是用drop和alter完成删除与修改的</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown会不了一点</title>
      <link href="/2024/03/02/markdown-hui-bu-liao-yi-dian/"/>
      <url>/2024/03/02/markdown-hui-bu-liao-yi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><hr><p>语法格式： <code>&#39;#&#39;+&#39;空格&#39;+&#39;文本&#39;</code></p><p>注：</p><ul><li><code>#</code>和标题之间建议保留一个字符的空格</li><li>一般情况下，文章标题会被系统渲染为一级标题，避免在文章中使用一级标题</li></ul><h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h2><hr><p>无序列表：<code>&#39;-&#39;+空格+文本</code></p><p>有序列表：<code>&#39;1.&#39;+空格+文本</code></p><h2 id="3-链接和图片"><a href="#3-链接和图片" class="headerlink" title="3.链接和图片"></a>3.链接和图片</h2><hr><p>链接：<code>[显示文本]+(链接地址)</code></p><p>图片：<code>&#39;!&#39;+[显示文本]+(链接地址)</code></p><ul><li>如果希望图片能够部署在网页上<ul><li>方法1：利用hexo-asset插件，使用如下格式：</li><li><code>&#123;% asset_img xxx.jpg 图片名后可写图片描述 %&#125;</code></li><li>方法2：上传到github图床上，将图片本地地址转成网络地址（当下使用）</li></ul></li></ul><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/SomeFnone/blog_pic@main/img/paperwall_4.jpg" alt="paperwall_4"></p><h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h2><hr><p>语法格式：<code>&#39;&gt;&#39;+引用内容</code></p><h2 id="5-行内代码"><a href="#5-行内代码" class="headerlink" title="5.行内代码"></a>5.行内代码</h2><hr><p>语法格式：用 <strong>&#96;</strong> 将代码包起来即可</p><h2 id="6-代码段与高亮"><a href="#6-代码段与高亮" class="headerlink" title="6.代码段与高亮"></a>6.代码段与高亮</h2><hr><p>代码段语法格式：</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;编程语言这是代码段&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token keyword">extends</span> <span class="token class-name">Model</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-粗体和斜体"><a href="#7-粗体和斜体" class="headerlink" title="7.粗体和斜体"></a>7.粗体和斜体</h2><hr><p>粗体：用两个<code>**</code>包含一段文字</p><p>斜体：用一个<code>*</code>包含一段文字</p><p>示例：</p><p><strong>粗体</strong></p><p><em>斜体</em></p><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h2><hr><p>Markdown制作表格使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行。</p><p>语法格式如下：</p><p>| 表头 | 表头 |</p><p>| — | — |</p><p>| 单元格 | 单元格 |</p><p>| 单元格 | 单元格 |</p><p>注：</p><ul><li>自动生成太香啦😍</li></ul><p>示例：</p><table><thead><tr><th align="left">表头</th><th align="left">表头</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="left">单元格</td></tr><tr><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="9-上-下标"><a href="#9-上-下标" class="headerlink" title="9.上&#x2F;下标"></a>9.上&#x2F;下标</h2><hr><ul><li>用<code>&lt;sub&gt;</code>和<code>&lt;/sub&gt;</code>包含下标文字<ul><li>H<sub>2</sub>O</li></ul></li><li>用<code>&lt;sup&gt;</code>和<code>&lt;/sup&gt;</code>包含上标文字<ul><li>X<sup>2</sup>+2X+1&#x3D;0</li></ul></li></ul><h2 id="10-注释"><a href="#10-注释" class="headerlink" title="10.注释"></a>10.注释</h2><hr><pre class="line-numbers language-none"><code class="language-none">[&#x2F;&#x2F;]: # (哈哈我是注释，不会在浏览器中显示。)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="11-数学符号"><a href="#11-数学符号" class="headerlink" title="11.数学符号"></a>11.数学符号</h2><p><a href="https://blog.csdn.net/qq_46311811/article/details/122544565">https://blog.csdn.net/qq_46311811/article/details/122544565</a></p><p><a href="https://www.cnblogs.com/Xuxiaokang/p/15654336.html">https://www.cnblogs.com/Xuxiaokang/p/15654336.html</a></p><hr><h2 id="12-注意事项"><a href="#12-注意事项" class="headerlink" title="12.注意事项"></a>12.注意事项</h2><p>1.代码块前不要用列表，网页会因此识别不出代码块语言类型，导致排版出问题！</p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
